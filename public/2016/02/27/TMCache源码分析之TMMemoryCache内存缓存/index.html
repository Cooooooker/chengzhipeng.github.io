<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="TMCache,缓存," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:

内存缓存: 快速, 读写数据量小
磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)

那缓存的目的是什么呢? 大概分为以下几点:

复用数据,避免重复计算.
缓解服务端压力.
提高用户体验,比如离线浏览, 节省流量等等.

简言之,缓存的目的就是:

以空间换时间.">
<meta property="og:type" content="article">
<meta property="og:title" content="TMCache源码分析<一> TMMemoryCache内存缓存">
<meta property="og:url" content="http://yoursite.com/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/index.html">
<meta property="og:site_name" content="Cheng'blog">
<meta property="og:description" content="缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:

内存缓存: 快速, 读写数据量小
磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)

那缓存的目的是什么呢? 大概分为以下几点:

复用数据,避免重复计算.
缓解服务端压力.
提高用户体验,比如离线浏览, 节省流量等等.

简言之,缓存的目的就是:

以空间换时间.">
<meta property="og:image" content="https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67">
<meta property="og:updated_time" content="2017-02-27T16:17:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TMCache源码分析<一> TMMemoryCache内存缓存">
<meta name="twitter:description" content="缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:

内存缓存: 快速, 读写数据量小
磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)

那缓存的目的是什么呢? 大概分为以下几点:

复用数据,避免重复计算.
缓解服务端压力.
提高用户体验,比如离线浏览, 节省流量等等.

简言之,缓存的目的就是:

以空间换时间.">
<meta name="twitter:image" content="https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/"/>





  <title> TMCache源码分析<一> TMMemoryCache内存缓存 | Cheng'blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cheng'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengzhipeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cheng'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                TMCache源码分析<一> TMMemoryCache内存缓存
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-27T00:00:00+08:00">
                2016-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:</p>
<ul>
<li>内存缓存: 快速, 读写数据量小</li>
<li>磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)</li>
</ul>
<p>那缓存的目的是什么呢? 大概分为以下几点:</p>
<ul>
<li>复用数据,避免重复计算.</li>
<li>缓解服务端压力.</li>
<li>提高用户体验,比如离线浏览, 节省流量等等.</li>
</ul>
<p>简言之,缓存的目的就是:</p>
<blockquote>
<p>以空间换时间.  </p>
</blockquote>
<a id="more"></a>
<p>目前 gitHub 上开源了很多缓存框架, 著名的 <a href="https://github.com/tumblr/TMCache" target="_blank" rel="external">TMCache</a>, <a href="https://github.com/pinterest/PINCache" target="_blank" rel="external">PINCache</a>, <a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>等, 接下来我会逐一分析他们的源码实现, 对比它们的优缺点.  </p>
<p><a href="https://github.com/tumblr/TMCache" target="_blank" rel="external">TMCache</a>, <a href="https://github.com/pinterest/PINCache" target="_blank" rel="external">PINCache</a>, <a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>基本框架结构都相同, 接口 API 类似, 所以只要会使用其中一个框架, 另外两个上手起来非常容易, 但是三个框架的内部实现原理略有不同.</p>
<h3 id="TMMemoryCache"><a href="#TMMemoryCache" class="headerlink" title="TMMemoryCache"></a>TMMemoryCache</h3><p><code>TMMemoryCache</code> 是 <code>TMCache</code> 框架中针对内存缓存的实现, 在系统 <code>NSCache</code> 缓存的基础上增加了很多方法和属性, 比如数量限制、内存总容量限制、缓存存活时间限制、内存警告或应用退到后台时清空缓存等功能. 并且<code>TMMemoryCache</code>能够同步和异步的对内存数据进行操作,最重要的一点是<code>TMMemoryCache</code>是线程安全的, 能够确保在多线程情况下数据的安全性.  </p>
<p>首先来看一下 <code>TMMemoryCache</code> 提供什么功能, 按照功能来分析它的实现原理:</p>
<ol>
<li>同步/异步的存储对象到内存中.</li>
<li>同步/异步的从内存中获取对象.</li>
<li>同步/异步的从内存中删除指定 key 的对象,或者全部对象.</li>
<li>增加/删除数据, 内存警告, 退回后台的异步回调事件.</li>
<li>设置内存缓存使用上限.</li>
<li>设置内存缓存过期时间.</li>
<li>内存警告或退到后台清空缓存.</li>
<li>根据时间或缓存大小来清空指定时间段或缓存范围的数据.</li>
</ol>
<h3 id="同步-异步的存储对象到内存中"><a href="#同步-异步的存储对象到内存中" class="headerlink" title="同步/异步的存储对象到内存中"></a>同步/异步的存储对象到内存中</h3><p>相关 API:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key withCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">// 异步</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block;</div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key withCost:(<span class="built_in">NSUInteger</span>)cost block:(TMMemoryCacheObjectBlock)block;</div></pre></td></tr></table></figure>
<h4 id="异步存储"><a href="#异步存储" class="headerlink" title="异步存储"></a>异步存储</h4><p>首先看一下异步存储对象, 因为同步存储里面会调用异步存储操作, 采用 <code>dispatch_semaphore</code> 信号量的方式强制把异步操作转换成同步操作.<br>内存缓存的核心是创建字典把需要存储的对象按照 key, value的形式存进字典中, 这是一条主线, 然后在主线上分发出许多分支, 比如:缓存时间, 缓存大小, 线程安全等, 都是围绕着这条主线来的. TMMemoryCache 也不例外, 在调用<code>+ (instancetype)sharedCache</code>方法创建并初始化的时候会创建三个可变字典<code>_dictionary</code>, <code>_dates</code>, <code>_costs</code>,这三个字典分别保存三种键值对:   </p>
<table>
<thead>
<tr>
<th>-</th>
<th>Key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>_dictionary</td>
<td>存储对象的 key</td>
<td>存储对象的值</td>
</tr>
<tr>
<td>_dates</td>
<td>存储对象的 key</td>
<td>存储对象时的时间</td>
</tr>
<tr>
<td>_costs</td>
<td>存储对象的 key</td>
<td>存储对象所占内存大小</td>
</tr>
</tbody>
</table>
<p>实现数据存储的核心方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key withCost:(<span class="built_in">NSUInteger</span>)cost block:(TMMemoryCacheObjectBlock)block &#123;</div><div class="line">    <span class="built_in">NSDate</span> *now = [[<span class="built_in">NSDate</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!key || !object)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    __<span class="keyword">weak</span> TMMemoryCache *weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 0.竞态条件下, 在并发队列中保护写操作</span></div><div class="line">    dispatch_barrier_async(_queue, ^&#123;</div><div class="line">        TMMemoryCache *strongSelf = weakSelf;</div><div class="line">        <span class="keyword">if</span> (!strongSelf)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 1.调用 will add block</span></div><div class="line">        <span class="keyword">if</span> (strongSelf-&gt;_willAddObjectBlock)</div><div class="line">            strongSelf-&gt;_willAddObjectBlock(strongSelf, key, object);</div><div class="line"></div><div class="line">        <span class="comment">// 2.存储 key 对应的数据,时间,缓存大小到相应的字典中</span></div><div class="line">        [strongSelf-&gt;_dictionary setObject:object forKey:key];</div><div class="line">        [strongSelf-&gt;_dates setObject:now forKey:key];</div><div class="line">        [strongSelf-&gt;_costs setObject:@(cost) forKey:key];</div><div class="line"></div><div class="line">        _totalCost += cost;</div><div class="line"></div><div class="line">        <span class="comment">// 3.调用 did add block</span></div><div class="line">        <span class="keyword">if</span> (strongSelf-&gt;_didAddObjectBlock)</div><div class="line">            strongSelf-&gt;_didAddObjectBlock(strongSelf, key, object);</div><div class="line"></div><div class="line">        <span class="comment">// 4.根据时间排序来清空指定缓存大小的内存</span></div><div class="line">        <span class="keyword">if</span> (strongSelf-&gt;_costLimit &gt; <span class="number">0</span>)</div><div class="line">            [strongSelf trimToCostByDate:strongSelf-&gt;_costLimit block:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 5.异步回调</span></div><div class="line">        <span class="keyword">if</span> (block) &#123;</div><div class="line">            __<span class="keyword">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class="line">            <span class="built_in">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</div><div class="line">                TMMemoryCache *strongSelf = weakSelf;</div><div class="line">                <span class="keyword">if</span> (strongSelf)</div><div class="line">                    block(strongSelf, key, object);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中我标出了核心存储方法做了几件事, 其中最为核心的是保证线程安全的<code>dispatch_barrier_async</code>方法, 在 GCD 中称之为<code>栅栏</code>方法, 一般跟<code>并发队列</code>一起用, 在多线程中对同一资源的竞争条件下保护共享资源, 确保在同一时间片段只有一个线程<code>写</code>资源, 这是不扩展讲 GCD 的相关知识.</p>
<blockquote>
<p>dispatch_barrier_async 方法一般都是跟并发队列搭配使用,下面的图解很清晰(<code>侵删</code>), 在并发队列中有很多任务(block), 这些block都是按照 FIFO 的顺序执行的, 当要执行用 dispatch_barrier_async 方法提交到并发队列queue的 block 的时候, 该并发队列暂时会’卡住’, 等待之前的任务 block 执行完毕, 再执行dispatch_barrier_async 提交的 block, 在此 block 之后提交到并发队列queue的 block 不会被执行,会一直等待 dispatch_barrier_async block 执行完毕后才开始并发执行, 我们可以看出, 在并发队列遇到 dispatch_barrier_async block 时就处于一直串行队列状态, 等待执行完毕后又开始并发执行.<br>由于TMMemoryCache中所有的读写操作都是在一个 concurrent queue(并发队列)中, 所以使用 <code>dispatch_barrier_async</code> 能够保证写操作的线程安全, 在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心, 但也是它最大的毛病, 容易造成性能下降和死锁.<br><img src="https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67" alt="dispatch_barrier_async"></p>
</blockquote>
<p>从上面代码中可以看出, 在该方法中把需要存储的数据按照 key-value 的形式存储进了<code>_dictionary</code>字典中, 其它操作无非就是增加功能的配料,后面会抽丝剥茧的捋清楚, 到此处我们的任务完成, 知道是怎么存储数据的, 非常简单:</p>
<ol>
<li>使用 GCD 的 <code>dispatch_barrier_async</code> 方法保证写操作线程安全.</li>
<li>把需要存储的数据存进可变字典中.</li>
</ol>
<h4 id="同步存储"><a href="#同步存储" class="headerlink" title="同步存储"></a>同步存储</h4><p>根据上文所说, 同步存储中会调用异步存储操作, 来看一下代码:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    <span class="keyword">if</span> (!object || !key)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 1.创建信号量</span></div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 2.异步存数据</span></div><div class="line">    [<span class="keyword">self</span> setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> object) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 3.异步存储完毕发送 signal 信号</span></div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// 4.等待异步存储完毕</span></div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面代码可以看出,同步的存储数据使用了 GCD 的 <code>dispatch_semaphore_t</code> 信号量, 这是一个非常古老又复杂的线程概念, 有兴趣的话可以看看 <code>&lt;&lt;UNIX 环境高级编程&gt;&gt;</code> 这本经典之作, 因为它的复杂是建立在操作系统的复杂性上的.但是这并不影响我们使用 dispatch_semaphore_t 信号量. 怎么使用 GCD 的信号量以及原理下面大概描述一下:</p>
<blockquote>
<p>信号量在竞态条件下能够保证线程安全,在创建信号量 dispatch_semaphore_create 的时候设置信号量的值, 这个值表示允许多少个线程可同时访问公共资源, 就好比我们的车位一样, 线程就是我们的车子,这个信号量就是停车场的管理者, 他知道什么时候有多少车位, 是不是该把车子放进停车场, 当没有车位或者车位不足时, 这个管理员就会把司机卡在停车场外不准进, 那么被拦住的司机按照 FIFO 的队列排着队, 有足够位置的时候,管理员就方法闸门, 大吼一声: 孩子们去吧. 那么肯定有司机等不耐烦了, 就想着等十分钟没有车位就不等了,就可以在 dispatch_semaphore_wait 方法中设置等待时间, 等待超过设置时间就不等待.<br>那么把上面的场景应用在 dispatch_semaphore_create 信号量中就很容易理解了, 创建信号量并设置最大并发线程数, dispatch_semaphore_wait 设置等待时间,在等待时间未到达或者信号量值没有达到初始值时会一直等待, 调用 dispatch_semaphore_wait 方法会使信号量的值+1, 表示增加一个线程等待处理共用资源, 当 dispatch_semaphore_signal 时会使信号量的值-1, 表示该线程不再占用共用资源.</p>
</blockquote>
<p>根据上面对 dispatch_semaphore_t 信号量的描述可知, 信号量的初始值为0,当前线程执行 dispatch_semaphore_wait 方法就会一直等待, 此时就相当于同步操作, 当在并发队列中异步存储完数据调用dispatch_semaphore_signal 方法, 此时信号量的值变成0,跟初始值一样,当前线程立即结束等待, 同步设置方法执行完毕.  </p>
<p>其实同步实现存储数据的方式很多, 主要就是要串行执行写操作采用 dispatch_sync的方式, 但是基于 TMMemoryCache 所有的操作都是在并发队列上的, 所以才采用信号量的方式.</p>
<p>其实只要知道<code>dispatch_barrier_async</code>, <code>dispatch_semaphore_t</code> 的用法,后面的都可以不用看了, 自己去找源码看看就明白了.</p>
<hr>
<p>休息一下吧,后面的简单了</p>
<hr>
<h3 id="同步-异步的从内存中获取对象"><a href="#同步-异步的从内存中获取对象" class="headerlink" title="同步/异步的从内存中获取对象."></a>同步/异步的从内存中获取对象.</h3><p>有了上面的同步/异步存储的理论, 那么同步/异步获取对象简直易如反掌, 不就是从<code>_dictionary</code>字典中根据 key 取出对应的 value 值, 在取的过程中加以线程安全, will/did 之类辅助处理的 block 操作.</p>
<h4 id="异步获取数据"><a href="#异步获取数据" class="headerlink" title="异步获取数据"></a>异步获取数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block &#123;</div><div class="line">    <span class="built_in">NSDate</span> *now = [[<span class="built_in">NSDate</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key || !block)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    __<span class="keyword">weak</span> TMMemoryCache *weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 1.异步加载存储数据</span></div><div class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</div><div class="line">        TMMemoryCache *strongSelf = weakSelf;</div><div class="line">        <span class="keyword">if</span> (!strongSelf)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 2.根据 key 找到value</span></div><div class="line">        <span class="keyword">id</span> object = [strongSelf-&gt;_dictionary objectForKey:key];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (object) &#123;</div><div class="line">            __<span class="keyword">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class="line">            <span class="comment">// 3.也用栅栏保护写操作, 保证在写的时候没有线程在访问共享资源</span></div><div class="line">            dispatch_barrier_async(strongSelf-&gt;_queue, ^&#123;</div><div class="line">                TMMemoryCache *strongSelf = weakSelf;</div><div class="line">                <span class="keyword">if</span> (strongSelf)</div><div class="line">                    <span class="comment">// 4.更新数据的最后操作时间(当前时间)</span></div><div class="line">                    [strongSelf-&gt;_dates setObject:now forKey:key];</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 5.回调</span></div><div class="line">        block(strongSelf, key, object);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据代码中注释可知,除了拿到 key 值对应的 value, 还更新了此数据最后操作时间, 这有什么用呢? 其实是为了记录数据最后的操作时间, 后面会根据这个最后操作时间来删除数据等一系列根据时间排序的操作.最后一步是回调, 我们可以看到, TMMemoryCache所有的读写和回调操作都放在同一个并发队列中,这就为以后性能下降和死锁埋下伏笔.</p>
<h4 id="同步获取数据"><a href="#同步获取数据" class="headerlink" title="同步获取数据"></a>同步获取数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (!key)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    __block <span class="keyword">id</span> objectForKey = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 采用信号量强制转化成同步操作</span></div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> objectForKey:key block:^(TMMemoryCache *cache, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> object) &#123;</div><div class="line">        objectForKey = object;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objectForKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步获取数据也是通过 <code>dispatch_semaphore_t</code> 信号量的方式,把异步获取数据的操作强制转成同步获取, 跟同步存储数据的原理相同.</p>
<h3 id="同步-异步的从内存中删除指定-key-的对象-或者全部对象"><a href="#同步-异步的从内存中删除指定-key-的对象-或者全部对象" class="headerlink" title="同步/异步的从内存中删除指定 key 的对象,或者全部对象."></a>同步/异步的从内存中删除指定 key 的对象,或者全部对象.</h3><p>删除操作也不例外:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block &#123;</div><div class="line">    <span class="keyword">if</span> (!key)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    __<span class="keyword">weak</span> TMMemoryCache *weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 1."栅栏"方法,保证线程安全</span></div><div class="line">    dispatch_barrier_async(_queue, ^&#123;</div><div class="line">        TMMemoryCache *strongSelf = weakSelf;</div><div class="line">        <span class="keyword">if</span> (!strongSelf)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 2.根据 key 删除 value</span></div><div class="line">        [strongSelf removeObjectAndExecuteBlocksForKey:key];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (block) &#123;</div><div class="line">            __<span class="keyword">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class="line">            </div><div class="line">            <span class="comment">// 3.完成后回调</span></div><div class="line">            <span class="built_in">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</div><div class="line">                TMMemoryCache *strongSelf = weakSelf;</div><div class="line">                <span class="keyword">if</span> (strongSelf)</div><div class="line">                    block(strongSelf, key, <span class="literal">nil</span>);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// private API</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectAndExecuteBlocksForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">id</span> object = [_dictionary objectForKey:key];</div><div class="line">    <span class="built_in">NSNumber</span> *cost = [_costs objectForKey:key];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_willRemoveObjectBlock)</div><div class="line">        _willRemoveObjectBlock(<span class="keyword">self</span>, key, object);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cost)</div><div class="line">        _totalCost -= [cost unsignedIntegerValue];</div><div class="line"></div><div class="line">    <span class="comment">// 删除所有跟此数据相关的缓存: value, date, cost</span></div><div class="line">    [_dictionary removeObjectForKey:key];</div><div class="line">    [_dates removeObjectForKey:key];</div><div class="line">    [_costs removeObjectForKey:key];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_didRemoveObjectBlock)</div><div class="line">        _didRemoveObjectBlock(<span class="keyword">self</span>, key, <span class="literal">nil</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是 <code>- (void)removeObjectAndExecuteBlocksForKey</code> 是共用私有方法, 删除跟 key 相关的所有缓存, 后面的删除操作还会用到此方法.</p>
<h3 id="设置内存缓存使用上限"><a href="#设置内存缓存使用上限" class="headerlink" title="设置内存缓存使用上限"></a>设置内存缓存使用上限</h3><p>TMMemoryCache 提供<code>costLimit</code>属性来设置内存缓存使用上限, 这个也是 NSCache 不具备的功能,来看一下跟此属性相关的方法以及实现,代码中有详细解释:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getter</span></div><div class="line">- (<span class="built_in">NSUInteger</span>)costLimit &#123;</div><div class="line">    __block <span class="built_in">NSUInteger</span> costLimit = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 要想通过函数返回值传递回去,那么必须同步执行,所以使用dispatch_sync同步获取内存使用上限</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</div><div class="line">        costLimit = _costLimit;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> costLimit;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// setter</span></div><div class="line">- (<span class="keyword">void</span>)setCostLimit:(<span class="built_in">NSUInteger</span>)costLimit &#123;</div><div class="line">    __<span class="keyword">weak</span> TMMemoryCache *weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">// "栅栏"方法保护写操作</span></div><div class="line">    dispatch_barrier_async(_queue, ^&#123;</div><div class="line">        TMMemoryCache *strongSelf = weakSelf;</div><div class="line">        <span class="keyword">if</span> (!strongSelf)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 设置内存上限</span></div><div class="line">        strongSelf-&gt;_costLimit = costLimit;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (costLimit &gt; <span class="number">0</span>)</div><div class="line">            <span class="comment">// 根据时间排序来削减内存缓存,以达到设置的内存缓存上限的目的</span></div><div class="line">            [strongSelf trimToCostLimitByDate:costLimit];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToCostLimitByDate:(<span class="built_in">NSUInteger</span>)limit &#123;</div><div class="line">    <span class="keyword">if</span> (_totalCost &lt;= limit)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 按照时间的升序来排列 key</span></div><div class="line">    <span class="built_in">NSArray</span> *keysSortedByDate = [_dates keysSortedByValueUsingSelector:<span class="keyword">@selector</span>(compare:)];</div><div class="line"></div><div class="line">    <span class="comment">// oldest objects first</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> keysSortedByDate) &#123;</div><div class="line">        [<span class="keyword">self</span> removeObjectAndExecuteBlocksForKey:key];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (_totalCost &lt;= limit)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>- (void)trimToCostLimitByDate:(NSUInteger)limit</code> 方法的作用:</p>
<ol>
<li>如果目前已使用的内存大小小于需要设置的内存上线,则不删除数据,否则删除’最老’的数据,让已使用的内存大小不超过设置的内存上限.</li>
<li>按照存储的数据最近操作的最后时间进行升序排序,即最近操作的数据对应的 key 排最后.</li>
<li>如果已经超过内存上限, 则根据 key 值删除数据, 先删除操作时间较早的数据.</li>
</ol>
<p>从这里就会恍然大悟, 之前设置的 <code>_date</code> 数组终于派上用场了,如果需要删除数据则按照时间的先后顺序来删除,也算是一种优先级策略吧.</p>
<h3 id="设置内存缓存过期时间"><a href="#设置内存缓存过期时间" class="headerlink" title="设置内存缓存过期时间"></a>设置内存缓存过期时间</h3><p>TMMemoryCache 提供<code>ageLimit</code>属性来设置缓存过期时间,根据上面<code>costLimit</code>属性可以猜想一下<code>ageLimit</code>是怎么实现的,既然是要设置缓存过期时间, 那么我设置缓存过期时间 <code>ageLimit = 10</code> 10秒钟,说明距离当前时间之前的10秒的数据已经过期, 需要删除掉; 再过10秒又要当前时间删除之前10秒存的数据,我们知道删除只需要找到 key 就行,所以就必须通过<code>_date</code>字典找到过期的 key, 再删除数据.由此可知需要一个定时器,每过10秒删除一次,完成一个定时任务.<br>上面只是我们的猜想,来看看代码是不是这么实现的呢?我们只需看核心的操作方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)trimToAgeLimitRecursively &#123;</div><div class="line">    <span class="keyword">if</span> (_ageLimit == <span class="number">0.0</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 说明距离现在 ageLimit 秒的缓存应该被清除掉了</span></div><div class="line">    <span class="built_in">NSDate</span> *date = [[<span class="built_in">NSDate</span> alloc] initWithTimeIntervalSinceNow:-_ageLimit];</div><div class="line">    [<span class="keyword">self</span> trimMemoryToDate:date];</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> TMMemoryCache *weakSelf = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 延迟 ageLimit 秒, 又异步的清除缓存</span></div><div class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_ageLimit * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">    dispatch_after(time, _queue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">        TMMemoryCache *strongSelf = weakSelf;</div><div class="line">        <span class="keyword">if</span> (!strongSelf)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        __<span class="keyword">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class="line">        </div><div class="line">        dispatch_barrier_async(strongSelf-&gt;_queue, ^&#123;</div><div class="line">            TMMemoryCache *strongSelf = weakSelf;</div><div class="line">            [strongSelf trimToAgeLimitRecursively];</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">;``  </div><div class="line">上面的代码验证了我们的猜想,但是在不断的创建定时器,不断的在并行队列中使用`dispatch_barrier_async`栅栏方法提交递归 block, 天啦噜...如果设置的 ageLimit 很小,可想而知性能消耗会非常大!</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="meta">### 内存警告或退到后台清空缓存</span></div><div class="line">内存警告和退到后台需要监听系统通知,`<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span>`和`<span class="built_in">UIApplicationDidEnterBackgroundNotification</span>`, 然后执行清除操作方法`removeAllObjects`,只不过在相应的位置执行对应的 will/did 之类的 block 操作.</div><div class="line"></div><div class="line"><span class="meta">### 根据时间或缓存大小来清空指定时间段或缓存范围的数据</span></div><div class="line">这两类方法主要是为了更加灵活的使用 TMMemoryCache,指定一个时间或者内存大小,会自动删除时间点之前和大于指定内存大小的数据.</div><div class="line">相关 API:</div><div class="line"></div><div class="line">```Objc</div><div class="line"><span class="comment">// 清空 date 之前的数据</span></div><div class="line">- (<span class="keyword">void</span>)trimToDate:(<span class="built_in">NSDate</span> *)date block:(TMMemoryCacheBlock)block;</div><div class="line"><span class="comment">// 清空数据,让已使用内存大小为cost </span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost block:(TMMemoryCacheBlock)block;</div></pre></td></tr></table></figure>
<p>删除指定时间点有两点注意:</p>
<ul>
<li>如果指定的时间点为 <code>[NSDate distantPast]</code> 表示最早能表示的时间,说明清空全部数据.</li>
<li>如果不是最早时间,把<code>_date</code>中的 key 按照升序排序,再遍历排序后的 key 数组,判断跟指定时间的关系,如果比指定时间更早则删除, 即删除指定时间节点之前的数据.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)trimMemoryToDate:(<span class="built_in">NSDate</span> *)trimDate &#123;</div><div class="line">    <span class="comment">// 字典中存放的顺序不是按照顺序存放的, 所以按照一定格式排序, 根据 value 升序的排 key 值顺序, 也就是说根据时间的升序来排 key, 数组中第一个值是最早的时间的值.</span></div><div class="line">    <span class="built_in">NSArray</span> *keysSortedByDate = [_dates keysSortedByValueUsingSelector:<span class="keyword">@selector</span>(compare:)];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> keysSortedByDate) &#123; <span class="comment">// oldest objects first</span></div><div class="line">        <span class="built_in">NSDate</span> *accessDate = [_dates objectForKey:key];</div><div class="line">        <span class="keyword">if</span> (!accessDate)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 找出每个时间的然后跟要删除的时间点进行比较, 如果比删除时间早则删除</span></div><div class="line">        <span class="keyword">if</span> ([accessDate compare:trimDate] == <span class="built_in">NSOrderedAscending</span>) &#123; <span class="comment">// older than trim date</span></div><div class="line">            [<span class="keyword">self</span> removeObjectAndExecuteBlocksForKey:key];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存缓存是很简单的, 核心就是 key-value 的形式存储数据进字典,再辅助设置内存上限,缓存时间,各类 will/did block 操作, 最重要的是要实现线程安全.</p>
<p>欢迎大家斧正!</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/TMCache/" rel="tag"># TMCache</a>
          
            <a href="/tags/缓存/" rel="tag"># 缓存</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/02/13/Swift中安全优雅的使用UserDefaults/" rel="next" title="Swift中安全优雅的使用UserDefaults">
                <i class="fa fa-chevron-left"></i> Swift中安全优雅的使用UserDefaults
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/03/TMCache源码分析之TMDiskCache磁盘缓存/" rel="prev" title="TMCache源码分析<二> TMDiskCache磁盘缓存">
                TMCache源码分析<二> TMDiskCache磁盘缓存 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpeg"
               alt="chengzhipeng" />
          <p class="site-author-name" itemprop="name">chengzhipeng</p>
           
              <p class="site-description motion-element" itemprop="description">格物致知</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#TMMemoryCache"><span class="nav-number">1.</span> <span class="nav-text">TMMemoryCache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步-异步的存储对象到内存中"><span class="nav-number">2.</span> <span class="nav-text">同步/异步的存储对象到内存中</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异步存储"><span class="nav-number">2.1.</span> <span class="nav-text">异步存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步存储"><span class="nav-number">2.2.</span> <span class="nav-text">同步存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步-异步的从内存中获取对象"><span class="nav-number">3.</span> <span class="nav-text">同步/异步的从内存中获取对象.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异步获取数据"><span class="nav-number">3.1.</span> <span class="nav-text">异步获取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步获取数据"><span class="nav-number">3.2.</span> <span class="nav-text">同步获取数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步-异步的从内存中删除指定-key-的对象-或者全部对象"><span class="nav-number">4.</span> <span class="nav-text">同步/异步的从内存中删除指定 key 的对象,或者全部对象.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置内存缓存使用上限"><span class="nav-number">5.</span> <span class="nav-text">设置内存缓存使用上限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置内存缓存过期时间"><span class="nav-number">6.</span> <span class="nav-text">设置内存缓存过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengzhipeng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
