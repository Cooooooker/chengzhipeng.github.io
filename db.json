{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ba85e1fc54644e4d58ad79cd8aa2cc3fbca8ce40","modified":1488213386000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1488205988000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1488205988000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1488205988000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1488205988000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1488205988000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1488205988000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1488205988000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1488205988000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1488205988000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1488205988000},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1488205988000},{"_id":"themes/next/_config.yml","hash":"b1a9084227c5afaafb7d25ab0d547debd44b674b","modified":1488208973000},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1488205988000},{"_id":"source/_posts/RunLoop浅析.md","hash":"566150cb2747afcf3d2747be7ea0ef9b30566357","modified":1488253425000},{"_id":"source/_posts/.DS_Store","hash":"c970050044e55018db2a79e1ccf00eddb2aaff22","modified":1488207643000},{"_id":"source/_posts/Swift在扩展中关联对象.md","hash":"e24e36e48a90c7b887b3d4f302ff148de954ce78","modified":1488212330000},{"_id":"source/_posts/Swift中安全优雅的使用UserDefaults.md","hash":"82adc4926400b28745893951a888c663bf31db31","modified":1488212476000},{"_id":"source/_posts/TMCache源码分析之TMDiskCache磁盘缓存.md","hash":"fecda78a69f1597bf7a2f79e7d34c4a0b35a6d7d","modified":1488213278000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1488205988000},{"_id":"source/categories/index.md","hash":"d90815c7519f972977cf590cfa4756cbc35f1aec","modified":1488208411000},{"_id":"source/tags/index.md","hash":"6e933dc79fd355709536695be718981ce0f7bece","modified":1488208400000},{"_id":"source/_posts/TMCache源码分析之TMMemoryCache内存缓存.md","hash":"4d5644c491b470b4772671b23df9d7a44aee8b8a","modified":1488212222000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1488205988000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1488205212000},{"_id":"themes/next/.git/index","hash":"cd148bf5cd9f5e868ee9d99d4502e64bdb928095","modified":1488212572000},{"_id":"themes/next/.git/packed-refs","hash":"3b294c9a0cc5368711d2c44e1441b4e92aeb2c65","modified":1488205988000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1488205988000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1488205988000},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1488205988000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1488205988000},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1488205988000},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1488205988000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1488205988000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1488205988000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1488205988000},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1488205988000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1488205988000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1488205988000},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1488205988000},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1488205988000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1488205988000},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1488205988000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1488205988000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1488205988000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1488205988000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1488205988000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1488205988000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1488205988000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1488205988000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1488205988000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1488205988000},{"_id":"themes/next/source/404.html","hash":"5ec9d3385706cccae043d9d2db0eecc6afa59f20","modified":1488208784000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1488205988000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1488205988000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1488205988000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1488205212000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1488205212000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1488205212000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1488205212000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1488205212000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1488205212000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1488205212000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1488205212000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1488205212000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1488205212000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1488205212000},{"_id":"themes/next/.git/logs/HEAD","hash":"1a21ec8d27ad6ca50363ee7acfcdc6052db8965e","modified":1488205988000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1488205988000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1488205988000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1488205988000},{"_id":"themes/next/layout/_macro/post.swig","hash":"2c2efe44ea013030f3ce5da7bfdeddb74489eb6e","modified":1488205988000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1488205988000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1488205988000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1488205988000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1488205988000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1488205988000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1488205988000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1488205988000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1488205988000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1488205988000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1488205988000},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1488205988000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1488205988000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1488205988000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1488205988000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1488205988000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1488205988000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1488205988000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1488205988000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1488205988000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1488205988000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1488205988000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1488205988000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1488205988000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1488205988000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1488205988000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1488205988000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1488205988000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1488205988000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1488205988000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1488205988000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1488205988000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1488205988000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1488205988000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1488205988000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1488205988000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1488205988000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488205988000},{"_id":"themes/next/.git/refs/heads/master","hash":"7f4a0b344aa33ef4c45dad7046cb1e24ee1459fe","modified":1488205988000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1488205988000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1488205988000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1488205988000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1488205988000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1488205988000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1488205988000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1488205988000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1488205988000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1488205988000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1488205988000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1488205988000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1488205988000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1488205988000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1488205988000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1488205988000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1488205988000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1488205988000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1488205988000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7c76d93605e2b685274400afe51c55cc651486e","modified":1488205988000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1488205988000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1488205988000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1488205988000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1488205988000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1488205988000},{"_id":"themes/next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1488205988000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1488205988000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1488205988000},{"_id":"themes/next/source/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1488205988000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1488205988000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1488205988000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1488205988000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1488205988000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1488205988000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1488205988000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1488205988000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1488205988000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1488205988000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1488205988000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1488205988000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1488205988000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1488205988000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1488205988000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1488205988000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1488205988000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1488205988000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1488205988000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1488205988000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"1a21ec8d27ad6ca50363ee7acfcdc6052db8965e","modified":1488205988000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1488205988000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1488205988000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1488205988000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1488205988000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1488205988000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1488205988000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1488205988000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"7e18f08c2c82f71e83860f232d43d8b89865ac2e","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1488205988000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1488205988000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1488205988000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1488205988000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1488205988000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1488205988000},{"_id":"themes/next/.git/objects/pack/pack-ffeda7d4c1197b8844616f965b1a3f389eb572c3.idx","hash":"90bfa1d75020b69ee0168affd57a3c28db84130c","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1488205988000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1488205988000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"1a21ec8d27ad6ca50363ee7acfcdc6052db8965e","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"72bb1c9c890a1dfeca7804d681b366fea0ac4421","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1488205988000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1488205988000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488205988000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1488205988000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1488205988000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1488205988000},{"_id":"themes/next/source/images/avatar.jpeg","hash":"c1a0e55f240b2db968b2029ef276521b4d72ca1a","modified":1488206081000},{"_id":"themes/next/.git/objects/pack/pack-ffeda7d4c1197b8844616f965b1a3f389eb572c3.pack","hash":"6a92f0a4f76982ca48828626b2177927ab1ecd54","modified":1488205988000},{"_id":"public/categories/index.html","hash":"33dc845569acba581e3dfcd734fb14ee413fbf7e","modified":1488253804367},{"_id":"public/tags/index.html","hash":"e13ed99fe31eebeb17542c6121f0c4cbe8f572c7","modified":1488253804368},{"_id":"public/archives/index.html","hash":"363564e6ae46f0cef25c4ace79f40506dd10c32e","modified":1488253804369},{"_id":"public/archives/2015/index.html","hash":"c4830184be94e48c645fcadcead0aac20892acad","modified":1488253804369},{"_id":"public/archives/2015/12/index.html","hash":"1216a4ef9752c9ba98f3429124fac658af84ae10","modified":1488253804369},{"_id":"public/archives/2016/index.html","hash":"5c34415c2c200e58669a5d7da2276c646337c736","modified":1488253804369},{"_id":"public/archives/2016/02/index.html","hash":"10ac2556c79cb0ada87ef36c67bde11b330dce50","modified":1488253804369},{"_id":"public/archives/2016/03/index.html","hash":"321b181d016167f204891a2e79416971a15bb907","modified":1488253804369},{"_id":"public/categories/Objective-C/index.html","hash":"a35167684986ae160de741d148c58e8d37c8562d","modified":1488253804369},{"_id":"public/categories/Swift/index.html","hash":"f2524f0f9044a358ce3aca9ffd6a0adfae3d9849","modified":1488253804369},{"_id":"public/tags/Swift/index.html","hash":"80a1be03af3d321e3f2f43b8734ed866f340740b","modified":1488253804369},{"_id":"public/tags/关联对象/index.html","hash":"73ac45854f878babf0b5b44beced04299af35534","modified":1488253804369},{"_id":"public/tags/UserDefaults/index.html","hash":"e38bcaf1bb723bda9d0a01d97cd82c183440f2a0","modified":1488253804369},{"_id":"public/tags/TMCache/index.html","hash":"d2d36a54f73ba2db28ef55519a3b0dfe9cf9da0a","modified":1488253804369},{"_id":"public/tags/缓存/index.html","hash":"bb57f3fe4ebe5b4bb2f0c33633561da0e4e57708","modified":1488253804369},{"_id":"public/2016/03/03/TMCache源码分析之TMDiskCache磁盘缓存/index.html","hash":"70621976d1a537d24fb61d717bd1c8d540e95567","modified":1488253804369},{"_id":"public/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/index.html","hash":"8142559072517af9e42ceb93db2cc5cb991b17c9","modified":1488253804369},{"_id":"public/2016/02/13/Swift中安全优雅的使用UserDefaults/index.html","hash":"eb041c330626a84cb5ad5775ce514dc2ff195bd1","modified":1488253804369},{"_id":"public/2015/12/27/Swift在扩展中关联对象/index.html","hash":"e34d72f7df0d8dc33260e1ad223c29d7f874e627","modified":1488253804369},{"_id":"public/index.html","hash":"e6a21e41006d2b0d75d16f4d46481d2f4354248c","modified":1488253804370},{"_id":"public/2016/04/08/RunLoop浅析/index.html","hash":"7d90fc7175d11ddfe1a977418cf9140f54b8c632","modified":1488253804427},{"_id":"public/archives/2016/04/index.html","hash":"1ca188cf6afcd957a47931627ac2570cdcb49e07","modified":1488253804427},{"_id":"public/tags/RunLoop/index.html","hash":"53194b2f95adf31586c2b93bdf166250d3c5f5eb","modified":1488253804427}],"Category":[{"name":"Objective-C","_id":"cizozpeb90004k4exjqy1l95q"},{"name":"Swift","_id":"cizozpebl0009k4ex1rdrual9"}],"Data":[],"Page":[{"title":"分类","type":"categories","_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\n---\n\n\n","date":"2017-02-27T15:13:31.000Z","updated":"2017-02-27T15:13:31.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cizozpeb30001k4exprrxsm7k","content":"","excerpt":"","more":""},{"title":"标签","type":"tags","_content":"\n\n","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\n---\n\n\n","date":"2017-02-27T15:13:20.000Z","updated":"2017-02-27T15:13:20.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cizozpeb70003k4exgmwmrkv8","content":"","excerpt":"","more":""}],"Post":[{"title":"RunLoop浅析","date":"2016-04-07T16:00:00.000Z","_content":"\n`RunLoop`虽然在平时开发过程中使用不多, 但是是非常重要的, 往往能够解决关键性问题, 比如计时器突然不准,  页面滑动有时会卡顿等问题, 都可以用`RunLoop`来解决, 本篇文章是总结性和实践性文章, 主要做个记录, 方便自己开发中查阅.\n\n### 什么是RunLoop?\nRunLoop从字面量意思看就是一个运行循环, 其实是一个事件处理的循环, 用来不停的调度任务和处理输入事件. RunLoop 内部其实是一个do-while大循环, 在这个循环里处理输入事件, 比如:点击事件, 滑动屏幕, 定时器等, 当处理完一个任务后RunLoop进入休眠, 有任务时又唤醒RunLoop处理事件.\n\n简言之, `RunLoop是管理线程各类输入事件的对象`.\n\n<!---more--->\n\n基本作用:\n1. `保持程序的持续运行`. 如果线程中没有RunLoop, 线程执行完任务队列中的任务后, 就会退出. 所以app的主线程必定有一个RunLoop, 一直让主线程处理不退出状态, 除非系统或者手动让RunLoop停止工作, 此时主线程退出, app挂掉.\n2. `处理app中的各类输入事件`. 比如:点击事件,触摸事件, 方法调用(seletor)事件, 定时器等, RunLoop就是一直在等待处理这些事件.\n3. `节省CPU资源`. 虽然RunLoop 是一个大循环, 但是不同于while(1)死循环, 当有任务的事件会`唤醒`RunLoop执行任务, 没有任务时`休眠`RunLoop.\n\n在我们程序的main函数中, 返回`UIApplicationMain`方法调用的返回值, 这个方法程序运行时是不会被返回的, 因为在这个方法内部会创建一个RunLoop, 维持主线程的持续运行.\n\n```Objc\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([CZPAppDelegate class]));\n    }\n}\n```\n\n类似于下面的伪代码:\n\n```Objc\nint main(int argc, char * argv[]) {\n    BOOL isRunning = YES;\n    \n    do {\n        // 通知观察者告知RunLoop的状态\n        // ...\n        // 处理各类事件\n        // ...\n        // 休眠, 等待被唤醒\n        // 唤醒\n        \n        // 各类条件是否满足??\n        BOOL conditions;\n        if (conditions) {\n            isRunning = YES;\n        }else {\n            isRunning = NO;\n        }\n        \n    } while (isRunning);\n    \n    return 0;\n}\n```\n\n### RunLoop对象\nRunLoop是管理线程输入事件的对象\n\n- `Core Foundation`框架中使用 `CFRunLoopRef`. 是纯C写的代码, 所以是线程安全的.\n- 在`Foundation`框架中使用`NSRunLoop`, 是封装的 `CFRunLoopRef`中, 不是线程安全的. 两者都代表RunLoop对象, 是可以等价转换的. \n\n要想了解RunLoop很有必要知道底层的实现, 苹果公司开源了这个部分代码, 其中跟RunLoop相关的就两个文件: `CFRunLoop.h`, `CFRunLoop.c`.\n\n[CFRunLoopRef开源代码下载地址](http://opensource.apple.com/source/CF/CF-1151.16/)\nhttp://opensource.apple.com/source/CF/CF-1151.16/\n\n获取 RunLoop 对象\n\n1. 获取当前 RunLoop 对象:\n\n    ```Objc\n    // NSRunloop\n     NSRunLoop * runloop = [NSRunLoop currentRunLoop];\n     \n    // CFRunLoopRef\n    CFRunLoopRef runloop =   CFRunLoopGetCurrent();\n    ```\n2. 获取主线程的 RunLoop 对象:\n    \n    ```Objc\n    // NSRunloop\n     NSRunLoop * runloop = [NSRunLoop mainRunLoop];\n    \n    // CFRunLoopRef\n     CFRunLoopRef runloop =   CFRunLoopGetMain();\n    ```\n注意:\n> 创建 RunLoop 对象不是通过 alloc init 的方式创建的, 是直接获取, 没有的话就会创建. 主线程中也可以通过方式一来获取 RunLoop 对象.\n\n### RunLoop 与线程\n线程和RunLoop的关系:\n\n- 每条线程都有唯一的一个RunLoop 对象.\n- 主线程的RunLoop在程序启动时自动创建好了, 子线程的需要手动创建.\n- RunLoop 在第一次获取时创建, 线程销毁时销毁.\n\n线程和RunLoop的对应关系保存在一个全局的字典中, 通过key-value保持. 下面是CFRunLoop.m中的源代码, 无论是主线程还是子线程在获取RunLoop的时候会调用`_CFRunLoopGet0`函数, 该函数判断该线程RunLoop对象, 有则返回, 没有则创建并保存.\n\n```C\n// 创建字典\nCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n// 创建主线程runloop\nCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n// 保存主线程runloop\nCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n\n// 从字典中获取子线程的runloop\nCFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n__CFUnlock(&loopsLock);\nif (!loop) {\n// 如果子线程的runloop不存在,那么就为该线程创建一个对应的runloop\nCFRunLoopRef newLoop = __CFRunLoopCreate(t);\n__CFLock(&loopsLock);\nloop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n// 把当前子线程和对应的runloop保存到字典中\nif (!loop) {\nCFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\nloop = newLoop;\n}\n```\n### RunLoop 运行原理\n\nRunloop运行原理图中可以看到, 一个线程中的RunLoop接受 source 源的输入事件和 timer 定时器事件, 当有这些事件发生时, 就会唤醒 RunLoop 执行相应任务.\n\n![运行原理图](http://oixseublm.bkt.clouddn.com/2.png)\n\n### RunLoop 相关类\n\n有5个相关类:\n\n- `CFRunloopRef`\n- `CFRunloopModeRef`: Runloop的运行模式\n- `CFRunloopSourceRef`: Runloop要处理的事件源\n- `CFRunloopTimerRef`: Timer事件\n- `CFRunloopObserverRef`: Runloop的观察者（监听者）\n\nRunloop和相关类之间的关系图:\n\n![关系图](http://oixseublm.bkt.clouddn.com/1.png)\n\n`CFRunloopModeRef`代表RunLoop的运行模式, 每次运行只能处于一个模式下, 每个mode下有很多source, timer, observer, 如果要切换模式, 只能退出当前循环, 重新指定一个新的mode后再次进入循环.  \nRunLoop 这么设计其实是为了避免各个mode下的source, timer, observer相互影响.\n\n`CFRunloopModeRef`有五种mode:\n\n- `kCFRunLoopDefaultMode`: App的默认Mode，通常主线程是在这个Mode下运行.\n- `UITrackingRunLoopMode`: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响.\n\n- `UIInitializationRunLoopMode`: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用.\n- `GSEventReceiveRunLoopMode`: 接受系统事件的内部 Mode，通常用不到\n- `kCFRunLoopCommonModes`: 这是一个占位用的Mode，不是一种真正的Mode. \n\n\n`CFRunloopSourceRef`分为两种:\n\n- source0: 非基于Port的, 把事件告诉RunLoop, 需要手动激活.\n- Source1: 通过系统内核来唤醒.\n- 可以通过打断点的方式查看一个方法的函数调用栈\n\n`CFRunLoopObserverRef`观察者,监听RunLoop的状态:\n\n监听的状态是枚举:\n\n```Objc\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),           //即将进入Runloop\n    kCFRunLoopBeforeTimers = (1UL << 1),    //即将处理NSTimer\n    kCFRunLoopBeforeSources = (1UL << 2),   //即将处理Sources\n    kCFRunLoopBeforeWaiting = (1UL << 5),   //即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),    //刚从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),            //即将退出runloop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU   //所有状态改变\n};\n```\n\n给RunLoop添加监听者:\n\n```objc\n//创建一个runloop监听者\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n\n   NSLog(@\"监听runloop状态改变---%zd\",activity);\n});\n\n//为runloop添加一个监听者\nCFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);\n\n// 必须释放\nCFRelease(observer);\n```\n\n`CFRunloopTimerRef`是定时器事件, `NSTimer`是基于`CFRunloopTimerRef`的封装, 是基于时间的触发器, 需要把timer加入到RunLoop里面去, RunLoop会在相应的时间点注册事件, 等时间到了触发唤醒RunLoop执行事件.  \n\n定时器在开发中使用广泛, 但是很容易犯错, 有两种方式设置定时事件, `NSTimer`和`GCD`, 两者的定时器不同, `GCD`的更加精准, 不受RunLoop的影响. 而且RunLoop里面设置循环过期时间也是用的`GCD`的定时器, 由此可知, RunLoop 会使用 GCD 的部分功能.\n\n注意:\n> 使用timer 的时候一定要注意添加到哪种mode模式下, 一般标记为`NSRunLoopCommonModes`下, 也就是说任何模式下都可以正常运行定时器, 否则只能特定模式下运行, 当RunLoop切换模式后, 定时器不正常工作.\n\n#### NSTimer + RunLoop用法:\n\n```Objc\n- (void)timer2 {\n   //NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode\n    \n   NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n    \n   //更改模式\n   [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n}\n    \n- (void)timer1 {\n    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n   \n   // 定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作\n   // [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n   \n   // 占位模式：common modes标记\n   // 被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode\n   [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n   \n   // NSLog(@\"%@\",[NSRunLoop currentRunLoop]);\n}\n    \n- (void)run {\n   NSLog(@\"---run---%@\", [NSRunLoop currentRunLoop].currentMode);\n}\n    \n- (IBAction)btnClick {\n   NSLog(@\"---btnClick---\");\n}\n```\n    \n还有一种办法是添加两次:\n\n```Objc\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n#### GCD 定时器用法:\n\n```objc\n//0.创建一个队列\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\n//1.创建一个GCD的定时器\ndispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\n//2.设置定时器的开始时间，间隔时间以及精准度\ndispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,3.0 *NSEC_PER_SEC);\n//设置定时器工作的间隔时间\nuint64_t intevel = 1.0 * NSEC_PER_SEC;\n\n/*\n第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0\n该参数的意义：可以适当的提高程序的性能\n注意点：GCD定时器中的时间以纳秒为单位\n*/\ndispatch_source_set_timer(timer, start, intevel, 0 * NSEC_PER_SEC);\n\n//3.设置定时器开启后回调的方法\ndispatch_source_set_event_handler(timer, ^{\n   NSLog(@\"------%@\", [NSThread currentThread]);\n});\n\n//4.执行定时器\ndispatch_resume(timer);\n\n//注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用\nself.timer = timer;\n```\n\n### RunLoop运行逻辑\n运行逻辑就是一个do-while大循环, 在这个循环里面处理事件, 监听RunLoop的状态, 不停的`休眠-唤醒-处理-休眠`这个过程.\n\n![处理过程](http://oixseublm.bkt.clouddn.com/3.png)\n\n![逻辑图](http://oixseublm.bkt.clouddn.com/4.png)\n\n### RunLoop应用\n下面是开发中经常使用RunLoop的地方:\n#### NSTimer\n\n```Objc\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    \n    NSTimer *timer = [NSTimer timerWithTimeInterval:3 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"---timer block---\");\n    }];\n    \n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n}\n```\n\n控制台输出:\n\n```\n2017-02-28 11:17:46.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:49.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:52.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:55.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:58.102 test[2831:93953] ---timer block---\n2017-02-28 11:18:01.175 test[2831:93953] ---timer block---\n```\n\n#### ImageView显示\n\n```Objc\n[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"abc\"] afterDelay:2.0 inModes:@[NSDefaultRunLoopMode,UITrackingRunLoopMode]];\n```\n#### PerformSelector\n\n有很多 PerformSelector 方法都是需要制定mode, date的, 正如上面所示.\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n#### 常驻线程\n有时需要在后台开启一个线程持续的做任务, 比如搜集数据, 语音唤起等, 无非就是在一个线程中开启一个RunLoop 让它维持线程的持续运行, 而不是执行完任务后退出.\nAFN框架中也是用了:\n\n```Objc\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n \n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n    return _networkRequestThread;\n}\n```\n\n注意:\n> 子线程的RunLoop里面至少要有一个source或者是timer, 只有observer不行的.\n\n#### 自动释放池\n自动释放池的第一次创建:\n`第一次进入RunLoop时候自动创建`.\n\n自动释放池的第一次销毁:\n`RunLoop即将进入休眠的时候`\n\n其它情况下创建和销毁:\n`唤醒RunLoop的时候会创建新的自动释放池`\n`RunLoop销毁时销毁自动释放池`\n\n打印RunLoop信息可以看出:\n\n```\n_wrapRunLoopWithAutoreleasePoolHandler  activities = 0x1  1\n_wrapRunLoopWithAutoreleasePoolHandler activities = 0xa0 160\n```\n160 是 kCFRunLoopBeforeWaiting + kCFRunLoopExit\n\n\n\n","source":"_posts/RunLoop浅析.md","raw":"---\ntitle: RunLoop浅析\ndate: 2016-04-8 \ncategories: Objective-C\ntags: [RunLoop]\n---\n\n`RunLoop`虽然在平时开发过程中使用不多, 但是是非常重要的, 往往能够解决关键性问题, 比如计时器突然不准,  页面滑动有时会卡顿等问题, 都可以用`RunLoop`来解决, 本篇文章是总结性和实践性文章, 主要做个记录, 方便自己开发中查阅.\n\n### 什么是RunLoop?\nRunLoop从字面量意思看就是一个运行循环, 其实是一个事件处理的循环, 用来不停的调度任务和处理输入事件. RunLoop 内部其实是一个do-while大循环, 在这个循环里处理输入事件, 比如:点击事件, 滑动屏幕, 定时器等, 当处理完一个任务后RunLoop进入休眠, 有任务时又唤醒RunLoop处理事件.\n\n简言之, `RunLoop是管理线程各类输入事件的对象`.\n\n<!---more--->\n\n基本作用:\n1. `保持程序的持续运行`. 如果线程中没有RunLoop, 线程执行完任务队列中的任务后, 就会退出. 所以app的主线程必定有一个RunLoop, 一直让主线程处理不退出状态, 除非系统或者手动让RunLoop停止工作, 此时主线程退出, app挂掉.\n2. `处理app中的各类输入事件`. 比如:点击事件,触摸事件, 方法调用(seletor)事件, 定时器等, RunLoop就是一直在等待处理这些事件.\n3. `节省CPU资源`. 虽然RunLoop 是一个大循环, 但是不同于while(1)死循环, 当有任务的事件会`唤醒`RunLoop执行任务, 没有任务时`休眠`RunLoop.\n\n在我们程序的main函数中, 返回`UIApplicationMain`方法调用的返回值, 这个方法程序运行时是不会被返回的, 因为在这个方法内部会创建一个RunLoop, 维持主线程的持续运行.\n\n```Objc\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([CZPAppDelegate class]));\n    }\n}\n```\n\n类似于下面的伪代码:\n\n```Objc\nint main(int argc, char * argv[]) {\n    BOOL isRunning = YES;\n    \n    do {\n        // 通知观察者告知RunLoop的状态\n        // ...\n        // 处理各类事件\n        // ...\n        // 休眠, 等待被唤醒\n        // 唤醒\n        \n        // 各类条件是否满足??\n        BOOL conditions;\n        if (conditions) {\n            isRunning = YES;\n        }else {\n            isRunning = NO;\n        }\n        \n    } while (isRunning);\n    \n    return 0;\n}\n```\n\n### RunLoop对象\nRunLoop是管理线程输入事件的对象\n\n- `Core Foundation`框架中使用 `CFRunLoopRef`. 是纯C写的代码, 所以是线程安全的.\n- 在`Foundation`框架中使用`NSRunLoop`, 是封装的 `CFRunLoopRef`中, 不是线程安全的. 两者都代表RunLoop对象, 是可以等价转换的. \n\n要想了解RunLoop很有必要知道底层的实现, 苹果公司开源了这个部分代码, 其中跟RunLoop相关的就两个文件: `CFRunLoop.h`, `CFRunLoop.c`.\n\n[CFRunLoopRef开源代码下载地址](http://opensource.apple.com/source/CF/CF-1151.16/)\nhttp://opensource.apple.com/source/CF/CF-1151.16/\n\n获取 RunLoop 对象\n\n1. 获取当前 RunLoop 对象:\n\n    ```Objc\n    // NSRunloop\n     NSRunLoop * runloop = [NSRunLoop currentRunLoop];\n     \n    // CFRunLoopRef\n    CFRunLoopRef runloop =   CFRunLoopGetCurrent();\n    ```\n2. 获取主线程的 RunLoop 对象:\n    \n    ```Objc\n    // NSRunloop\n     NSRunLoop * runloop = [NSRunLoop mainRunLoop];\n    \n    // CFRunLoopRef\n     CFRunLoopRef runloop =   CFRunLoopGetMain();\n    ```\n注意:\n> 创建 RunLoop 对象不是通过 alloc init 的方式创建的, 是直接获取, 没有的话就会创建. 主线程中也可以通过方式一来获取 RunLoop 对象.\n\n### RunLoop 与线程\n线程和RunLoop的关系:\n\n- 每条线程都有唯一的一个RunLoop 对象.\n- 主线程的RunLoop在程序启动时自动创建好了, 子线程的需要手动创建.\n- RunLoop 在第一次获取时创建, 线程销毁时销毁.\n\n线程和RunLoop的对应关系保存在一个全局的字典中, 通过key-value保持. 下面是CFRunLoop.m中的源代码, 无论是主线程还是子线程在获取RunLoop的时候会调用`_CFRunLoopGet0`函数, 该函数判断该线程RunLoop对象, 有则返回, 没有则创建并保存.\n\n```C\n// 创建字典\nCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks);\n// 创建主线程runloop\nCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n// 保存主线程runloop\nCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n\n// 从字典中获取子线程的runloop\nCFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n__CFUnlock(&loopsLock);\nif (!loop) {\n// 如果子线程的runloop不存在,那么就为该线程创建一个对应的runloop\nCFRunLoopRef newLoop = __CFRunLoopCreate(t);\n__CFLock(&loopsLock);\nloop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n// 把当前子线程和对应的runloop保存到字典中\nif (!loop) {\nCFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\nloop = newLoop;\n}\n```\n### RunLoop 运行原理\n\nRunloop运行原理图中可以看到, 一个线程中的RunLoop接受 source 源的输入事件和 timer 定时器事件, 当有这些事件发生时, 就会唤醒 RunLoop 执行相应任务.\n\n![运行原理图](http://oixseublm.bkt.clouddn.com/2.png)\n\n### RunLoop 相关类\n\n有5个相关类:\n\n- `CFRunloopRef`\n- `CFRunloopModeRef`: Runloop的运行模式\n- `CFRunloopSourceRef`: Runloop要处理的事件源\n- `CFRunloopTimerRef`: Timer事件\n- `CFRunloopObserverRef`: Runloop的观察者（监听者）\n\nRunloop和相关类之间的关系图:\n\n![关系图](http://oixseublm.bkt.clouddn.com/1.png)\n\n`CFRunloopModeRef`代表RunLoop的运行模式, 每次运行只能处于一个模式下, 每个mode下有很多source, timer, observer, 如果要切换模式, 只能退出当前循环, 重新指定一个新的mode后再次进入循环.  \nRunLoop 这么设计其实是为了避免各个mode下的source, timer, observer相互影响.\n\n`CFRunloopModeRef`有五种mode:\n\n- `kCFRunLoopDefaultMode`: App的默认Mode，通常主线程是在这个Mode下运行.\n- `UITrackingRunLoopMode`: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响.\n\n- `UIInitializationRunLoopMode`: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用.\n- `GSEventReceiveRunLoopMode`: 接受系统事件的内部 Mode，通常用不到\n- `kCFRunLoopCommonModes`: 这是一个占位用的Mode，不是一种真正的Mode. \n\n\n`CFRunloopSourceRef`分为两种:\n\n- source0: 非基于Port的, 把事件告诉RunLoop, 需要手动激活.\n- Source1: 通过系统内核来唤醒.\n- 可以通过打断点的方式查看一个方法的函数调用栈\n\n`CFRunLoopObserverRef`观察者,监听RunLoop的状态:\n\n监听的状态是枚举:\n\n```Objc\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),           //即将进入Runloop\n    kCFRunLoopBeforeTimers = (1UL << 1),    //即将处理NSTimer\n    kCFRunLoopBeforeSources = (1UL << 2),   //即将处理Sources\n    kCFRunLoopBeforeWaiting = (1UL << 5),   //即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),    //刚从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),            //即将退出runloop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU   //所有状态改变\n};\n```\n\n给RunLoop添加监听者:\n\n```objc\n//创建一个runloop监听者\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n\n   NSLog(@\"监听runloop状态改变---%zd\",activity);\n});\n\n//为runloop添加一个监听者\nCFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);\n\n// 必须释放\nCFRelease(observer);\n```\n\n`CFRunloopTimerRef`是定时器事件, `NSTimer`是基于`CFRunloopTimerRef`的封装, 是基于时间的触发器, 需要把timer加入到RunLoop里面去, RunLoop会在相应的时间点注册事件, 等时间到了触发唤醒RunLoop执行事件.  \n\n定时器在开发中使用广泛, 但是很容易犯错, 有两种方式设置定时事件, `NSTimer`和`GCD`, 两者的定时器不同, `GCD`的更加精准, 不受RunLoop的影响. 而且RunLoop里面设置循环过期时间也是用的`GCD`的定时器, 由此可知, RunLoop 会使用 GCD 的部分功能.\n\n注意:\n> 使用timer 的时候一定要注意添加到哪种mode模式下, 一般标记为`NSRunLoopCommonModes`下, 也就是说任何模式下都可以正常运行定时器, 否则只能特定模式下运行, 当RunLoop切换模式后, 定时器不正常工作.\n\n#### NSTimer + RunLoop用法:\n\n```Objc\n- (void)timer2 {\n   //NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode\n    \n   NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n    \n   //更改模式\n   [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n}\n    \n- (void)timer1 {\n    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n   \n   // 定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作\n   // [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n   \n   // 占位模式：common modes标记\n   // 被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode\n   [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n   \n   // NSLog(@\"%@\",[NSRunLoop currentRunLoop]);\n}\n    \n- (void)run {\n   NSLog(@\"---run---%@\", [NSRunLoop currentRunLoop].currentMode);\n}\n    \n- (IBAction)btnClick {\n   NSLog(@\"---btnClick---\");\n}\n```\n    \n还有一种办法是添加两次:\n\n```Objc\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n#### GCD 定时器用法:\n\n```objc\n//0.创建一个队列\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\n//1.创建一个GCD的定时器\ndispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\n//2.设置定时器的开始时间，间隔时间以及精准度\ndispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,3.0 *NSEC_PER_SEC);\n//设置定时器工作的间隔时间\nuint64_t intevel = 1.0 * NSEC_PER_SEC;\n\n/*\n第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0\n该参数的意义：可以适当的提高程序的性能\n注意点：GCD定时器中的时间以纳秒为单位\n*/\ndispatch_source_set_timer(timer, start, intevel, 0 * NSEC_PER_SEC);\n\n//3.设置定时器开启后回调的方法\ndispatch_source_set_event_handler(timer, ^{\n   NSLog(@\"------%@\", [NSThread currentThread]);\n});\n\n//4.执行定时器\ndispatch_resume(timer);\n\n//注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用\nself.timer = timer;\n```\n\n### RunLoop运行逻辑\n运行逻辑就是一个do-while大循环, 在这个循环里面处理事件, 监听RunLoop的状态, 不停的`休眠-唤醒-处理-休眠`这个过程.\n\n![处理过程](http://oixseublm.bkt.clouddn.com/3.png)\n\n![逻辑图](http://oixseublm.bkt.clouddn.com/4.png)\n\n### RunLoop应用\n下面是开发中经常使用RunLoop的地方:\n#### NSTimer\n\n```Objc\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    \n    NSTimer *timer = [NSTimer timerWithTimeInterval:3 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        NSLog(@\"---timer block---\");\n    }];\n    \n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n}\n```\n\n控制台输出:\n\n```\n2017-02-28 11:17:46.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:49.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:52.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:55.102 test[2831:93953] ---timer block---\n2017-02-28 11:17:58.102 test[2831:93953] ---timer block---\n2017-02-28 11:18:01.175 test[2831:93953] ---timer block---\n```\n\n#### ImageView显示\n\n```Objc\n[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"abc\"] afterDelay:2.0 inModes:@[NSDefaultRunLoopMode,UITrackingRunLoopMode]];\n```\n#### PerformSelector\n\n有很多 PerformSelector 方法都是需要制定mode, date的, 正如上面所示.\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n#### 常驻线程\n有时需要在后台开启一个线程持续的做任务, 比如搜集数据, 语音唤起等, 无非就是在一个线程中开启一个RunLoop 让它维持线程的持续运行, 而不是执行完任务后退出.\nAFN框架中也是用了:\n\n```Objc\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n \n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n    return _networkRequestThread;\n}\n```\n\n注意:\n> 子线程的RunLoop里面至少要有一个source或者是timer, 只有observer不行的.\n\n#### 自动释放池\n自动释放池的第一次创建:\n`第一次进入RunLoop时候自动创建`.\n\n自动释放池的第一次销毁:\n`RunLoop即将进入休眠的时候`\n\n其它情况下创建和销毁:\n`唤醒RunLoop的时候会创建新的自动释放池`\n`RunLoop销毁时销毁自动释放池`\n\n打印RunLoop信息可以看出:\n\n```\n_wrapRunLoopWithAutoreleasePoolHandler  activities = 0x1  1\n_wrapRunLoopWithAutoreleasePoolHandler activities = 0xa0 160\n```\n160 是 kCFRunLoopBeforeWaiting + kCFRunLoopExit\n\n\n\n","slug":"RunLoop浅析","published":1,"updated":"2017-02-28T03:43:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizozpeay0000k4ex0dhaby1i","content":"<p><code>RunLoop</code>虽然在平时开发过程中使用不多, 但是是非常重要的, 往往能够解决关键性问题, 比如计时器突然不准,  页面滑动有时会卡顿等问题, 都可以用<code>RunLoop</code>来解决, 本篇文章是总结性和实践性文章, 主要做个记录, 方便自己开发中查阅.</p>\n<h3 id=\"什么是RunLoop\"><a href=\"#什么是RunLoop\" class=\"headerlink\" title=\"什么是RunLoop?\"></a>什么是RunLoop?</h3><p>RunLoop从字面量意思看就是一个运行循环, 其实是一个事件处理的循环, 用来不停的调度任务和处理输入事件. RunLoop 内部其实是一个do-while大循环, 在这个循环里处理输入事件, 比如:点击事件, 滑动屏幕, 定时器等, 当处理完一个任务后RunLoop进入休眠, 有任务时又唤醒RunLoop处理事件.</p>\n<p>简言之, <code>RunLoop是管理线程各类输入事件的对象</code>.</p>\n<a id=\"more\"></a>\n<p>基本作用:</p>\n<ol>\n<li><code>保持程序的持续运行</code>. 如果线程中没有RunLoop, 线程执行完任务队列中的任务后, 就会退出. 所以app的主线程必定有一个RunLoop, 一直让主线程处理不退出状态, 除非系统或者手动让RunLoop停止工作, 此时主线程退出, app挂掉.</li>\n<li><code>处理app中的各类输入事件</code>. 比如:点击事件,触摸事件, 方法调用(seletor)事件, 定时器等, RunLoop就是一直在等待处理这些事件.</li>\n<li><code>节省CPU资源</code>. 虽然RunLoop 是一个大循环, 但是不同于while(1)死循环, 当有任务的事件会<code>唤醒</code>RunLoop执行任务, 没有任务时<code>休眠</code>RunLoop.</li>\n</ol>\n<p>在我们程序的main函数中, 返回<code>UIApplicationMain</code>方法调用的返回值, 这个方法程序运行时是不会被返回的, 因为在这个方法内部会创建一个RunLoop, 维持主线程的持续运行.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([CZPAppDelegate <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类似于下面的伪代码:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"built_in\">BOOL</span> isRunning = <span class=\"literal\">YES</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 通知观察者告知RunLoop的状态</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 处理各类事件</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 休眠, 等待被唤醒</span></div><div class=\"line\">        <span class=\"comment\">// 唤醒</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 各类条件是否满足??</span></div><div class=\"line\">        <span class=\"built_in\">BOOL</span> conditions;</div><div class=\"line\">        <span class=\"keyword\">if</span> (conditions) &#123;</div><div class=\"line\">            isRunning = <span class=\"literal\">YES</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            isRunning = <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (isRunning);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"RunLoop对象\"><a href=\"#RunLoop对象\" class=\"headerlink\" title=\"RunLoop对象\"></a>RunLoop对象</h3><p>RunLoop是管理线程输入事件的对象</p>\n<ul>\n<li><code>Core Foundation</code>框架中使用 <code>CFRunLoopRef</code>. 是纯C写的代码, 所以是线程安全的.</li>\n<li>在<code>Foundation</code>框架中使用<code>NSRunLoop</code>, 是封装的 <code>CFRunLoopRef</code>中, 不是线程安全的. 两者都代表RunLoop对象, 是可以等价转换的. </li>\n</ul>\n<p>要想了解RunLoop很有必要知道底层的实现, 苹果公司开源了这个部分代码, 其中跟RunLoop相关的就两个文件: <code>CFRunLoop.h</code>, <code>CFRunLoop.c</code>.</p>\n<p><a href=\"http://opensource.apple.com/source/CF/CF-1151.16/\" target=\"_blank\" rel=\"external\">CFRunLoopRef开源代码下载地址</a><br><a href=\"http://opensource.apple.com/source/CF/CF-1151.16/\" target=\"_blank\" rel=\"external\">http://opensource.apple.com/source/CF/CF-1151.16/</a></p>\n<p>获取 RunLoop 对象</p>\n<ol>\n<li><p>获取当前 RunLoop 对象:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NSRunloop</span></div><div class=\"line\"> <span class=\"built_in\">NSRunLoop</span> * runloop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// CFRunLoopRef</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> runloop =   <span class=\"built_in\">CFRunLoopGetCurrent</span>();</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取主线程的 RunLoop 对象:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NSRunloop</span></div><div class=\"line\"> <span class=\"built_in\">NSRunLoop</span> * runloop = [<span class=\"built_in\">NSRunLoop</span> mainRunLoop];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// CFRunLoopRef</span></div><div class=\"line\"> <span class=\"built_in\">CFRunLoopRef</span> runloop =   <span class=\"built_in\">CFRunLoopGetMain</span>();</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意:</p>\n<blockquote>\n<p>创建 RunLoop 对象不是通过 alloc init 的方式创建的, 是直接获取, 没有的话就会创建. 主线程中也可以通过方式一来获取 RunLoop 对象.</p>\n</blockquote>\n<h3 id=\"RunLoop-与线程\"><a href=\"#RunLoop-与线程\" class=\"headerlink\" title=\"RunLoop 与线程\"></a>RunLoop 与线程</h3><p>线程和RunLoop的关系:</p>\n<ul>\n<li>每条线程都有唯一的一个RunLoop 对象.</li>\n<li>主线程的RunLoop在程序启动时自动创建好了, 子线程的需要手动创建.</li>\n<li>RunLoop 在第一次获取时创建, 线程销毁时销毁.</li>\n</ul>\n<p>线程和RunLoop的对应关系保存在一个全局的字典中, 通过key-value保持. 下面是CFRunLoop.m中的源代码, 无论是主线程还是子线程在获取RunLoop的时候会调用<code>_CFRunLoopGet0</code>函数, 该函数判断该线程RunLoop对象, 有则返回, 没有则创建并保存.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建字典</span></div><div class=\"line\">CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</div><div class=\"line\"><span class=\"comment\">// 创建主线程runloop</span></div><div class=\"line\">CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class=\"line\"><span class=\"comment\">// 保存主线程runloop</span></div><div class=\"line\">CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从字典中获取子线程的runloop</span></div><div class=\"line\">CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class=\"line\">__CFUnlock(&amp;loopsLock);</div><div class=\"line\"><span class=\"keyword\">if</span> (!loop) &#123;</div><div class=\"line\"><span class=\"comment\">// 如果子线程的runloop不存在,那么就为该线程创建一个对应的runloop</span></div><div class=\"line\">CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class=\"line\">__CFLock(&amp;loopsLock);</div><div class=\"line\">loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class=\"line\"><span class=\"comment\">// 把当前子线程和对应的runloop保存到字典中</span></div><div class=\"line\"><span class=\"keyword\">if</span> (!loop) &#123;</div><div class=\"line\">CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class=\"line\">loop = newLoop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"RunLoop-运行原理\"><a href=\"#RunLoop-运行原理\" class=\"headerlink\" title=\"RunLoop 运行原理\"></a>RunLoop 运行原理</h3><p>Runloop运行原理图中可以看到, 一个线程中的RunLoop接受 source 源的输入事件和 timer 定时器事件, 当有这些事件发生时, 就会唤醒 RunLoop 执行相应任务.</p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/2.png\" alt=\"运行原理图\"></p>\n<h3 id=\"RunLoop-相关类\"><a href=\"#RunLoop-相关类\" class=\"headerlink\" title=\"RunLoop 相关类\"></a>RunLoop 相关类</h3><p>有5个相关类:</p>\n<ul>\n<li><code>CFRunloopRef</code></li>\n<li><code>CFRunloopModeRef</code>: Runloop的运行模式</li>\n<li><code>CFRunloopSourceRef</code>: Runloop要处理的事件源</li>\n<li><code>CFRunloopTimerRef</code>: Timer事件</li>\n<li><code>CFRunloopObserverRef</code>: Runloop的观察者（监听者）</li>\n</ul>\n<p>Runloop和相关类之间的关系图:</p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/1.png\" alt=\"关系图\"></p>\n<p><code>CFRunloopModeRef</code>代表RunLoop的运行模式, 每次运行只能处于一个模式下, 每个mode下有很多source, timer, observer, 如果要切换模式, 只能退出当前循环, 重新指定一个新的mode后再次进入循环.<br>RunLoop 这么设计其实是为了避免各个mode下的source, timer, observer相互影响.</p>\n<p><code>CFRunloopModeRef</code>有五种mode:</p>\n<ul>\n<li><code>kCFRunLoopDefaultMode</code>: App的默认Mode，通常主线程是在这个Mode下运行.</li>\n<li><p><code>UITrackingRunLoopMode</code>: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响.</p>\n</li>\n<li><p><code>UIInitializationRunLoopMode</code>: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用.</p>\n</li>\n<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 Mode，通常用不到</li>\n<li><code>kCFRunLoopCommonModes</code>: 这是一个占位用的Mode，不是一种真正的Mode. </li>\n</ul>\n<p><code>CFRunloopSourceRef</code>分为两种:</p>\n<ul>\n<li>source0: 非基于Port的, 把事件告诉RunLoop, 需要手动激活.</li>\n<li>Source1: 通过系统内核来唤醒.</li>\n<li>可以通过打断点的方式查看一个方法的函数调用栈</li>\n</ul>\n<p><code>CFRunLoopObserverRef</code>观察者,监听RunLoop的状态:</p>\n<p>监听的状态是枚举:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>),           <span class=\"comment\">//即将进入Runloop</span></div><div class=\"line\">    kCFRunLoopBeforeTimers = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>),    <span class=\"comment\">//即将处理NSTimer</span></div><div class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>),   <span class=\"comment\">//即将处理Sources</span></div><div class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>),   <span class=\"comment\">//即将进入休眠</span></div><div class=\"line\">    kCFRunLoopAfterWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>),    <span class=\"comment\">//刚从休眠中唤醒</span></div><div class=\"line\">    kCFRunLoopExit = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>),            <span class=\"comment\">//即将退出runloop</span></div><div class=\"line\">    kCFRunLoopAllActivities = <span class=\"number\">0x0FFFFFFF</span>U   <span class=\"comment\">//所有状态改变</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>给RunLoop添加监听者:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个runloop监听者</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreateWithHandler</span>(<span class=\"built_in\">CFAllocatorGetDefault</span>(),kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, ^(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity) &#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"监听runloop状态改变---%zd\"</span>,activity);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//为runloop添加一个监听者</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 必须释放</span></div><div class=\"line\"><span class=\"built_in\">CFRelease</span>(observer);</div></pre></td></tr></table></figure>\n<p><code>CFRunloopTimerRef</code>是定时器事件, <code>NSTimer</code>是基于<code>CFRunloopTimerRef</code>的封装, 是基于时间的触发器, 需要把timer加入到RunLoop里面去, RunLoop会在相应的时间点注册事件, 等时间到了触发唤醒RunLoop执行事件.  </p>\n<p>定时器在开发中使用广泛, 但是很容易犯错, 有两种方式设置定时事件, <code>NSTimer</code>和<code>GCD</code>, 两者的定时器不同, <code>GCD</code>的更加精准, 不受RunLoop的影响. 而且RunLoop里面设置循环过期时间也是用的<code>GCD</code>的定时器, 由此可知, RunLoop 会使用 GCD 的部分功能.</p>\n<p>注意:</p>\n<blockquote>\n<p>使用timer 的时候一定要注意添加到哪种mode模式下, 一般标记为<code>NSRunLoopCommonModes</code>下, 也就是说任何模式下都可以正常运行定时器, 否则只能特定模式下运行, 当RunLoop切换模式后, 定时器不正常工作.</p>\n</blockquote>\n<h4 id=\"NSTimer-RunLoop用法\"><a href=\"#NSTimer-RunLoop用法\" class=\"headerlink\" title=\"NSTimer + RunLoop用法:\"></a>NSTimer + RunLoop用法:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)timer2 &#123;</div><div class=\"line\">   <span class=\"comment\">//NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode</span></div><div class=\"line\">    </div><div class=\"line\">   <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">2.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">//更改模式</span></div><div class=\"line\">   [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (<span class=\"keyword\">void</span>)timer1 &#123;</div><div class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">2.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作</span></div><div class=\"line\">   <span class=\"comment\">// [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 占位模式：common modes标记</span></div><div class=\"line\">   <span class=\"comment\">// 被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode</span></div><div class=\"line\">   [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// NSLog(@\"%@\",[NSRunLoop currentRunLoop]);</span></div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---run---%@\"</span>, [<span class=\"built_in\">NSRunLoop</span> currentRunLoop].currentMode);</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)btnClick &#123;</div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---btnClick---\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有一种办法是添加两次:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">UITrackingRunLoopMode</span>];</div><div class=\"line\"></div><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"GCD-定时器用法\"><a href=\"#GCD-定时器用法\" class=\"headerlink\" title=\"GCD 定时器用法:\"></a>GCD 定时器用法:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//0.创建一个队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1.创建一个GCD的定时器</span></div><div class=\"line\">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, queue);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.设置定时器的开始时间，间隔时间以及精准度</span></div><div class=\"line\">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,<span class=\"number\">3.0</span> *<span class=\"built_in\">NSEC_PER_SEC</span>);</div><div class=\"line\"><span class=\"comment\">//设置定时器工作的间隔时间</span></div><div class=\"line\">uint64_t intevel = <span class=\"number\">1.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0</div><div class=\"line\">该参数的意义：可以适当的提高程序的性能</div><div class=\"line\">注意点：GCD定时器中的时间以纳秒为单位</div><div class=\"line\">*/</div><div class=\"line\">dispatch_source_set_timer(timer, start, intevel, <span class=\"number\">0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3.设置定时器开启后回调的方法</span></div><div class=\"line\">dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"------%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4.执行定时器</span></div><div class=\"line\">dispatch_resume(timer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用</span></div><div class=\"line\"><span class=\"keyword\">self</span>.timer = timer;</div></pre></td></tr></table></figure>\n<h3 id=\"RunLoop运行逻辑\"><a href=\"#RunLoop运行逻辑\" class=\"headerlink\" title=\"RunLoop运行逻辑\"></a>RunLoop运行逻辑</h3><p>运行逻辑就是一个do-while大循环, 在这个循环里面处理事件, 监听RunLoop的状态, 不停的<code>休眠-唤醒-处理-休眠</code>这个过程.</p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/3.png\" alt=\"处理过程\"></p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/4.png\" alt=\"逻辑图\"></p>\n<h3 id=\"RunLoop应用\"><a href=\"#RunLoop应用\" class=\"headerlink\" title=\"RunLoop应用\"></a>RunLoop应用</h3><p>下面是开发中经常使用RunLoop的地方:</p>\n<h4 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">3</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---timer block---\"</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>控制台输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">2017-02-28 11:17:46.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:49.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:52.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:55.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:58.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:18:01.175 test[2831:93953] ---timer block---</div></pre></td></tr></table></figure>\n<h4 id=\"ImageView显示\"><a href=\"#ImageView显示\" class=\"headerlink\" title=\"ImageView显示\"></a>ImageView显示</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.imageView performSelector:<span class=\"keyword\">@selector</span>(setImage:) withObject:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"abc\"</span>] afterDelay:<span class=\"number\">2.0</span> inModes:@[<span class=\"built_in\">NSDefaultRunLoopMode</span>,<span class=\"built_in\">UITrackingRunLoopMode</span>]];</div></pre></td></tr></table></figure>\n<h4 id=\"PerformSelector\"><a href=\"#PerformSelector\" class=\"headerlink\" title=\"PerformSelector\"></a>PerformSelector</h4><p>有很多 PerformSelector 方法都是需要制定mode, date的, 正如上面所示.</p>\n<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<h4 id=\"常驻线程\"><a href=\"#常驻线程\" class=\"headerlink\" title=\"常驻线程\"></a>常驻线程</h4><p>有时需要在后台开启一个线程持续的做任务, 比如搜集数据, 语音唤起等, 无非就是在一个线程中开启一个RunLoop 让它维持线程的持续运行, 而不是执行完任务后退出.<br>AFN框架中也是用了:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)networkRequestThreadEntryPoint:(<span class=\"keyword\">id</span>)__unused object &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        [[<span class=\"built_in\">NSThread</span> currentThread] setName:<span class=\"string\">@\"AFNetworking\"</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRunLoop</span> *runLoop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\">        [runLoop addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">        [runLoop run];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)networkRequestThread &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSThread</span> *_networkRequestThread = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> oncePredicate;</div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(networkRequestThreadEntryPoint:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意:</p>\n<blockquote>\n<p>子线程的RunLoop里面至少要有一个source或者是timer, 只有observer不行的.</p>\n</blockquote>\n<h4 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h4><p>自动释放池的第一次创建:<br><code>第一次进入RunLoop时候自动创建</code>.</p>\n<p>自动释放池的第一次销毁:<br><code>RunLoop即将进入休眠的时候</code></p>\n<p>其它情况下创建和销毁:<br><code>唤醒RunLoop的时候会创建新的自动释放池</code><br><code>RunLoop销毁时销毁自动释放池</code></p>\n<p>打印RunLoop信息可以看出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_wrapRunLoopWithAutoreleasePoolHandler  activities = 0x1  1</div><div class=\"line\">_wrapRunLoopWithAutoreleasePoolHandler activities = 0xa0 160</div></pre></td></tr></table></figure>\n<p>160 是 kCFRunLoopBeforeWaiting + kCFRunLoopExit</p>\n","excerpt":"<p><code>RunLoop</code>虽然在平时开发过程中使用不多, 但是是非常重要的, 往往能够解决关键性问题, 比如计时器突然不准,  页面滑动有时会卡顿等问题, 都可以用<code>RunLoop</code>来解决, 本篇文章是总结性和实践性文章, 主要做个记录, 方便自己开发中查阅.</p>\n<h3 id=\"什么是RunLoop\"><a href=\"#什么是RunLoop\" class=\"headerlink\" title=\"什么是RunLoop?\"></a>什么是RunLoop?</h3><p>RunLoop从字面量意思看就是一个运行循环, 其实是一个事件处理的循环, 用来不停的调度任务和处理输入事件. RunLoop 内部其实是一个do-while大循环, 在这个循环里处理输入事件, 比如:点击事件, 滑动屏幕, 定时器等, 当处理完一个任务后RunLoop进入休眠, 有任务时又唤醒RunLoop处理事件.</p>\n<p>简言之, <code>RunLoop是管理线程各类输入事件的对象</code>.</p>","more":"<p>基本作用:</p>\n<ol>\n<li><code>保持程序的持续运行</code>. 如果线程中没有RunLoop, 线程执行完任务队列中的任务后, 就会退出. 所以app的主线程必定有一个RunLoop, 一直让主线程处理不退出状态, 除非系统或者手动让RunLoop停止工作, 此时主线程退出, app挂掉.</li>\n<li><code>处理app中的各类输入事件</code>. 比如:点击事件,触摸事件, 方法调用(seletor)事件, 定时器等, RunLoop就是一直在等待处理这些事件.</li>\n<li><code>节省CPU资源</code>. 虽然RunLoop 是一个大循环, 但是不同于while(1)死循环, 当有任务的事件会<code>唤醒</code>RunLoop执行任务, 没有任务时<code>休眠</code>RunLoop.</li>\n</ol>\n<p>在我们程序的main函数中, 返回<code>UIApplicationMain</code>方法调用的返回值, 这个方法程序运行时是不会被返回的, 因为在这个方法内部会创建一个RunLoop, 维持主线程的持续运行.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([CZPAppDelegate <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类似于下面的伪代码:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"built_in\">BOOL</span> isRunning = <span class=\"literal\">YES</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 通知观察者告知RunLoop的状态</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 处理各类事件</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 休眠, 等待被唤醒</span></div><div class=\"line\">        <span class=\"comment\">// 唤醒</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 各类条件是否满足??</span></div><div class=\"line\">        <span class=\"built_in\">BOOL</span> conditions;</div><div class=\"line\">        <span class=\"keyword\">if</span> (conditions) &#123;</div><div class=\"line\">            isRunning = <span class=\"literal\">YES</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            isRunning = <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (isRunning);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"RunLoop对象\"><a href=\"#RunLoop对象\" class=\"headerlink\" title=\"RunLoop对象\"></a>RunLoop对象</h3><p>RunLoop是管理线程输入事件的对象</p>\n<ul>\n<li><code>Core Foundation</code>框架中使用 <code>CFRunLoopRef</code>. 是纯C写的代码, 所以是线程安全的.</li>\n<li>在<code>Foundation</code>框架中使用<code>NSRunLoop</code>, 是封装的 <code>CFRunLoopRef</code>中, 不是线程安全的. 两者都代表RunLoop对象, 是可以等价转换的. </li>\n</ul>\n<p>要想了解RunLoop很有必要知道底层的实现, 苹果公司开源了这个部分代码, 其中跟RunLoop相关的就两个文件: <code>CFRunLoop.h</code>, <code>CFRunLoop.c</code>.</p>\n<p><a href=\"http://opensource.apple.com/source/CF/CF-1151.16/\">CFRunLoopRef开源代码下载地址</a><br><a href=\"http://opensource.apple.com/source/CF/CF-1151.16/\">http://opensource.apple.com/source/CF/CF-1151.16/</a></p>\n<p>获取 RunLoop 对象</p>\n<ol>\n<li><p>获取当前 RunLoop 对象:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NSRunloop</span></div><div class=\"line\"> <span class=\"built_in\">NSRunLoop</span> * runloop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// CFRunLoopRef</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> runloop =   <span class=\"built_in\">CFRunLoopGetCurrent</span>();</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取主线程的 RunLoop 对象:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NSRunloop</span></div><div class=\"line\"> <span class=\"built_in\">NSRunLoop</span> * runloop = [<span class=\"built_in\">NSRunLoop</span> mainRunLoop];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// CFRunLoopRef</span></div><div class=\"line\"> <span class=\"built_in\">CFRunLoopRef</span> runloop =   <span class=\"built_in\">CFRunLoopGetMain</span>();</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意:</p>\n<blockquote>\n<p>创建 RunLoop 对象不是通过 alloc init 的方式创建的, 是直接获取, 没有的话就会创建. 主线程中也可以通过方式一来获取 RunLoop 对象.</p>\n</blockquote>\n<h3 id=\"RunLoop-与线程\"><a href=\"#RunLoop-与线程\" class=\"headerlink\" title=\"RunLoop 与线程\"></a>RunLoop 与线程</h3><p>线程和RunLoop的关系:</p>\n<ul>\n<li>每条线程都有唯一的一个RunLoop 对象.</li>\n<li>主线程的RunLoop在程序启动时自动创建好了, 子线程的需要手动创建.</li>\n<li>RunLoop 在第一次获取时创建, 线程销毁时销毁.</li>\n</ul>\n<p>线程和RunLoop的对应关系保存在一个全局的字典中, 通过key-value保持. 下面是CFRunLoop.m中的源代码, 无论是主线程还是子线程在获取RunLoop的时候会调用<code>_CFRunLoopGet0</code>函数, 该函数判断该线程RunLoop对象, 有则返回, 没有则创建并保存.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建字典</span></div><div class=\"line\">CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</div><div class=\"line\"><span class=\"comment\">// 创建主线程runloop</span></div><div class=\"line\">CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class=\"line\"><span class=\"comment\">// 保存主线程runloop</span></div><div class=\"line\">CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从字典中获取子线程的runloop</span></div><div class=\"line\">CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class=\"line\">__CFUnlock(&amp;loopsLock);</div><div class=\"line\"><span class=\"keyword\">if</span> (!loop) &#123;</div><div class=\"line\"><span class=\"comment\">// 如果子线程的runloop不存在,那么就为该线程创建一个对应的runloop</span></div><div class=\"line\">CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class=\"line\">__CFLock(&amp;loopsLock);</div><div class=\"line\">loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class=\"line\"><span class=\"comment\">// 把当前子线程和对应的runloop保存到字典中</span></div><div class=\"line\"><span class=\"keyword\">if</span> (!loop) &#123;</div><div class=\"line\">CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class=\"line\">loop = newLoop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"RunLoop-运行原理\"><a href=\"#RunLoop-运行原理\" class=\"headerlink\" title=\"RunLoop 运行原理\"></a>RunLoop 运行原理</h3><p>Runloop运行原理图中可以看到, 一个线程中的RunLoop接受 source 源的输入事件和 timer 定时器事件, 当有这些事件发生时, 就会唤醒 RunLoop 执行相应任务.</p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/2.png\" alt=\"运行原理图\"></p>\n<h3 id=\"RunLoop-相关类\"><a href=\"#RunLoop-相关类\" class=\"headerlink\" title=\"RunLoop 相关类\"></a>RunLoop 相关类</h3><p>有5个相关类:</p>\n<ul>\n<li><code>CFRunloopRef</code></li>\n<li><code>CFRunloopModeRef</code>: Runloop的运行模式</li>\n<li><code>CFRunloopSourceRef</code>: Runloop要处理的事件源</li>\n<li><code>CFRunloopTimerRef</code>: Timer事件</li>\n<li><code>CFRunloopObserverRef</code>: Runloop的观察者（监听者）</li>\n</ul>\n<p>Runloop和相关类之间的关系图:</p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/1.png\" alt=\"关系图\"></p>\n<p><code>CFRunloopModeRef</code>代表RunLoop的运行模式, 每次运行只能处于一个模式下, 每个mode下有很多source, timer, observer, 如果要切换模式, 只能退出当前循环, 重新指定一个新的mode后再次进入循环.<br>RunLoop 这么设计其实是为了避免各个mode下的source, timer, observer相互影响.</p>\n<p><code>CFRunloopModeRef</code>有五种mode:</p>\n<ul>\n<li><code>kCFRunLoopDefaultMode</code>: App的默认Mode，通常主线程是在这个Mode下运行.</li>\n<li><p><code>UITrackingRunLoopMode</code>: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响.</p>\n</li>\n<li><p><code>UIInitializationRunLoopMode</code>: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用.</p>\n</li>\n<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 Mode，通常用不到</li>\n<li><code>kCFRunLoopCommonModes</code>: 这是一个占位用的Mode，不是一种真正的Mode. </li>\n</ul>\n<p><code>CFRunloopSourceRef</code>分为两种:</p>\n<ul>\n<li>source0: 非基于Port的, 把事件告诉RunLoop, 需要手动激活.</li>\n<li>Source1: 通过系统内核来唤醒.</li>\n<li>可以通过打断点的方式查看一个方法的函数调用栈</li>\n</ul>\n<p><code>CFRunLoopObserverRef</code>观察者,监听RunLoop的状态:</p>\n<p>监听的状态是枚举:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>),           <span class=\"comment\">//即将进入Runloop</span></div><div class=\"line\">    kCFRunLoopBeforeTimers = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>),    <span class=\"comment\">//即将处理NSTimer</span></div><div class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>),   <span class=\"comment\">//即将处理Sources</span></div><div class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>),   <span class=\"comment\">//即将进入休眠</span></div><div class=\"line\">    kCFRunLoopAfterWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>),    <span class=\"comment\">//刚从休眠中唤醒</span></div><div class=\"line\">    kCFRunLoopExit = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>),            <span class=\"comment\">//即将退出runloop</span></div><div class=\"line\">    kCFRunLoopAllActivities = <span class=\"number\">0x0FFFFFFF</span>U   <span class=\"comment\">//所有状态改变</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>给RunLoop添加监听者:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个runloop监听者</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreateWithHandler</span>(<span class=\"built_in\">CFAllocatorGetDefault</span>(),kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, ^(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity) &#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"监听runloop状态改变---%zd\"</span>,activity);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//为runloop添加一个监听者</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 必须释放</span></div><div class=\"line\"><span class=\"built_in\">CFRelease</span>(observer);</div></pre></td></tr></table></figure>\n<p><code>CFRunloopTimerRef</code>是定时器事件, <code>NSTimer</code>是基于<code>CFRunloopTimerRef</code>的封装, 是基于时间的触发器, 需要把timer加入到RunLoop里面去, RunLoop会在相应的时间点注册事件, 等时间到了触发唤醒RunLoop执行事件.  </p>\n<p>定时器在开发中使用广泛, 但是很容易犯错, 有两种方式设置定时事件, <code>NSTimer</code>和<code>GCD</code>, 两者的定时器不同, <code>GCD</code>的更加精准, 不受RunLoop的影响. 而且RunLoop里面设置循环过期时间也是用的<code>GCD</code>的定时器, 由此可知, RunLoop 会使用 GCD 的部分功能.</p>\n<p>注意:</p>\n<blockquote>\n<p>使用timer 的时候一定要注意添加到哪种mode模式下, 一般标记为<code>NSRunLoopCommonModes</code>下, 也就是说任何模式下都可以正常运行定时器, 否则只能特定模式下运行, 当RunLoop切换模式后, 定时器不正常工作.</p>\n</blockquote>\n<h4 id=\"NSTimer-RunLoop用法\"><a href=\"#NSTimer-RunLoop用法\" class=\"headerlink\" title=\"NSTimer + RunLoop用法:\"></a>NSTimer + RunLoop用法:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)timer2 &#123;</div><div class=\"line\">   <span class=\"comment\">//NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode</span></div><div class=\"line\">    </div><div class=\"line\">   <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">2.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">    </div><div class=\"line\">   <span class=\"comment\">//更改模式</span></div><div class=\"line\">   [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (<span class=\"keyword\">void</span>)timer1 &#123;</div><div class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">2.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作</span></div><div class=\"line\">   <span class=\"comment\">// [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 占位模式：common modes标记</span></div><div class=\"line\">   <span class=\"comment\">// 被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode</span></div><div class=\"line\">   [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// NSLog(@\"%@\",[NSRunLoop currentRunLoop]);</span></div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---run---%@\"</span>, [<span class=\"built_in\">NSRunLoop</span> currentRunLoop].currentMode);</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)btnClick &#123;</div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---btnClick---\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有一种办法是添加两次:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">UITrackingRunLoopMode</span>];</div><div class=\"line\"></div><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"GCD-定时器用法\"><a href=\"#GCD-定时器用法\" class=\"headerlink\" title=\"GCD 定时器用法:\"></a>GCD 定时器用法:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//0.创建一个队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1.创建一个GCD的定时器</span></div><div class=\"line\">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, queue);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2.设置定时器的开始时间，间隔时间以及精准度</span></div><div class=\"line\">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,<span class=\"number\">3.0</span> *<span class=\"built_in\">NSEC_PER_SEC</span>);</div><div class=\"line\"><span class=\"comment\">//设置定时器工作的间隔时间</span></div><div class=\"line\">uint64_t intevel = <span class=\"number\">1.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0</div><div class=\"line\">该参数的意义：可以适当的提高程序的性能</div><div class=\"line\">注意点：GCD定时器中的时间以纳秒为单位</div><div class=\"line\">*/</span></div><div class=\"line\">dispatch_source_set_timer(timer, start, intevel, <span class=\"number\">0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3.设置定时器开启后回调的方法</span></div><div class=\"line\">dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"------%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4.执行定时器</span></div><div class=\"line\">dispatch_resume(timer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用</span></div><div class=\"line\"><span class=\"keyword\">self</span>.timer = timer;</div></pre></td></tr></table></figure>\n<h3 id=\"RunLoop运行逻辑\"><a href=\"#RunLoop运行逻辑\" class=\"headerlink\" title=\"RunLoop运行逻辑\"></a>RunLoop运行逻辑</h3><p>运行逻辑就是一个do-while大循环, 在这个循环里面处理事件, 监听RunLoop的状态, 不停的<code>休眠-唤醒-处理-休眠</code>这个过程.</p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/3.png\" alt=\"处理过程\"></p>\n<p><img src=\"http://oixseublm.bkt.clouddn.com/4.png\" alt=\"逻辑图\"></p>\n<h3 id=\"RunLoop应用\"><a href=\"#RunLoop应用\" class=\"headerlink\" title=\"RunLoop应用\"></a>RunLoop应用</h3><p>下面是开发中经常使用RunLoop的地方:</p>\n<h4 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">3</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---timer block---\"</span>);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>控制台输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">2017-02-28 11:17:46.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:49.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:52.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:55.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:17:58.102 test[2831:93953] ---timer block---</div><div class=\"line\">2017-02-28 11:18:01.175 test[2831:93953] ---timer block---</div></pre></td></tr></table></figure>\n<h4 id=\"ImageView显示\"><a href=\"#ImageView显示\" class=\"headerlink\" title=\"ImageView显示\"></a>ImageView显示</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.imageView performSelector:<span class=\"keyword\">@selector</span>(setImage:) withObject:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"abc\"</span>] afterDelay:<span class=\"number\">2.0</span> inModes:@[<span class=\"built_in\">NSDefaultRunLoopMode</span>,<span class=\"built_in\">UITrackingRunLoopMode</span>]];</div></pre></td></tr></table></figure>\n<h4 id=\"PerformSelector\"><a href=\"#PerformSelector\" class=\"headerlink\" title=\"PerformSelector\"></a>PerformSelector</h4><p>有很多 PerformSelector 方法都是需要制定mode, date的, 正如上面所示.</p>\n<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<h4 id=\"常驻线程\"><a href=\"#常驻线程\" class=\"headerlink\" title=\"常驻线程\"></a>常驻线程</h4><p>有时需要在后台开启一个线程持续的做任务, 比如搜集数据, 语音唤起等, 无非就是在一个线程中开启一个RunLoop 让它维持线程的持续运行, 而不是执行完任务后退出.<br>AFN框架中也是用了:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)networkRequestThreadEntryPoint:(<span class=\"keyword\">id</span>)__unused object &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        [[<span class=\"built_in\">NSThread</span> currentThread] setName:<span class=\"string\">@\"AFNetworking\"</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRunLoop</span> *runLoop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\">        [runLoop addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">        [runLoop run];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)networkRequestThread &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSThread</span> *_networkRequestThread = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> oncePredicate;</div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(networkRequestThreadEntryPoint:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意:</p>\n<blockquote>\n<p>子线程的RunLoop里面至少要有一个source或者是timer, 只有observer不行的.</p>\n</blockquote>\n<h4 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h4><p>自动释放池的第一次创建:<br><code>第一次进入RunLoop时候自动创建</code>.</p>\n<p>自动释放池的第一次销毁:<br><code>RunLoop即将进入休眠的时候</code></p>\n<p>其它情况下创建和销毁:<br><code>唤醒RunLoop的时候会创建新的自动释放池</code><br><code>RunLoop销毁时销毁自动释放池</code></p>\n<p>打印RunLoop信息可以看出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_wrapRunLoopWithAutoreleasePoolHandler  activities = 0x1  1</div><div class=\"line\">_wrapRunLoopWithAutoreleasePoolHandler activities = 0xa0 160</div></pre></td></tr></table></figure>\n<p>160 是 kCFRunLoopBeforeWaiting + kCFRunLoopExit</p>"},{"title":"Swift在扩展中关联对象","date":"2015-12-26T16:00:00.000Z","_content":"Objective-C 最让人诟病的也许就是不能给已有类添加属性, 但是可以通过 Objective-C 的运行时机制关联自定义属性到对象上, 几乎弥补了这个痛点.  \n\nSwift Extension 比 Objective-C Category 增色不少, extension 能够给已有类添加计算型属性, 这已经是很大的进步, 但是仍然不能添加存储属性. Swift 中也可以使用 Objective-C runtime 的关联对象([Associated Objects](http://nshipster.cn/associated-objects/))的方式添加属性, 弥补这一痛点.\n\n\n<!---more--->\n\n## 关联对象(Associated Objects)\nSwift 中提供三个与 Objective-C 类似的方法将自定义的属性关联到对象上:\n1. `objc_setAssociatedObject`\n2. `objc_getAssociatedObject`\n3. `objc_removeAssociatedObjects`\n\n> 注意: 使用 objc_removeAssociatedObjects 时要小心, 这个方法会删除对象关联的所有属性, 就可能导致把别人添加的关联属性也删掉. 如果要删除某一个属性, 使用 objc_setAssociatedObject 方法, value 置为 nil.\n\n下面给 UIView 添加三种不同类型的属性: isShow, displayName, width.\n\n```Swift\nextension UIView {\n    // 嵌套结构体\n    private struct AssociatedKeys {\n        static var isShowKey = \"isShowKey\"\n        static var displayNameKey = \"displayNameKey\"\n        static var widthKey = \"widthKey\"\n    }\n    \n    // Bool 类型\n    var isShow: Bool {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.isShowKey) as! Bool\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.isShowKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n    \n    // String 类型\n    var displayName: String? {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.displayNameKey) as? String\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.displayNameKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_COPY_NONATOMIC)\n        }\n    }\n    \n    // Float 类型\n    var width: Float {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.widthKey) as! Float\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.widthKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n```\n\n上述列子说明几点:\n- 嵌套私有结构体, 声明与扩展属性对应的键(key). [Swift Extension](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151) 提供了丰富的功能, 可以在 Extension 中嵌套类型, 使用 private 私有访问控制, 不会污染整个命名空间, 而且能够统一管理关联对象键.\n- Swift 的基本类型Int, Float, Double, Bool能够自动隐式地转换成 Objective-C 的 NSNumber 类型, 所以不需要显示的包装成 NSNumber 类型进行关联.\n- 如果使用 `OBJC_ASSOCIATION_ASSIGN` 关联策略时要注意, 文档中指出是弱引用, 但不完全等同于 weak, 更像是 unsafe_unretained 引用, 关联对象被释放后,关联属性仍然保留被释放的地址, 如果不小心访问关联属性, 就会造成野指针访问出错.\n\n>\tSpecifies a weak reference to the associated object.\n\n## 抽取关联对象方法\n我们可以把关联对象的方法提取成公共方法, 在 NSObject 类的 extension 里实现, 只要继承自 NSObject 的类就能够调用关联对象方法, 通过[Swift 泛型](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179)来关联不同类型的属性.\n\n```Swift\nextension NSObject {\n    func setAssociated<T>(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) -> Void {\n        objc_setAssociatedObject(self, associatedKey, value, policy)\n    }\n    \n    func getAssociated<T>(associatedKey: UnsafeRawPointer) -> T? {\n        let value = objc_getAssociatedObject(self, associatedKey) as? T\n        return value;\n    }\n}\n```\n\n我们只需要在 UIView+Extension.swift 中调动上面两个方法即可, 目前只支持有可选类型的属性.\n\n```Swift\nextension UIView {\n    private struct AssociatedKeys {\n        static var displayNameKey = \"displayNameKey\"\n    }\n    \n    var displayName: String? {\n        get {\n            return getAssociated(associatedKey: &AssociatedKeys.displayNameKey)\n        }\n        set {\n            setAssociated(value: newValue, associatedKey: &AssociatedKeys.displayNameKey)\n        }\n    }\n}   \n```\n\n## 关联闭包属性\n开发中有时会给已有类关联闭包属性, 比如给 UIViewController 类添加一个 pushCompletion 的闭包属性, 当导航控制器 push 动作完成后调用该控制器的 pushCompletion 闭包.  \n先按照最基本的方式来关联对象, 如下:\n\n```Swift\ntypealias pushCompletionClosure = ()->()\n\nextension UIViewController {\n    private struct AssociatedKeys {\n        static var pushCompletionKey = \"pushCompletionKey\"\n    }\n    \n    var pushCompletion: pushCompletionClosure? {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.pushCompletionKey) as? pushCompletionClosure\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.pushCompletionKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_COPY_NONATOMIC)\n        }\n    }\n}\n```\n\n开开心心编译一发, 发现编译报错:  \n![关联闭包报错](http://upload-images.jianshu.io/upload_images/4238758-3381fdc45c5a8855.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n定位问题发现出在 objc_setAssociatedObject 这个方法上. 原来闭包属性需要包装一下才能进行关联, 下面给出两种解决办法:\n1. 使用泛型包装闭包属性, 利用 NSObject+Extension.swift 中的 `setAssociated` 方法来关联闭包.\n2. 创建私有闭包容器类, 利用闭包容器间接关联闭包属性.\n\n### 泛型包装闭包属性\nsetAssociated 方法需要泛型参数, 当传入闭包后, 就会把闭包包装成泛型.\n\n```Swift\nset {\n   setAssociated(value: newValue, associatedKey: &AssociatedKeys.pushCompletionKey)\n}\n```\n\n### 闭包容器\n使用闭包容器的方式关联闭包属性, 过程分为两步:\n1. 在 extension 中嵌套创建容器类, 容器类中定义需要关联的闭包属性.\n2. 关联对象时把容器类对象关联到已有类, 间接的就把闭包属性关联到已有类.\n\n闭包容器的方式是把闭包属性包装到了容器中, 再把容器对象关联到已有类上, 跟泛型包装闭包有异曲同工之处, 因此必须通过容器对象来访问闭包, 如果需要给类关联的闭包属性相对较多, 这种方式也不失为一种好方法, 能统一管理闭包属性, 代码层级结构也比较清晰.\n\n```Swift\ntypealias pushCompletionClosure = ()->()\n\nextension UIViewController {\n    private struct AssociatedKeys {\n        static var pushCompletionKey = \"pushCompletionKey\"\n    }\n    \n    // 嵌套闭包容器类\n    class closureContainer {\n        var pushCompletion: pushCompletionClosure?\n    }\n    \n    // 关联容器属性\n    var container: closureContainer? {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.pushCompletionKey) as? closureContainer\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.pushCompletionKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n\n```\n\n`代码在这里:`  \n[github](https://github.com/ChilliCheng/AssociatedObject)\n\n欢迎大家留言斧正!\n\n参考链接:  \n<http://swift.gg/2016/10/11/swift-extensions-can-add-stored-properties/>\n<http://stackoverflow.com/questions/24133058/is-there-a-way-to-set-associated-objects-in-swift/25428409#25428409>\n\n\n\n","source":"_posts/Swift在扩展中关联对象.md","raw":"---\ntitle: Swift在扩展中关联对象\ndate: 2015-12-27 \ncategories: Swift\ntags: [Swift, 关联对象]\n---\nObjective-C 最让人诟病的也许就是不能给已有类添加属性, 但是可以通过 Objective-C 的运行时机制关联自定义属性到对象上, 几乎弥补了这个痛点.  \n\nSwift Extension 比 Objective-C Category 增色不少, extension 能够给已有类添加计算型属性, 这已经是很大的进步, 但是仍然不能添加存储属性. Swift 中也可以使用 Objective-C runtime 的关联对象([Associated Objects](http://nshipster.cn/associated-objects/))的方式添加属性, 弥补这一痛点.\n\n\n<!---more--->\n\n## 关联对象(Associated Objects)\nSwift 中提供三个与 Objective-C 类似的方法将自定义的属性关联到对象上:\n1. `objc_setAssociatedObject`\n2. `objc_getAssociatedObject`\n3. `objc_removeAssociatedObjects`\n\n> 注意: 使用 objc_removeAssociatedObjects 时要小心, 这个方法会删除对象关联的所有属性, 就可能导致把别人添加的关联属性也删掉. 如果要删除某一个属性, 使用 objc_setAssociatedObject 方法, value 置为 nil.\n\n下面给 UIView 添加三种不同类型的属性: isShow, displayName, width.\n\n```Swift\nextension UIView {\n    // 嵌套结构体\n    private struct AssociatedKeys {\n        static var isShowKey = \"isShowKey\"\n        static var displayNameKey = \"displayNameKey\"\n        static var widthKey = \"widthKey\"\n    }\n    \n    // Bool 类型\n    var isShow: Bool {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.isShowKey) as! Bool\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.isShowKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n    \n    // String 类型\n    var displayName: String? {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.displayNameKey) as? String\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.displayNameKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_COPY_NONATOMIC)\n        }\n    }\n    \n    // Float 类型\n    var width: Float {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.widthKey) as! Float\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.widthKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n```\n\n上述列子说明几点:\n- 嵌套私有结构体, 声明与扩展属性对应的键(key). [Swift Extension](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151) 提供了丰富的功能, 可以在 Extension 中嵌套类型, 使用 private 私有访问控制, 不会污染整个命名空间, 而且能够统一管理关联对象键.\n- Swift 的基本类型Int, Float, Double, Bool能够自动隐式地转换成 Objective-C 的 NSNumber 类型, 所以不需要显示的包装成 NSNumber 类型进行关联.\n- 如果使用 `OBJC_ASSOCIATION_ASSIGN` 关联策略时要注意, 文档中指出是弱引用, 但不完全等同于 weak, 更像是 unsafe_unretained 引用, 关联对象被释放后,关联属性仍然保留被释放的地址, 如果不小心访问关联属性, 就会造成野指针访问出错.\n\n>\tSpecifies a weak reference to the associated object.\n\n## 抽取关联对象方法\n我们可以把关联对象的方法提取成公共方法, 在 NSObject 类的 extension 里实现, 只要继承自 NSObject 的类就能够调用关联对象方法, 通过[Swift 泛型](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179)来关联不同类型的属性.\n\n```Swift\nextension NSObject {\n    func setAssociated<T>(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) -> Void {\n        objc_setAssociatedObject(self, associatedKey, value, policy)\n    }\n    \n    func getAssociated<T>(associatedKey: UnsafeRawPointer) -> T? {\n        let value = objc_getAssociatedObject(self, associatedKey) as? T\n        return value;\n    }\n}\n```\n\n我们只需要在 UIView+Extension.swift 中调动上面两个方法即可, 目前只支持有可选类型的属性.\n\n```Swift\nextension UIView {\n    private struct AssociatedKeys {\n        static var displayNameKey = \"displayNameKey\"\n    }\n    \n    var displayName: String? {\n        get {\n            return getAssociated(associatedKey: &AssociatedKeys.displayNameKey)\n        }\n        set {\n            setAssociated(value: newValue, associatedKey: &AssociatedKeys.displayNameKey)\n        }\n    }\n}   \n```\n\n## 关联闭包属性\n开发中有时会给已有类关联闭包属性, 比如给 UIViewController 类添加一个 pushCompletion 的闭包属性, 当导航控制器 push 动作完成后调用该控制器的 pushCompletion 闭包.  \n先按照最基本的方式来关联对象, 如下:\n\n```Swift\ntypealias pushCompletionClosure = ()->()\n\nextension UIViewController {\n    private struct AssociatedKeys {\n        static var pushCompletionKey = \"pushCompletionKey\"\n    }\n    \n    var pushCompletion: pushCompletionClosure? {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.pushCompletionKey) as? pushCompletionClosure\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.pushCompletionKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_COPY_NONATOMIC)\n        }\n    }\n}\n```\n\n开开心心编译一发, 发现编译报错:  \n![关联闭包报错](http://upload-images.jianshu.io/upload_images/4238758-3381fdc45c5a8855.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n定位问题发现出在 objc_setAssociatedObject 这个方法上. 原来闭包属性需要包装一下才能进行关联, 下面给出两种解决办法:\n1. 使用泛型包装闭包属性, 利用 NSObject+Extension.swift 中的 `setAssociated` 方法来关联闭包.\n2. 创建私有闭包容器类, 利用闭包容器间接关联闭包属性.\n\n### 泛型包装闭包属性\nsetAssociated 方法需要泛型参数, 当传入闭包后, 就会把闭包包装成泛型.\n\n```Swift\nset {\n   setAssociated(value: newValue, associatedKey: &AssociatedKeys.pushCompletionKey)\n}\n```\n\n### 闭包容器\n使用闭包容器的方式关联闭包属性, 过程分为两步:\n1. 在 extension 中嵌套创建容器类, 容器类中定义需要关联的闭包属性.\n2. 关联对象时把容器类对象关联到已有类, 间接的就把闭包属性关联到已有类.\n\n闭包容器的方式是把闭包属性包装到了容器中, 再把容器对象关联到已有类上, 跟泛型包装闭包有异曲同工之处, 因此必须通过容器对象来访问闭包, 如果需要给类关联的闭包属性相对较多, 这种方式也不失为一种好方法, 能统一管理闭包属性, 代码层级结构也比较清晰.\n\n```Swift\ntypealias pushCompletionClosure = ()->()\n\nextension UIViewController {\n    private struct AssociatedKeys {\n        static var pushCompletionKey = \"pushCompletionKey\"\n    }\n    \n    // 嵌套闭包容器类\n    class closureContainer {\n        var pushCompletion: pushCompletionClosure?\n    }\n    \n    // 关联容器属性\n    var container: closureContainer? {\n        get {\n            return objc_getAssociatedObject(self, &AssociatedKeys.pushCompletionKey) as? closureContainer\n        }\n        set {\n            objc_setAssociatedObject(self, &AssociatedKeys.pushCompletionKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)\n        }\n    }\n}\n\n```\n\n`代码在这里:`  \n[github](https://github.com/ChilliCheng/AssociatedObject)\n\n欢迎大家留言斧正!\n\n参考链接:  \n<http://swift.gg/2016/10/11/swift-extensions-can-add-stored-properties/>\n<http://stackoverflow.com/questions/24133058/is-there-a-way-to-set-associated-objects-in-swift/25428409#25428409>\n\n\n\n","slug":"Swift在扩展中关联对象","published":1,"updated":"2017-02-27T16:18:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizozpeb50002k4exaddm0eme","content":"<p>Objective-C 最让人诟病的也许就是不能给已有类添加属性, 但是可以通过 Objective-C 的运行时机制关联自定义属性到对象上, 几乎弥补了这个痛点.  </p>\n<p>Swift Extension 比 Objective-C Category 增色不少, extension 能够给已有类添加计算型属性, 这已经是很大的进步, 但是仍然不能添加存储属性. Swift 中也可以使用 Objective-C runtime 的关联对象(<a href=\"http://nshipster.cn/associated-objects/\" target=\"_blank\" rel=\"external\">Associated Objects</a>)的方式添加属性, 弥补这一痛点.</p>\n<a id=\"more\"></a>\n<h2 id=\"关联对象-Associated-Objects\"><a href=\"#关联对象-Associated-Objects\" class=\"headerlink\" title=\"关联对象(Associated Objects)\"></a>关联对象(Associated Objects)</h2><p>Swift 中提供三个与 Objective-C 类似的方法将自定义的属性关联到对象上:</p>\n<ol>\n<li><code>objc_setAssociatedObject</code></li>\n<li><code>objc_getAssociatedObject</code></li>\n<li><code>objc_removeAssociatedObjects</code></li>\n</ol>\n<blockquote>\n<p>注意: 使用 objc_removeAssociatedObjects 时要小心, 这个方法会删除对象关联的所有属性, 就可能导致把别人添加的关联属性也删掉. 如果要删除某一个属性, 使用 objc_setAssociatedObject 方法, value 置为 nil.</p>\n</blockquote>\n<p>下面给 UIView 添加三种不同类型的属性: isShow, displayName, width.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 嵌套结构体</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isShowKey = <span class=\"string\">\"isShowKey\"</span></div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> displayNameKey = <span class=\"string\">\"displayNameKey\"</span></div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> widthKey = <span class=\"string\">\"widthKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// Bool 类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> isShow: <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.isShowKey) <span class=\"keyword\">as</span>! <span class=\"type\">Bool</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.isShowKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// String 类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> displayName: <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey) <span class=\"keyword\">as</span>? <span class=\"type\">String</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// Float 类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Float</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.widthKey) <span class=\"keyword\">as</span>! <span class=\"type\">Float</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.widthKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述列子说明几点:</p>\n<ul>\n<li>嵌套私有结构体, 声明与扩展属性对应的键(key). <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151\" target=\"_blank\" rel=\"external\">Swift Extension</a> 提供了丰富的功能, 可以在 Extension 中嵌套类型, 使用 private 私有访问控制, 不会污染整个命名空间, 而且能够统一管理关联对象键.</li>\n<li>Swift 的基本类型Int, Float, Double, Bool能够自动隐式地转换成 Objective-C 的 NSNumber 类型, 所以不需要显示的包装成 NSNumber 类型进行关联.</li>\n<li>如果使用 <code>OBJC_ASSOCIATION_ASSIGN</code> 关联策略时要注意, 文档中指出是弱引用, 但不完全等同于 weak, 更像是 unsafe_unretained 引用, 关联对象被释放后,关联属性仍然保留被释放的地址, 如果不小心访问关联属性, 就会造成野指针访问出错.</li>\n</ul>\n<blockquote>\n<p>   Specifies a weak reference to the associated object.</p>\n</blockquote>\n<h2 id=\"抽取关联对象方法\"><a href=\"#抽取关联对象方法\" class=\"headerlink\" title=\"抽取关联对象方法\"></a>抽取关联对象方法</h2><p>我们可以把关联对象的方法提取成公共方法, 在 NSObject 类的 extension 里实现, 只要继承自 NSObject 的类就能够调用关联对象方法, 通过<a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179\" target=\"_blank\" rel=\"external\">Swift 泛型</a>来关联不同类型的属性.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAssociated</span>&lt;T&gt;<span class=\"params\">(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span></span> -&gt; <span class=\"type\">Void</span> &#123;</div><div class=\"line\">        objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, value, policy)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getAssociated</span>&lt;T&gt;<span class=\"params\">(associatedKey: UnsafeRawPointer)</span></span> -&gt; <span class=\"type\">T</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> value = objc_getAssociatedObject(<span class=\"keyword\">self</span>, associatedKey) <span class=\"keyword\">as</span>? <span class=\"type\">T</span></div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们只需要在 UIView+Extension.swift 中调动上面两个方法即可, 目前只支持有可选类型的属性.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> displayNameKey = <span class=\"string\">\"displayNameKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">var</span> displayName: <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> getAssociated(associatedKey: &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            setAssociated(value: newValue, associatedKey: &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"关联闭包属性\"><a href=\"#关联闭包属性\" class=\"headerlink\" title=\"关联闭包属性\"></a>关联闭包属性</h2><p>开发中有时会给已有类关联闭包属性, 比如给 UIViewController 类添加一个 pushCompletion 的闭包属性, 当导航控制器 push 动作完成后调用该控制器的 pushCompletion 闭包.<br>先按照最基本的方式来关联对象, 如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typealias</span> pushCompletionClosure = ()-&gt;()</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> pushCompletionKey = <span class=\"string\">\"pushCompletionKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">var</span> pushCompletion: pushCompletionClosure? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey) <span class=\"keyword\">as</span>? pushCompletionClosure</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>开开心心编译一发, 发现编译报错:<br><img src=\"http://upload-images.jianshu.io/upload_images/4238758-3381fdc45c5a8855.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"关联闭包报错\"><br>定位问题发现出在 objc_setAssociatedObject 这个方法上. 原来闭包属性需要包装一下才能进行关联, 下面给出两种解决办法:</p>\n<ol>\n<li>使用泛型包装闭包属性, 利用 NSObject+Extension.swift 中的 <code>setAssociated</code> 方法来关联闭包.</li>\n<li>创建私有闭包容器类, 利用闭包容器间接关联闭包属性.</li>\n</ol>\n<h3 id=\"泛型包装闭包属性\"><a href=\"#泛型包装闭包属性\" class=\"headerlink\" title=\"泛型包装闭包属性\"></a>泛型包装闭包属性</h3><p>setAssociated 方法需要泛型参数, 当传入闭包后, 就会把闭包包装成泛型.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> &#123;</div><div class=\"line\">   setAssociated(value: newValue, associatedKey: &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"闭包容器\"><a href=\"#闭包容器\" class=\"headerlink\" title=\"闭包容器\"></a>闭包容器</h3><p>使用闭包容器的方式关联闭包属性, 过程分为两步:</p>\n<ol>\n<li>在 extension 中嵌套创建容器类, 容器类中定义需要关联的闭包属性.</li>\n<li>关联对象时把容器类对象关联到已有类, 间接的就把闭包属性关联到已有类.</li>\n</ol>\n<p>闭包容器的方式是把闭包属性包装到了容器中, 再把容器对象关联到已有类上, 跟泛型包装闭包有异曲同工之处, 因此必须通过容器对象来访问闭包, 如果需要给类关联的闭包属性相对较多, 这种方式也不失为一种好方法, 能统一管理闭包属性, 代码层级结构也比较清晰.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typealias</span> pushCompletionClosure = ()-&gt;()</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> pushCompletionKey = <span class=\"string\">\"pushCompletionKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 嵌套闭包容器类</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">closureContainer</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> pushCompletion: pushCompletionClosure?</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 关联容器属性</span></div><div class=\"line\">    <span class=\"keyword\">var</span> container: closureContainer? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey) <span class=\"keyword\">as</span>? closureContainer</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>代码在这里:</code><br><a href=\"https://github.com/ChilliCheng/AssociatedObject\" target=\"_blank\" rel=\"external\">github</a></p>\n<p>欢迎大家留言斧正!</p>\n<p>参考链接:<br><a href=\"http://swift.gg/2016/10/11/swift-extensions-can-add-stored-properties/\" target=\"_blank\" rel=\"external\">http://swift.gg/2016/10/11/swift-extensions-can-add-stored-properties/</a><br><a href=\"http://stackoverflow.com/questions/24133058/is-there-a-way-to-set-associated-objects-in-swift/25428409#25428409\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/24133058/is-there-a-way-to-set-associated-objects-in-swift/25428409#25428409</a></p>\n","excerpt":"<p>Objective-C 最让人诟病的也许就是不能给已有类添加属性, 但是可以通过 Objective-C 的运行时机制关联自定义属性到对象上, 几乎弥补了这个痛点.  </p>\n<p>Swift Extension 比 Objective-C Category 增色不少, extension 能够给已有类添加计算型属性, 这已经是很大的进步, 但是仍然不能添加存储属性. Swift 中也可以使用 Objective-C runtime 的关联对象(<a href=\"http://nshipster.cn/associated-objects/\">Associated Objects</a>)的方式添加属性, 弥补这一痛点.</p>","more":"<h2 id=\"关联对象-Associated-Objects\"><a href=\"#关联对象-Associated-Objects\" class=\"headerlink\" title=\"关联对象(Associated Objects)\"></a>关联对象(Associated Objects)</h2><p>Swift 中提供三个与 Objective-C 类似的方法将自定义的属性关联到对象上:</p>\n<ol>\n<li><code>objc_setAssociatedObject</code></li>\n<li><code>objc_getAssociatedObject</code></li>\n<li><code>objc_removeAssociatedObjects</code></li>\n</ol>\n<blockquote>\n<p>注意: 使用 objc_removeAssociatedObjects 时要小心, 这个方法会删除对象关联的所有属性, 就可能导致把别人添加的关联属性也删掉. 如果要删除某一个属性, 使用 objc_setAssociatedObject 方法, value 置为 nil.</p>\n</blockquote>\n<p>下面给 UIView 添加三种不同类型的属性: isShow, displayName, width.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 嵌套结构体</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isShowKey = <span class=\"string\">\"isShowKey\"</span></div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> displayNameKey = <span class=\"string\">\"displayNameKey\"</span></div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> widthKey = <span class=\"string\">\"widthKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// Bool 类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> isShow: <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.isShowKey) <span class=\"keyword\">as</span>! <span class=\"type\">Bool</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.isShowKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// String 类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> displayName: <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey) <span class=\"keyword\">as</span>? <span class=\"type\">String</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// Float 类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Float</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.widthKey) <span class=\"keyword\">as</span>! <span class=\"type\">Float</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.widthKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述列子说明几点:</p>\n<ul>\n<li>嵌套私有结构体, 声明与扩展属性对应的键(key). <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151\">Swift Extension</a> 提供了丰富的功能, 可以在 Extension 中嵌套类型, 使用 private 私有访问控制, 不会污染整个命名空间, 而且能够统一管理关联对象键.</li>\n<li>Swift 的基本类型Int, Float, Double, Bool能够自动隐式地转换成 Objective-C 的 NSNumber 类型, 所以不需要显示的包装成 NSNumber 类型进行关联.</li>\n<li>如果使用 <code>OBJC_ASSOCIATION_ASSIGN</code> 关联策略时要注意, 文档中指出是弱引用, 但不完全等同于 weak, 更像是 unsafe_unretained 引用, 关联对象被释放后,关联属性仍然保留被释放的地址, 如果不小心访问关联属性, 就会造成野指针访问出错.</li>\n</ul>\n<blockquote>\n<p>   Specifies a weak reference to the associated object.</p>\n</blockquote>\n<h2 id=\"抽取关联对象方法\"><a href=\"#抽取关联对象方法\" class=\"headerlink\" title=\"抽取关联对象方法\"></a>抽取关联对象方法</h2><p>我们可以把关联对象的方法提取成公共方法, 在 NSObject 类的 extension 里实现, 只要继承自 NSObject 的类就能够调用关联对象方法, 通过<a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179\">Swift 泛型</a>来关联不同类型的属性.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAssociated</span>&lt;T&gt;<span class=\"params\">(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span></span> -&gt; <span class=\"type\">Void</span> &#123;</div><div class=\"line\">        objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, value, policy)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getAssociated</span>&lt;T&gt;<span class=\"params\">(associatedKey: UnsafeRawPointer)</span></span> -&gt; <span class=\"type\">T</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> value = objc_getAssociatedObject(<span class=\"keyword\">self</span>, associatedKey) <span class=\"keyword\">as</span>? <span class=\"type\">T</span></div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们只需要在 UIView+Extension.swift 中调动上面两个方法即可, 目前只支持有可选类型的属性.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> displayNameKey = <span class=\"string\">\"displayNameKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">var</span> displayName: <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> getAssociated(associatedKey: &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            setAssociated(value: newValue, associatedKey: &amp;<span class=\"type\">AssociatedKeys</span>.displayNameKey)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"关联闭包属性\"><a href=\"#关联闭包属性\" class=\"headerlink\" title=\"关联闭包属性\"></a>关联闭包属性</h2><p>开发中有时会给已有类关联闭包属性, 比如给 UIViewController 类添加一个 pushCompletion 的闭包属性, 当导航控制器 push 动作完成后调用该控制器的 pushCompletion 闭包.<br>先按照最基本的方式来关联对象, 如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typealias</span> pushCompletionClosure = ()-&gt;()</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> pushCompletionKey = <span class=\"string\">\"pushCompletionKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">var</span> pushCompletion: pushCompletionClosure? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey) <span class=\"keyword\">as</span>? pushCompletionClosure</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>开开心心编译一发, 发现编译报错:<br><img src=\"http://upload-images.jianshu.io/upload_images/4238758-3381fdc45c5a8855.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"关联闭包报错\"><br>定位问题发现出在 objc_setAssociatedObject 这个方法上. 原来闭包属性需要包装一下才能进行关联, 下面给出两种解决办法:</p>\n<ol>\n<li>使用泛型包装闭包属性, 利用 NSObject+Extension.swift 中的 <code>setAssociated</code> 方法来关联闭包.</li>\n<li>创建私有闭包容器类, 利用闭包容器间接关联闭包属性.</li>\n</ol>\n<h3 id=\"泛型包装闭包属性\"><a href=\"#泛型包装闭包属性\" class=\"headerlink\" title=\"泛型包装闭包属性\"></a>泛型包装闭包属性</h3><p>setAssociated 方法需要泛型参数, 当传入闭包后, 就会把闭包包装成泛型.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> &#123;</div><div class=\"line\">   setAssociated(value: newValue, associatedKey: &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"闭包容器\"><a href=\"#闭包容器\" class=\"headerlink\" title=\"闭包容器\"></a>闭包容器</h3><p>使用闭包容器的方式关联闭包属性, 过程分为两步:</p>\n<ol>\n<li>在 extension 中嵌套创建容器类, 容器类中定义需要关联的闭包属性.</li>\n<li>关联对象时把容器类对象关联到已有类, 间接的就把闭包属性关联到已有类.</li>\n</ol>\n<p>闭包容器的方式是把闭包属性包装到了容器中, 再把容器对象关联到已有类上, 跟泛型包装闭包有异曲同工之处, 因此必须通过容器对象来访问闭包, 如果需要给类关联的闭包属性相对较多, 这种方式也不失为一种好方法, 能统一管理闭包属性, 代码层级结构也比较清晰.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typealias</span> pushCompletionClosure = ()-&gt;()</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AssociatedKeys</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> pushCompletionKey = <span class=\"string\">\"pushCompletionKey\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 嵌套闭包容器类</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">closureContainer</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> pushCompletion: pushCompletionClosure?</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 关联容器属性</span></div><div class=\"line\">    <span class=\"keyword\">var</span> container: closureContainer? &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey) <span class=\"keyword\">as</span>? closureContainer</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;<span class=\"type\">AssociatedKeys</span>.pushCompletionKey, newValue, objc_AssociationPolicy.<span class=\"type\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>代码在这里:</code><br><a href=\"https://github.com/ChilliCheng/AssociatedObject\">github</a></p>\n<p>欢迎大家留言斧正!</p>\n<p>参考链接:<br><a href=\"http://swift.gg/2016/10/11/swift-extensions-can-add-stored-properties/\">http://swift.gg/2016/10/11/swift-extensions-can-add-stored-properties/</a><br><a href=\"http://stackoverflow.com/questions/24133058/is-there-a-way-to-set-associated-objects-in-swift/25428409#25428409\">http://stackoverflow.com/questions/24133058/is-there-a-way-to-set-associated-objects-in-swift/25428409#25428409</a></p>"},{"title":"Swift中安全优雅的使用UserDefaults","date":"2016-02-12T16:00:00.000Z","_content":"纳尼? 如此简单的 UserDefaults 怎么去优雅的使用? 这么简单的还能玩出花来? 没毛病吧?\n\nObjective-C 中的 NSUserDefaults 我们并不陌生, 通常作为数据持久化的一种方式, 一般用来存储用户信息和基础配置信息. Swift 中使用 UserDefaults 来替代 NSUserDefaults, 两者的使用基本相同.\n\n<!---more--->\n\n```Swift\nlet defaults = UserDefaults.standard\ndefaults.set(123, forKey: \"defaultKey\")\ndefaults.integer(forKey: \"defaultKey\")\n```\n\n>Objective-C中需要调用 synchronize 方法进行同步, 但是在Swift中已经废弃了该方法, 所以不需要手动去调用.  \n-synchronize is deprecated and will be marked with the NS_DEPRECATED macro in a future release.\n\n上面的用法是最基本的用法, 也是我们平常开发中使用频率最高的用法, 但也是最危险的用法, 为什么呢?  \n\n1. 在应用内部我们可以随意地覆盖和删除存储的值, 直接使用字符串来作为存储数据的 key 是非常危险的, 容易导致存数据时使用的 key 和取数据的时候使用的 key 不一致.\n2. UserDefaults.standard 是一个全局的单例, 如果需要存储账户信息(AccountInfo), 配置信息(SettingInfo), 此时按照最基本的使用方式, 简单的使用 key 来存取数据, 那么 key 值会随着存储的数据越来越多, 到时候不管是新接手的小伙伴还是我们自己都很难明白每个 key 值对应的意义. 也就是说我们不能根据方法调用的上下文明确知道我存取数据的具体含义, 代码的可读性和可维护性就不高.所以我们要利用 Swift 强大的灵活性来让我们使用 UserDefaults 存取数据的时候更加便捷和安全. \n\n所以要想把 UserDefaults 玩出花来就得解决下面两个问题:\n* `一致性`\n* `上下文`\n\n### 一致性\n使用 UserDefaults 存取数据时使用的 key 值不同就会导致存在一致性问题. 原因就在于通常我们在存取数据的时候, 手动键入 key 或者复制粘贴 key 可能会出错, 输入的时候也很麻烦. 那我们的目的就比较明确了, 就是为了让存取的 key 一致, 即使改了其中一个另外一个也随之更改. \n\n解决办法: \n* 常量保存\n* 分组存储\n\n#### 常量保存字符串\n既然涉及到两个重复使用的字符串, 很容易就想到用常量保存字符串, 只有在初始化的时候设置 key 值, 存取的时候拿来用即可, 简单粗暴的方式.\n\n``` Swift\nlet defaultStand = UserDefaults.standard\nlet defaultKey = \"defaultKey\"\ndefaultStand.set(123, forKey: defaultKey)\ndefaultStand.integer(forKey: defaultKey)\n```\n是不是感觉有点换汤不换药? 上面使用常量存储 key 值, 虽然能够保证存取的时候 key 值相同, 但是在设置 key 值的时候稍显麻烦.  \n最重要的一点就是如果需要存很多账户信息或者配置信息的时候, 按照这种方式都写在同一处地方就稍微欠妥, 比如下面这个场景, 在 app 启动后, 需要存储用户信息和登录信息, 用户信息里面包含: userName, avatar, password, gender等, 登录信息里包含: token, userId, timeStamp等等, 也就说需要存两类不同的信息, 那么此时这种方式就不合时宜了, 我们就会想办法把同类的信息归为一组, 进行分组存取.\n\n#### 分组存储\n分组存储 key 可以把存储数据按不同类别区分开, 代码的可读性和可维护性大大提升. 我们可以采用类class, 结构体struct, 枚举enum来进行分组存储 key, 下面使用结构体来示例.\n\n```Swift\n// 账户信息\nstruct AccountInfo {\n    let userName = \"userName\"\n    let avatar = \"avatar\"\n    let password = \"password\"\n    let gender = \"gender\"\n    let age = \"age\"\n    \n}\n// 登录信息\nstruct LoginInfo {\n    let token = \"token\"\n    let userId = \"userId\"\n}\n// 配置信息\nstruct SettingInfo {\n    let font = \"font\"\n    let backgroundImage = \"backgroundImage\"\n}\n```\n存取数据:\n\n```Swift\nlet defaultStand = UserDefaults.standard\n// 账户信息\ndefaultStand.set(\"Chilli Cheng\", forKey: AccountInfo().avatar)\ndefaultStand.set(18, forKey: AccountInfo().age)\n// 登录信息\ndefaultStand.set(\"achj167\", forKey: LoginInfo().token)\n// 配置信息\ndefaultStand.set(24, forKey: SettingInfo().font)\n        \nlet userName = defaultStand.string(forKey: AccountInfo().avatar)\nlet age = defaultStand.integer(forKey: AccountInfo().age)\nlet token = defaultStand.string(forKey: LoginInfo().token)\nlet font = defaultStand.integer(forKey: SettingInfo().font)\n```\n\n### 上下文\n\n上面这种方式是不是比直接使用常量的效果更好? 但是仍然有个问题, 账户信息, 登录信息, 配置信息都是属于要存储的信息, 那我们就可以把这三类信息归到一个大类里, 在这个大类中有这三个小类, 三个小类作为大类的属性, 既能解决一致性问题, 又能解决上下文的问题, 需要存储到 UserDefaults 里面的数据, 我只需要去特定的类中找到对应分组里面的属性即可. 示例:\n\n```Swift\nstruct UserDefaultKeys {\n    // 账户信息\n    struct AccountInfo {\n        let userName = \"userName\"\n        let avatar = \"avatar\"\n        let password = \"password\"\n        let gender = \"gender\"\n        let age = \"age\"\n    }\n    // 登录信息\n    struct LoginInfo {\n        let token = \"token\"\n        let userId = \"userId\"\n    }\n    // 配置信息\n    struct SettingInfo {\n        let font = \"font\"\n        let backgroundImage = \"backgroundImage\"\n    }\n}\n```\n存取数据:\n\n```\nlet defaultStand = UserDefaults.standard\n// 账户信息\ndefaultStand.set(\"Chilli Cheng\", forKey:UserDefaultKeys.AccountInfo().userName)\ndefaultStand.string(forKey: UserDefaultKeys.AccountInfo().userName)\n```\n上面的代码看起来可读性好了很多, 不仅是为了新接手的小伙伴能看懂, 更是为了我们自己过段时间能看懂. 我亲眼见过自己写的代码看不懂反而要进行重构的小伙伴. \n\n#### 避免初始化\n但是上面的代码存在一个明显的缺陷, 每次存取值的时候需要初始化 struct 出一个实例, 再访问这个实例的属性获取 key 值, 其实是不必要的, 怎么才能做到不初始化实例就能访问属性呢? 可以使用静态变量, 直接通过类型名字访问属性的值.\n\n```Swift\nstruct AccountInfo {\n    static let userName = \"userName\"\n    static let avatar = \"avatar\"\n    static let password = \"password\"\n    static let gender = \"gender\"\n    static let age = \"age\"\n}\n```\n存取的时候:\n\n```Swift\ndefaultStand.set(\"Chilli Cheng\", forKey: UserDefaultKeys.AccountInfo.userName)\ndefaultStand.string(forKey: UserDefaultKeys.AccountInfo.userName)\n```\n\n#### 枚举分组存储\n上面的方法虽然能基本满足要求, 但是仍然不完美, 我们依然需要手动去设置 key, 当 key 值很多的时候, 需要一个个的设置, 那有没有可以一劳永逸的办法呢? 不需要我们自己设置 key 的值, 让系统默认给我们设置好 key 的初始值, 我们直接拿 key 去进行存取数据. Swift这么好的语言当然可以实现, 即用枚举的方式, 枚举不仅可以分组设置 key, 还能默认设置 key 的原始值. 前提是我们需要遵守 String 协议, 不设置 rawValue 的时候, 系统会默认给我们的枚举 case 设置跟成员名字相同的原始值(rawValue), 我们就可以拿这个 rawValue 来作为存取数据的 key.\n\n```Swift\nstruct UserDefaultKeys {\n    // 账户信息\n    enum AccountInfo: String {\n        case userName\n        case age\n    }\n}\n\n// 存账户信息\ndefaultStand.set(\"Chilli Cheng\", forKey: UserDefaultKeys.AccountInfo.userName.rawValue)\ndefaultStand.set(18, forKey: UserDefaultKeys.AccountInfo.age.rawValue)\n\n// 取存账户信息\ndefaultStand.string(forKey: UserDefaultKeys.AccountInfo.userName.rawValue)\ndefaultStand.integer(forKey: UserDefaultKeys.AccountInfo.age.rawValue)\n```\n吼吼, 是不是感觉很方便, Swift 太棒了!\n上面基本就能达到我们的目的, 既解决了一致性问题, 又有上下文知道我存取数据使用的 key 的含义. 但是代码看起来很冗余, 我不就需要一个key 嘛, 干嘛非要链式调用那么多层呢? 还有就是为啥我非要写 rawValue 呢? 如果新来的小伙伴不知道 rawValue 是什么鬼肯定懵逼. \n\n#### 优化 key 值路径\n虽然上面的代码能很好的达到目的, 但是写法和使用上还是欠妥, 我们仍需要继续改进, 上面的代码主要存在两个问题:\n* key 值路径太长\n* rawValue 没必要写\n\n我们先分析一下为什么会出现这个两个问题: \nkey值的路径长是因为我们想分组存储 key, 让key具有上下文, 可读性更改,\nrawValue 的作用是因为我们使用枚举来存储 key, 就不需要去手动设置 key 的初始值. \n\n看起来简直是\"鱼和熊掌不能兼得\", 有什么办法能解决\"鱼和熊掌\"的问题呢?  \n那就是\"砍掉抓着鱼的熊掌\". 也就是说我们必须先解决一个问题(先让熊抓鱼), 再想法\"砍熊掌\".\n\n有了上面的一系列步骤, 解决第一个问题并不像刚开始一样使用简单的字符串, 而必须是使用枚举, 在这个前提下去\"抓鱼\". 也就是我能不能直接传枚举成员值进去, 先利用枚举的 rawValue 解决第一个问题,例如这样使用:\n\n```Swift\ndefaultStand.set(\"Chilli Cheng\", forKey: .userName)\ndefaultStand.string(forKey: .userName)\n```\n很明显能够实现, 只要给 userDefaults 扩展自定义方法即可, 在自定义方法中调用系统的方法进行存取, 为了使用方便我们扩展类方法.示例:\n\n```Swift\nextension UserDefaults {\n    enum AccountKeys: String {\n        case userName\n        case age\n    }\n    \n    static func set(value: String, forKey key: AccountKeys) {\n        let key = key.rawValue\n        UserDefaults.standard.set(value, forKey: key)\n    }\n\n    static func string(forKey key: AccountKeys) -> String? {\n        let key = key.rawValue\n        return UserDefaults.standard.string(forKey: key)\n    }\n}\n\n// 存取数据\nUserDefaults.set(value: \"chilli cheng\", forKey: .userName)\nUserDefaults.string(forKey: .userName)\n```\n\n#### 前置上下文\n 能实现上面的目的之一, 但是没有上下文, 既然在 key 那里不能加, 换一个思路, 那就在前面加, 例如:\n \n```Swift\nUserDefaults.AccountInfo.set(value: \"chilli cheng\", forKey: .userName)\nUserDefaults.AccountInfo.string(forKey: .userName)\n```\n\n要实现上面的实现方式, 需要扩展 UserDefaults, 添加 AccountInfo 属性, 再调用 AccountInfo 的方法, key值由 AccountInfo 来提供, 因为AccountInfo 提供分组的 key, 由于是自定义的一个分组信息, 需要实现既定方法, 必然想到用协议呀, 毕竟 Swift 的协议很强大, Swift 就是面向协议编程的.  \n那我们先把自定义的方法抽取到协议中, 额, 但是协议不是只能提供方法声明, 不提供方法实现吗? 谁说的? 站出来我保证不打死他! Swift 中可以对协议 protocol 进行扩展, 提供协议方法的默认实现, 如果遵守协议的类/结构体/枚举实现了该方法, 就会覆盖掉默认的方法.\n我们来试着实现一下, 先写一个协议, 提供默认的方法实现:\n\n```Swift\nprotocol UserDefaultsSettable {\n    \n}\n\nextension UserDefaultsSettable {\n    static func set(value: String, forKey key: AccountKeys) {\n        let key = key.rawValue\n        UserDefaults.standard.set(value, forKey: key)\n    }\n    static func string(forKey key: AccountKeys) -> String? {\n        let key = key.rawValue\n        return UserDefaults.standard.string(forKey: key)\n    }\n}\n```\n只要我的 AccountInfo 类/结构体/枚举遵守这个协议, 就能调用存取方法了, 但是, 现在问题来了, 也是至关重要的问题, AccountKeys 从哪儿来? 我们上面是把 AccountKeys 写在UserDefaults扩展里面的, 在协议里面如何知道这个变量是什么类型呢? 而且还使用到了 rawValue, 为了通用性, 那就需要在协议里[关联类型](http://wiki.jikexueyuan.com/project/swift/chapter2/23_Generics.html#associated_types), 而且传入的值能拿到 rawValue, 那么这个关联类型需要遵守 RawRepresentable 协议, 这个很关键!!!\n\n```Swift\nprotocol UserDefaultsSettable {\n    associatedtype defaultKeys: RawRepresentable\n}\n\nextension UserDefaultsSettable where defaultKeys.RawValue==String {\n    static func set(value: String?, forKey key: defaultKeys) {\n        let aKey = key.rawValue\n        UserDefaults.standard.set(value, forKey: aKey)\n    }\n    static func string(forKey key: defaultKeys) -> String? {\n        let aKey = key.rawValue\n        return UserDefaults.standard.string(forKey: aKey)\n    }\n}\n```\n\n>必须在扩展中使用 where 子语句限制关联类型是字符串类型, 因为 UserDefaults 的 key 就是字符串类型.\nwhere defaultKeys.RawValue==String\n\n\n在 UserDefaults 的扩展中定义分组 key: \n\n```Swift\nextension UserDefaults {\n    // 账户信息\n    struct AccountInfo: UserDefaultsSettable {\n        enum defaultKeys: String {\n            case userName\n            case age\n        }\n    }\n    \n    // 登录信息\n    struct LoginInfo: UserDefaultsSettable {\n        enum defaultKeys: String {\n            case token\n            case userId\n        }\n    }\n}\n```\n\n存取数据:\n\n```Swift\nUserDefaults.AccountInfo.set(value: \"chilli cheng\", forKey: .userName)\nUserDefaults.AccountInfo.string(forKey: .userName)\n        \nUserDefaults.LoginInfo.set(value: \"ahdsjhad\", forKey: .token)\nUserDefaults.LoginInfo.string(forKey: .token)\n```\n\n打完收工, 既没有手动去写 key, 避免了写错的问题, 实现了key的一致性, 又实现了上下文, 能够直接明白 key 的含义.\n如果还有需要存储的分类数据, 同样在 UserDefaults extension 中添加一个结构体, 遵守 UserDefaultsSettable 协议, 实现 defaultKeys 枚举属性, 在枚举中设置该分类存储数据所需要的 key.\n\n> 注意: UserDefaultsSettable 协议中只实现了存取 string 类型的数据, 可以自行在 UserDefaultsSettable 协议中添加 Int, Bool等类型方法. 虽然这种用法前期比较费劲, 但是不失为一种管理 UserDefaults 的比较好的方式.  \n> 如果大家有更好的方式, 欢迎交流.\n\n欢迎大家斧正!\n\n\n\n","source":"_posts/Swift中安全优雅的使用UserDefaults.md","raw":"---\ntitle: Swift中安全优雅的使用UserDefaults\ndate: 2016-02-13\ncategories: Swift\ntags: [UserDefaults, Swift]\n---\n纳尼? 如此简单的 UserDefaults 怎么去优雅的使用? 这么简单的还能玩出花来? 没毛病吧?\n\nObjective-C 中的 NSUserDefaults 我们并不陌生, 通常作为数据持久化的一种方式, 一般用来存储用户信息和基础配置信息. Swift 中使用 UserDefaults 来替代 NSUserDefaults, 两者的使用基本相同.\n\n<!---more--->\n\n```Swift\nlet defaults = UserDefaults.standard\ndefaults.set(123, forKey: \"defaultKey\")\ndefaults.integer(forKey: \"defaultKey\")\n```\n\n>Objective-C中需要调用 synchronize 方法进行同步, 但是在Swift中已经废弃了该方法, 所以不需要手动去调用.  \n-synchronize is deprecated and will be marked with the NS_DEPRECATED macro in a future release.\n\n上面的用法是最基本的用法, 也是我们平常开发中使用频率最高的用法, 但也是最危险的用法, 为什么呢?  \n\n1. 在应用内部我们可以随意地覆盖和删除存储的值, 直接使用字符串来作为存储数据的 key 是非常危险的, 容易导致存数据时使用的 key 和取数据的时候使用的 key 不一致.\n2. UserDefaults.standard 是一个全局的单例, 如果需要存储账户信息(AccountInfo), 配置信息(SettingInfo), 此时按照最基本的使用方式, 简单的使用 key 来存取数据, 那么 key 值会随着存储的数据越来越多, 到时候不管是新接手的小伙伴还是我们自己都很难明白每个 key 值对应的意义. 也就是说我们不能根据方法调用的上下文明确知道我存取数据的具体含义, 代码的可读性和可维护性就不高.所以我们要利用 Swift 强大的灵活性来让我们使用 UserDefaults 存取数据的时候更加便捷和安全. \n\n所以要想把 UserDefaults 玩出花来就得解决下面两个问题:\n* `一致性`\n* `上下文`\n\n### 一致性\n使用 UserDefaults 存取数据时使用的 key 值不同就会导致存在一致性问题. 原因就在于通常我们在存取数据的时候, 手动键入 key 或者复制粘贴 key 可能会出错, 输入的时候也很麻烦. 那我们的目的就比较明确了, 就是为了让存取的 key 一致, 即使改了其中一个另外一个也随之更改. \n\n解决办法: \n* 常量保存\n* 分组存储\n\n#### 常量保存字符串\n既然涉及到两个重复使用的字符串, 很容易就想到用常量保存字符串, 只有在初始化的时候设置 key 值, 存取的时候拿来用即可, 简单粗暴的方式.\n\n``` Swift\nlet defaultStand = UserDefaults.standard\nlet defaultKey = \"defaultKey\"\ndefaultStand.set(123, forKey: defaultKey)\ndefaultStand.integer(forKey: defaultKey)\n```\n是不是感觉有点换汤不换药? 上面使用常量存储 key 值, 虽然能够保证存取的时候 key 值相同, 但是在设置 key 值的时候稍显麻烦.  \n最重要的一点就是如果需要存很多账户信息或者配置信息的时候, 按照这种方式都写在同一处地方就稍微欠妥, 比如下面这个场景, 在 app 启动后, 需要存储用户信息和登录信息, 用户信息里面包含: userName, avatar, password, gender等, 登录信息里包含: token, userId, timeStamp等等, 也就说需要存两类不同的信息, 那么此时这种方式就不合时宜了, 我们就会想办法把同类的信息归为一组, 进行分组存取.\n\n#### 分组存储\n分组存储 key 可以把存储数据按不同类别区分开, 代码的可读性和可维护性大大提升. 我们可以采用类class, 结构体struct, 枚举enum来进行分组存储 key, 下面使用结构体来示例.\n\n```Swift\n// 账户信息\nstruct AccountInfo {\n    let userName = \"userName\"\n    let avatar = \"avatar\"\n    let password = \"password\"\n    let gender = \"gender\"\n    let age = \"age\"\n    \n}\n// 登录信息\nstruct LoginInfo {\n    let token = \"token\"\n    let userId = \"userId\"\n}\n// 配置信息\nstruct SettingInfo {\n    let font = \"font\"\n    let backgroundImage = \"backgroundImage\"\n}\n```\n存取数据:\n\n```Swift\nlet defaultStand = UserDefaults.standard\n// 账户信息\ndefaultStand.set(\"Chilli Cheng\", forKey: AccountInfo().avatar)\ndefaultStand.set(18, forKey: AccountInfo().age)\n// 登录信息\ndefaultStand.set(\"achj167\", forKey: LoginInfo().token)\n// 配置信息\ndefaultStand.set(24, forKey: SettingInfo().font)\n        \nlet userName = defaultStand.string(forKey: AccountInfo().avatar)\nlet age = defaultStand.integer(forKey: AccountInfo().age)\nlet token = defaultStand.string(forKey: LoginInfo().token)\nlet font = defaultStand.integer(forKey: SettingInfo().font)\n```\n\n### 上下文\n\n上面这种方式是不是比直接使用常量的效果更好? 但是仍然有个问题, 账户信息, 登录信息, 配置信息都是属于要存储的信息, 那我们就可以把这三类信息归到一个大类里, 在这个大类中有这三个小类, 三个小类作为大类的属性, 既能解决一致性问题, 又能解决上下文的问题, 需要存储到 UserDefaults 里面的数据, 我只需要去特定的类中找到对应分组里面的属性即可. 示例:\n\n```Swift\nstruct UserDefaultKeys {\n    // 账户信息\n    struct AccountInfo {\n        let userName = \"userName\"\n        let avatar = \"avatar\"\n        let password = \"password\"\n        let gender = \"gender\"\n        let age = \"age\"\n    }\n    // 登录信息\n    struct LoginInfo {\n        let token = \"token\"\n        let userId = \"userId\"\n    }\n    // 配置信息\n    struct SettingInfo {\n        let font = \"font\"\n        let backgroundImage = \"backgroundImage\"\n    }\n}\n```\n存取数据:\n\n```\nlet defaultStand = UserDefaults.standard\n// 账户信息\ndefaultStand.set(\"Chilli Cheng\", forKey:UserDefaultKeys.AccountInfo().userName)\ndefaultStand.string(forKey: UserDefaultKeys.AccountInfo().userName)\n```\n上面的代码看起来可读性好了很多, 不仅是为了新接手的小伙伴能看懂, 更是为了我们自己过段时间能看懂. 我亲眼见过自己写的代码看不懂反而要进行重构的小伙伴. \n\n#### 避免初始化\n但是上面的代码存在一个明显的缺陷, 每次存取值的时候需要初始化 struct 出一个实例, 再访问这个实例的属性获取 key 值, 其实是不必要的, 怎么才能做到不初始化实例就能访问属性呢? 可以使用静态变量, 直接通过类型名字访问属性的值.\n\n```Swift\nstruct AccountInfo {\n    static let userName = \"userName\"\n    static let avatar = \"avatar\"\n    static let password = \"password\"\n    static let gender = \"gender\"\n    static let age = \"age\"\n}\n```\n存取的时候:\n\n```Swift\ndefaultStand.set(\"Chilli Cheng\", forKey: UserDefaultKeys.AccountInfo.userName)\ndefaultStand.string(forKey: UserDefaultKeys.AccountInfo.userName)\n```\n\n#### 枚举分组存储\n上面的方法虽然能基本满足要求, 但是仍然不完美, 我们依然需要手动去设置 key, 当 key 值很多的时候, 需要一个个的设置, 那有没有可以一劳永逸的办法呢? 不需要我们自己设置 key 的值, 让系统默认给我们设置好 key 的初始值, 我们直接拿 key 去进行存取数据. Swift这么好的语言当然可以实现, 即用枚举的方式, 枚举不仅可以分组设置 key, 还能默认设置 key 的原始值. 前提是我们需要遵守 String 协议, 不设置 rawValue 的时候, 系统会默认给我们的枚举 case 设置跟成员名字相同的原始值(rawValue), 我们就可以拿这个 rawValue 来作为存取数据的 key.\n\n```Swift\nstruct UserDefaultKeys {\n    // 账户信息\n    enum AccountInfo: String {\n        case userName\n        case age\n    }\n}\n\n// 存账户信息\ndefaultStand.set(\"Chilli Cheng\", forKey: UserDefaultKeys.AccountInfo.userName.rawValue)\ndefaultStand.set(18, forKey: UserDefaultKeys.AccountInfo.age.rawValue)\n\n// 取存账户信息\ndefaultStand.string(forKey: UserDefaultKeys.AccountInfo.userName.rawValue)\ndefaultStand.integer(forKey: UserDefaultKeys.AccountInfo.age.rawValue)\n```\n吼吼, 是不是感觉很方便, Swift 太棒了!\n上面基本就能达到我们的目的, 既解决了一致性问题, 又有上下文知道我存取数据使用的 key 的含义. 但是代码看起来很冗余, 我不就需要一个key 嘛, 干嘛非要链式调用那么多层呢? 还有就是为啥我非要写 rawValue 呢? 如果新来的小伙伴不知道 rawValue 是什么鬼肯定懵逼. \n\n#### 优化 key 值路径\n虽然上面的代码能很好的达到目的, 但是写法和使用上还是欠妥, 我们仍需要继续改进, 上面的代码主要存在两个问题:\n* key 值路径太长\n* rawValue 没必要写\n\n我们先分析一下为什么会出现这个两个问题: \nkey值的路径长是因为我们想分组存储 key, 让key具有上下文, 可读性更改,\nrawValue 的作用是因为我们使用枚举来存储 key, 就不需要去手动设置 key 的初始值. \n\n看起来简直是\"鱼和熊掌不能兼得\", 有什么办法能解决\"鱼和熊掌\"的问题呢?  \n那就是\"砍掉抓着鱼的熊掌\". 也就是说我们必须先解决一个问题(先让熊抓鱼), 再想法\"砍熊掌\".\n\n有了上面的一系列步骤, 解决第一个问题并不像刚开始一样使用简单的字符串, 而必须是使用枚举, 在这个前提下去\"抓鱼\". 也就是我能不能直接传枚举成员值进去, 先利用枚举的 rawValue 解决第一个问题,例如这样使用:\n\n```Swift\ndefaultStand.set(\"Chilli Cheng\", forKey: .userName)\ndefaultStand.string(forKey: .userName)\n```\n很明显能够实现, 只要给 userDefaults 扩展自定义方法即可, 在自定义方法中调用系统的方法进行存取, 为了使用方便我们扩展类方法.示例:\n\n```Swift\nextension UserDefaults {\n    enum AccountKeys: String {\n        case userName\n        case age\n    }\n    \n    static func set(value: String, forKey key: AccountKeys) {\n        let key = key.rawValue\n        UserDefaults.standard.set(value, forKey: key)\n    }\n\n    static func string(forKey key: AccountKeys) -> String? {\n        let key = key.rawValue\n        return UserDefaults.standard.string(forKey: key)\n    }\n}\n\n// 存取数据\nUserDefaults.set(value: \"chilli cheng\", forKey: .userName)\nUserDefaults.string(forKey: .userName)\n```\n\n#### 前置上下文\n 能实现上面的目的之一, 但是没有上下文, 既然在 key 那里不能加, 换一个思路, 那就在前面加, 例如:\n \n```Swift\nUserDefaults.AccountInfo.set(value: \"chilli cheng\", forKey: .userName)\nUserDefaults.AccountInfo.string(forKey: .userName)\n```\n\n要实现上面的实现方式, 需要扩展 UserDefaults, 添加 AccountInfo 属性, 再调用 AccountInfo 的方法, key值由 AccountInfo 来提供, 因为AccountInfo 提供分组的 key, 由于是自定义的一个分组信息, 需要实现既定方法, 必然想到用协议呀, 毕竟 Swift 的协议很强大, Swift 就是面向协议编程的.  \n那我们先把自定义的方法抽取到协议中, 额, 但是协议不是只能提供方法声明, 不提供方法实现吗? 谁说的? 站出来我保证不打死他! Swift 中可以对协议 protocol 进行扩展, 提供协议方法的默认实现, 如果遵守协议的类/结构体/枚举实现了该方法, 就会覆盖掉默认的方法.\n我们来试着实现一下, 先写一个协议, 提供默认的方法实现:\n\n```Swift\nprotocol UserDefaultsSettable {\n    \n}\n\nextension UserDefaultsSettable {\n    static func set(value: String, forKey key: AccountKeys) {\n        let key = key.rawValue\n        UserDefaults.standard.set(value, forKey: key)\n    }\n    static func string(forKey key: AccountKeys) -> String? {\n        let key = key.rawValue\n        return UserDefaults.standard.string(forKey: key)\n    }\n}\n```\n只要我的 AccountInfo 类/结构体/枚举遵守这个协议, 就能调用存取方法了, 但是, 现在问题来了, 也是至关重要的问题, AccountKeys 从哪儿来? 我们上面是把 AccountKeys 写在UserDefaults扩展里面的, 在协议里面如何知道这个变量是什么类型呢? 而且还使用到了 rawValue, 为了通用性, 那就需要在协议里[关联类型](http://wiki.jikexueyuan.com/project/swift/chapter2/23_Generics.html#associated_types), 而且传入的值能拿到 rawValue, 那么这个关联类型需要遵守 RawRepresentable 协议, 这个很关键!!!\n\n```Swift\nprotocol UserDefaultsSettable {\n    associatedtype defaultKeys: RawRepresentable\n}\n\nextension UserDefaultsSettable where defaultKeys.RawValue==String {\n    static func set(value: String?, forKey key: defaultKeys) {\n        let aKey = key.rawValue\n        UserDefaults.standard.set(value, forKey: aKey)\n    }\n    static func string(forKey key: defaultKeys) -> String? {\n        let aKey = key.rawValue\n        return UserDefaults.standard.string(forKey: aKey)\n    }\n}\n```\n\n>必须在扩展中使用 where 子语句限制关联类型是字符串类型, 因为 UserDefaults 的 key 就是字符串类型.\nwhere defaultKeys.RawValue==String\n\n\n在 UserDefaults 的扩展中定义分组 key: \n\n```Swift\nextension UserDefaults {\n    // 账户信息\n    struct AccountInfo: UserDefaultsSettable {\n        enum defaultKeys: String {\n            case userName\n            case age\n        }\n    }\n    \n    // 登录信息\n    struct LoginInfo: UserDefaultsSettable {\n        enum defaultKeys: String {\n            case token\n            case userId\n        }\n    }\n}\n```\n\n存取数据:\n\n```Swift\nUserDefaults.AccountInfo.set(value: \"chilli cheng\", forKey: .userName)\nUserDefaults.AccountInfo.string(forKey: .userName)\n        \nUserDefaults.LoginInfo.set(value: \"ahdsjhad\", forKey: .token)\nUserDefaults.LoginInfo.string(forKey: .token)\n```\n\n打完收工, 既没有手动去写 key, 避免了写错的问题, 实现了key的一致性, 又实现了上下文, 能够直接明白 key 的含义.\n如果还有需要存储的分类数据, 同样在 UserDefaults extension 中添加一个结构体, 遵守 UserDefaultsSettable 协议, 实现 defaultKeys 枚举属性, 在枚举中设置该分类存储数据所需要的 key.\n\n> 注意: UserDefaultsSettable 协议中只实现了存取 string 类型的数据, 可以自行在 UserDefaultsSettable 协议中添加 Int, Bool等类型方法. 虽然这种用法前期比较费劲, 但是不失为一种管理 UserDefaults 的比较好的方式.  \n> 如果大家有更好的方式, 欢迎交流.\n\n欢迎大家斧正!\n\n\n\n","slug":"Swift中安全优雅的使用UserDefaults","published":1,"updated":"2017-02-27T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizozpebd0006k4exfx362u3s","content":"<p>纳尼? 如此简单的 UserDefaults 怎么去优雅的使用? 这么简单的还能玩出花来? 没毛病吧?</p>\n<p>Objective-C 中的 NSUserDefaults 我们并不陌生, 通常作为数据持久化的一种方式, 一般用来存储用户信息和基础配置信息. Swift 中使用 UserDefaults 来替代 NSUserDefaults, 两者的使用基本相同.</p>\n<a id=\"more\"></a>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaults = <span class=\"type\">UserDefaults</span>.standard</div><div class=\"line\">defaults.<span class=\"keyword\">set</span>(<span class=\"number\">123</span>, forKey: <span class=\"string\">\"defaultKey\"</span>)</div><div class=\"line\">defaults.integer(forKey: <span class=\"string\">\"defaultKey\"</span>)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Objective-C中需要调用 synchronize 方法进行同步, 但是在Swift中已经废弃了该方法, 所以不需要手动去调用.<br>-synchronize is deprecated and will be marked with the NS_DEPRECATED macro in a future release.</p>\n</blockquote>\n<p>上面的用法是最基本的用法, 也是我们平常开发中使用频率最高的用法, 但也是最危险的用法, 为什么呢?  </p>\n<ol>\n<li>在应用内部我们可以随意地覆盖和删除存储的值, 直接使用字符串来作为存储数据的 key 是非常危险的, 容易导致存数据时使用的 key 和取数据的时候使用的 key 不一致.</li>\n<li>UserDefaults.standard 是一个全局的单例, 如果需要存储账户信息(AccountInfo), 配置信息(SettingInfo), 此时按照最基本的使用方式, 简单的使用 key 来存取数据, 那么 key 值会随着存储的数据越来越多, 到时候不管是新接手的小伙伴还是我们自己都很难明白每个 key 值对应的意义. 也就是说我们不能根据方法调用的上下文明确知道我存取数据的具体含义, 代码的可读性和可维护性就不高.所以我们要利用 Swift 强大的灵活性来让我们使用 UserDefaults 存取数据的时候更加便捷和安全. </li>\n</ol>\n<p>所以要想把 UserDefaults 玩出花来就得解决下面两个问题:</p>\n<ul>\n<li><code>一致性</code></li>\n<li><code>上下文</code></li>\n</ul>\n<h3 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h3><p>使用 UserDefaults 存取数据时使用的 key 值不同就会导致存在一致性问题. 原因就在于通常我们在存取数据的时候, 手动键入 key 或者复制粘贴 key 可能会出错, 输入的时候也很麻烦. 那我们的目的就比较明确了, 就是为了让存取的 key 一致, 即使改了其中一个另外一个也随之更改. </p>\n<p>解决办法: </p>\n<ul>\n<li>常量保存</li>\n<li>分组存储</li>\n</ul>\n<h4 id=\"常量保存字符串\"><a href=\"#常量保存字符串\" class=\"headerlink\" title=\"常量保存字符串\"></a>常量保存字符串</h4><p>既然涉及到两个重复使用的字符串, 很容易就想到用常量保存字符串, 只有在初始化的时候设置 key 值, 存取的时候拿来用即可, 简单粗暴的方式.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaultStand = <span class=\"type\">UserDefaults</span>.standard</div><div class=\"line\"><span class=\"keyword\">let</span> defaultKey = <span class=\"string\">\"defaultKey\"</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">123</span>, forKey: defaultKey)</div><div class=\"line\">defaultStand.integer(forKey: defaultKey)</div></pre></td></tr></table></figure>\n<p>是不是感觉有点换汤不换药? 上面使用常量存储 key 值, 虽然能够保证存取的时候 key 值相同, 但是在设置 key 值的时候稍显麻烦.<br>最重要的一点就是如果需要存很多账户信息或者配置信息的时候, 按照这种方式都写在同一处地方就稍微欠妥, 比如下面这个场景, 在 app 启动后, 需要存储用户信息和登录信息, 用户信息里面包含: userName, avatar, password, gender等, 登录信息里包含: token, userId, timeStamp等等, 也就说需要存两类不同的信息, 那么此时这种方式就不合时宜了, 我们就会想办法把同类的信息归为一组, 进行分组存取.</p>\n<h4 id=\"分组存储\"><a href=\"#分组存储\" class=\"headerlink\" title=\"分组存储\"></a>分组存储</h4><p>分组存储 key 可以把存储数据按不同类别区分开, 代码的可读性和可维护性大大提升. 我们可以采用类class, 结构体struct, 枚举enum来进行分组存储 key, 下面使用结构体来示例.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 账户信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> userName = <span class=\"string\">\"userName\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> avatar = <span class=\"string\">\"avatar\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"string\">\"password\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> gender = <span class=\"string\">\"gender\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> age = <span class=\"string\">\"age\"</span></div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 登录信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LoginInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> token = <span class=\"string\">\"token\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> userId = <span class=\"string\">\"userId\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 配置信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SettingInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"string\">\"font\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> backgroundImage = <span class=\"string\">\"backgroundImage\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取数据:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaultStand = <span class=\"type\">UserDefaults</span>.standard</div><div class=\"line\"><span class=\"comment\">// 账户信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: <span class=\"type\">AccountInfo</span>().avatar)</div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">18</span>, forKey: <span class=\"type\">AccountInfo</span>().age)</div><div class=\"line\"><span class=\"comment\">// 登录信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"achj167\"</span>, forKey: <span class=\"type\">LoginInfo</span>().token)</div><div class=\"line\"><span class=\"comment\">// 配置信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">24</span>, forKey: <span class=\"type\">SettingInfo</span>().font)</div><div class=\"line\">        </div><div class=\"line\"><span class=\"keyword\">let</span> userName = defaultStand.string(forKey: <span class=\"type\">AccountInfo</span>().avatar)</div><div class=\"line\"><span class=\"keyword\">let</span> age = defaultStand.integer(forKey: <span class=\"type\">AccountInfo</span>().age)</div><div class=\"line\"><span class=\"keyword\">let</span> token = defaultStand.string(forKey: <span class=\"type\">LoginInfo</span>().token)</div><div class=\"line\"><span class=\"keyword\">let</span> font = defaultStand.integer(forKey: <span class=\"type\">SettingInfo</span>().font)</div></pre></td></tr></table></figure>\n<h3 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h3><p>上面这种方式是不是比直接使用常量的效果更好? 但是仍然有个问题, 账户信息, 登录信息, 配置信息都是属于要存储的信息, 那我们就可以把这三类信息归到一个大类里, 在这个大类中有这三个小类, 三个小类作为大类的属性, 既能解决一致性问题, 又能解决上下文的问题, 需要存储到 UserDefaults 里面的数据, 我只需要去特定的类中找到对应分组里面的属性即可. 示例:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefaultKeys</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 账户信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> userName = <span class=\"string\">\"userName\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> avatar = <span class=\"string\">\"avatar\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> password = <span class=\"string\">\"password\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> gender = <span class=\"string\">\"gender\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> age = <span class=\"string\">\"age\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 登录信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LoginInfo</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> token = <span class=\"string\">\"token\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> userId = <span class=\"string\">\"userId\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 配置信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SettingInfo</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> font = <span class=\"string\">\"font\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> backgroundImage = <span class=\"string\">\"backgroundImage\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let defaultStand = UserDefaults.standard</div><div class=\"line\">// 账户信息</div><div class=\"line\">defaultStand.set(&quot;Chilli Cheng&quot;, forKey:UserDefaultKeys.AccountInfo().userName)</div><div class=\"line\">defaultStand.string(forKey: UserDefaultKeys.AccountInfo().userName)</div></pre></td></tr></table></figure>\n<p>上面的代码看起来可读性好了很多, 不仅是为了新接手的小伙伴能看懂, 更是为了我们自己过段时间能看懂. 我亲眼见过自己写的代码看不懂反而要进行重构的小伙伴. </p>\n<h4 id=\"避免初始化\"><a href=\"#避免初始化\" class=\"headerlink\" title=\"避免初始化\"></a>避免初始化</h4><p>但是上面的代码存在一个明显的缺陷, 每次存取值的时候需要初始化 struct 出一个实例, 再访问这个实例的属性获取 key 值, 其实是不必要的, 怎么才能做到不初始化实例就能访问属性呢? 可以使用静态变量, 直接通过类型名字访问属性的值.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> userName = <span class=\"string\">\"userName\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> avatar = <span class=\"string\">\"avatar\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> password = <span class=\"string\">\"password\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> gender = <span class=\"string\">\"gender\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> age = <span class=\"string\">\"age\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取的时候:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName)</div><div class=\"line\">defaultStand.string(forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName)</div></pre></td></tr></table></figure>\n<h4 id=\"枚举分组存储\"><a href=\"#枚举分组存储\" class=\"headerlink\" title=\"枚举分组存储\"></a>枚举分组存储</h4><p>上面的方法虽然能基本满足要求, 但是仍然不完美, 我们依然需要手动去设置 key, 当 key 值很多的时候, 需要一个个的设置, 那有没有可以一劳永逸的办法呢? 不需要我们自己设置 key 的值, 让系统默认给我们设置好 key 的初始值, 我们直接拿 key 去进行存取数据. Swift这么好的语言当然可以实现, 即用枚举的方式, 枚举不仅可以分组设置 key, 还能默认设置 key 的原始值. 前提是我们需要遵守 String 协议, 不设置 rawValue 的时候, 系统会默认给我们的枚举 case 设置跟成员名字相同的原始值(rawValue), 我们就可以拿这个 rawValue 来作为存取数据的 key.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefaultKeys</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 账户信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">AccountInfo</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> userName</div><div class=\"line\">        <span class=\"keyword\">case</span> age</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存账户信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName.rawValue)</div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">18</span>, forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.age.rawValue)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 取存账户信息</span></div><div class=\"line\">defaultStand.string(forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName.rawValue)</div><div class=\"line\">defaultStand.integer(forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.age.rawValue)</div></pre></td></tr></table></figure>\n<p>吼吼, 是不是感觉很方便, Swift 太棒了!<br>上面基本就能达到我们的目的, 既解决了一致性问题, 又有上下文知道我存取数据使用的 key 的含义. 但是代码看起来很冗余, 我不就需要一个key 嘛, 干嘛非要链式调用那么多层呢? 还有就是为啥我非要写 rawValue 呢? 如果新来的小伙伴不知道 rawValue 是什么鬼肯定懵逼. </p>\n<h4 id=\"优化-key-值路径\"><a href=\"#优化-key-值路径\" class=\"headerlink\" title=\"优化 key 值路径\"></a>优化 key 值路径</h4><p>虽然上面的代码能很好的达到目的, 但是写法和使用上还是欠妥, 我们仍需要继续改进, 上面的代码主要存在两个问题:</p>\n<ul>\n<li>key 值路径太长</li>\n<li>rawValue 没必要写</li>\n</ul>\n<p>我们先分析一下为什么会出现这个两个问题:<br>key值的路径长是因为我们想分组存储 key, 让key具有上下文, 可读性更改,<br>rawValue 的作用是因为我们使用枚举来存储 key, 就不需要去手动设置 key 的初始值. </p>\n<p>看起来简直是”鱼和熊掌不能兼得”, 有什么办法能解决”鱼和熊掌”的问题呢?<br>那就是”砍掉抓着鱼的熊掌”. 也就是说我们必须先解决一个问题(先让熊抓鱼), 再想法”砍熊掌”.</p>\n<p>有了上面的一系列步骤, 解决第一个问题并不像刚开始一样使用简单的字符串, 而必须是使用枚举, 在这个前提下去”抓鱼”. 也就是我能不能直接传枚举成员值进去, 先利用枚举的 rawValue 解决第一个问题,例如这样使用:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: .userName)</div><div class=\"line\">defaultStand.string(forKey: .userName)</div></pre></td></tr></table></figure>\n<p>很明显能够实现, 只要给 userDefaults 扩展自定义方法即可, 在自定义方法中调用系统的方法进行存取, 为了使用方便我们扩展类方法.示例:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaults</span> </span>&#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">AccountKeys</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> userName</div><div class=\"line\">        <span class=\"keyword\">case</span> age</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(value: String, forKey key: AccountKeys)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"type\">UserDefaults</span>.standard.<span class=\"keyword\">set</span>(value, forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">string</span><span class=\"params\">(forKey key: AccountKeys)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.string(forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存取数据</span></div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"chilli cheng\"</span>, forKey: .userName)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.string(forKey: .userName)</div></pre></td></tr></table></figure>\n<h4 id=\"前置上下文\"><a href=\"#前置上下文\" class=\"headerlink\" title=\"前置上下文\"></a>前置上下文</h4><p> 能实现上面的目的之一, 但是没有上下文, 既然在 key 那里不能加, 换一个思路, 那就在前面加, 例如:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"chilli cheng\"</span>, forKey: .userName)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.string(forKey: .userName)</div></pre></td></tr></table></figure>\n<p>要实现上面的实现方式, 需要扩展 UserDefaults, 添加 AccountInfo 属性, 再调用 AccountInfo 的方法, key值由 AccountInfo 来提供, 因为AccountInfo 提供分组的 key, 由于是自定义的一个分组信息, 需要实现既定方法, 必然想到用协议呀, 毕竟 Swift 的协议很强大, Swift 就是面向协议编程的.<br>那我们先把自定义的方法抽取到协议中, 额, 但是协议不是只能提供方法声明, 不提供方法实现吗? 谁说的? 站出来我保证不打死他! Swift 中可以对协议 protocol 进行扩展, 提供协议方法的默认实现, 如果遵守协议的类/结构体/枚举实现了该方法, 就会覆盖掉默认的方法.<br>我们来试着实现一下, 先写一个协议, 提供默认的方法实现:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(value: String, forKey key: AccountKeys)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"type\">UserDefaults</span>.standard.<span class=\"keyword\">set</span>(value, forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">string</span><span class=\"params\">(forKey key: AccountKeys)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.string(forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只要我的 AccountInfo 类/结构体/枚举遵守这个协议, 就能调用存取方法了, 但是, 现在问题来了, 也是至关重要的问题, AccountKeys 从哪儿来? 我们上面是把 AccountKeys 写在UserDefaults扩展里面的, 在协议里面如何知道这个变量是什么类型呢? 而且还使用到了 rawValue, 为了通用性, 那就需要在协议里<a href=\"http://wiki.jikexueyuan.com/project/swift/chapter2/23_Generics.html#associated_types\" target=\"_blank\" rel=\"external\">关联类型</a>, 而且传入的值能拿到 rawValue, 那么这个关联类型需要遵守 RawRepresentable 协议, 这个很关键!!!</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">    associatedtype defaultKeys: <span class=\"type\">RawRepresentable</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaultsSettable</span> <span class=\"title\">where</span> <span class=\"title\">defaultKeys</span>.<span class=\"title\">RawValue</span>==<span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(value: String?, forKey key: defaultKeys)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> aKey = key.rawValue</div><div class=\"line\">        <span class=\"type\">UserDefaults</span>.standard.<span class=\"keyword\">set</span>(value, forKey: aKey)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">string</span><span class=\"params\">(forKey key: defaultKeys)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> aKey = key.rawValue</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.string(forKey: aKey)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>必须在扩展中使用 where 子语句限制关联类型是字符串类型, 因为 UserDefaults 的 key 就是字符串类型.<br>where defaultKeys.RawValue==String</p>\n</blockquote>\n<p>在 UserDefaults 的扩展中定义分组 key: </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaults</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 账户信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span>: <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">defaultKeys</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> userName</div><div class=\"line\">            <span class=\"keyword\">case</span> age</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 登录信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LoginInfo</span>: <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">defaultKeys</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> token</div><div class=\"line\">            <span class=\"keyword\">case</span> userId</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取数据:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"chilli cheng\"</span>, forKey: .userName)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.string(forKey: .userName)</div><div class=\"line\">        </div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">LoginInfo</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"ahdsjhad\"</span>, forKey: .token)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">LoginInfo</span>.string(forKey: .token)</div></pre></td></tr></table></figure>\n<p>打完收工, 既没有手动去写 key, 避免了写错的问题, 实现了key的一致性, 又实现了上下文, 能够直接明白 key 的含义.<br>如果还有需要存储的分类数据, 同样在 UserDefaults extension 中添加一个结构体, 遵守 UserDefaultsSettable 协议, 实现 defaultKeys 枚举属性, 在枚举中设置该分类存储数据所需要的 key.</p>\n<blockquote>\n<p>注意: UserDefaultsSettable 协议中只实现了存取 string 类型的数据, 可以自行在 UserDefaultsSettable 协议中添加 Int, Bool等类型方法. 虽然这种用法前期比较费劲, 但是不失为一种管理 UserDefaults 的比较好的方式.<br>如果大家有更好的方式, 欢迎交流.</p>\n</blockquote>\n<p>欢迎大家斧正!</p>\n","excerpt":"<p>纳尼? 如此简单的 UserDefaults 怎么去优雅的使用? 这么简单的还能玩出花来? 没毛病吧?</p>\n<p>Objective-C 中的 NSUserDefaults 我们并不陌生, 通常作为数据持久化的一种方式, 一般用来存储用户信息和基础配置信息. Swift 中使用 UserDefaults 来替代 NSUserDefaults, 两者的使用基本相同.</p>","more":"<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaults = <span class=\"type\">UserDefaults</span>.standard</div><div class=\"line\">defaults.<span class=\"keyword\">set</span>(<span class=\"number\">123</span>, forKey: <span class=\"string\">\"defaultKey\"</span>)</div><div class=\"line\">defaults.integer(forKey: <span class=\"string\">\"defaultKey\"</span>)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Objective-C中需要调用 synchronize 方法进行同步, 但是在Swift中已经废弃了该方法, 所以不需要手动去调用.<br>-synchronize is deprecated and will be marked with the NS_DEPRECATED macro in a future release.</p>\n</blockquote>\n<p>上面的用法是最基本的用法, 也是我们平常开发中使用频率最高的用法, 但也是最危险的用法, 为什么呢?  </p>\n<ol>\n<li>在应用内部我们可以随意地覆盖和删除存储的值, 直接使用字符串来作为存储数据的 key 是非常危险的, 容易导致存数据时使用的 key 和取数据的时候使用的 key 不一致.</li>\n<li>UserDefaults.standard 是一个全局的单例, 如果需要存储账户信息(AccountInfo), 配置信息(SettingInfo), 此时按照最基本的使用方式, 简单的使用 key 来存取数据, 那么 key 值会随着存储的数据越来越多, 到时候不管是新接手的小伙伴还是我们自己都很难明白每个 key 值对应的意义. 也就是说我们不能根据方法调用的上下文明确知道我存取数据的具体含义, 代码的可读性和可维护性就不高.所以我们要利用 Swift 强大的灵活性来让我们使用 UserDefaults 存取数据的时候更加便捷和安全. </li>\n</ol>\n<p>所以要想把 UserDefaults 玩出花来就得解决下面两个问题:</p>\n<ul>\n<li><code>一致性</code></li>\n<li><code>上下文</code></li>\n</ul>\n<h3 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h3><p>使用 UserDefaults 存取数据时使用的 key 值不同就会导致存在一致性问题. 原因就在于通常我们在存取数据的时候, 手动键入 key 或者复制粘贴 key 可能会出错, 输入的时候也很麻烦. 那我们的目的就比较明确了, 就是为了让存取的 key 一致, 即使改了其中一个另外一个也随之更改. </p>\n<p>解决办法: </p>\n<ul>\n<li>常量保存</li>\n<li>分组存储</li>\n</ul>\n<h4 id=\"常量保存字符串\"><a href=\"#常量保存字符串\" class=\"headerlink\" title=\"常量保存字符串\"></a>常量保存字符串</h4><p>既然涉及到两个重复使用的字符串, 很容易就想到用常量保存字符串, 只有在初始化的时候设置 key 值, 存取的时候拿来用即可, 简单粗暴的方式.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaultStand = <span class=\"type\">UserDefaults</span>.standard</div><div class=\"line\"><span class=\"keyword\">let</span> defaultKey = <span class=\"string\">\"defaultKey\"</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">123</span>, forKey: defaultKey)</div><div class=\"line\">defaultStand.integer(forKey: defaultKey)</div></pre></td></tr></table></figure>\n<p>是不是感觉有点换汤不换药? 上面使用常量存储 key 值, 虽然能够保证存取的时候 key 值相同, 但是在设置 key 值的时候稍显麻烦.<br>最重要的一点就是如果需要存很多账户信息或者配置信息的时候, 按照这种方式都写在同一处地方就稍微欠妥, 比如下面这个场景, 在 app 启动后, 需要存储用户信息和登录信息, 用户信息里面包含: userName, avatar, password, gender等, 登录信息里包含: token, userId, timeStamp等等, 也就说需要存两类不同的信息, 那么此时这种方式就不合时宜了, 我们就会想办法把同类的信息归为一组, 进行分组存取.</p>\n<h4 id=\"分组存储\"><a href=\"#分组存储\" class=\"headerlink\" title=\"分组存储\"></a>分组存储</h4><p>分组存储 key 可以把存储数据按不同类别区分开, 代码的可读性和可维护性大大提升. 我们可以采用类class, 结构体struct, 枚举enum来进行分组存储 key, 下面使用结构体来示例.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 账户信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> userName = <span class=\"string\">\"userName\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> avatar = <span class=\"string\">\"avatar\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"string\">\"password\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> gender = <span class=\"string\">\"gender\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> age = <span class=\"string\">\"age\"</span></div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 登录信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LoginInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> token = <span class=\"string\">\"token\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> userId = <span class=\"string\">\"userId\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 配置信息</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SettingInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"string\">\"font\"</span></div><div class=\"line\">    <span class=\"keyword\">let</span> backgroundImage = <span class=\"string\">\"backgroundImage\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取数据:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaultStand = <span class=\"type\">UserDefaults</span>.standard</div><div class=\"line\"><span class=\"comment\">// 账户信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: <span class=\"type\">AccountInfo</span>().avatar)</div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">18</span>, forKey: <span class=\"type\">AccountInfo</span>().age)</div><div class=\"line\"><span class=\"comment\">// 登录信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"achj167\"</span>, forKey: <span class=\"type\">LoginInfo</span>().token)</div><div class=\"line\"><span class=\"comment\">// 配置信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">24</span>, forKey: <span class=\"type\">SettingInfo</span>().font)</div><div class=\"line\">        </div><div class=\"line\"><span class=\"keyword\">let</span> userName = defaultStand.string(forKey: <span class=\"type\">AccountInfo</span>().avatar)</div><div class=\"line\"><span class=\"keyword\">let</span> age = defaultStand.integer(forKey: <span class=\"type\">AccountInfo</span>().age)</div><div class=\"line\"><span class=\"keyword\">let</span> token = defaultStand.string(forKey: <span class=\"type\">LoginInfo</span>().token)</div><div class=\"line\"><span class=\"keyword\">let</span> font = defaultStand.integer(forKey: <span class=\"type\">SettingInfo</span>().font)</div></pre></td></tr></table></figure>\n<h3 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h3><p>上面这种方式是不是比直接使用常量的效果更好? 但是仍然有个问题, 账户信息, 登录信息, 配置信息都是属于要存储的信息, 那我们就可以把这三类信息归到一个大类里, 在这个大类中有这三个小类, 三个小类作为大类的属性, 既能解决一致性问题, 又能解决上下文的问题, 需要存储到 UserDefaults 里面的数据, 我只需要去特定的类中找到对应分组里面的属性即可. 示例:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefaultKeys</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 账户信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> userName = <span class=\"string\">\"userName\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> avatar = <span class=\"string\">\"avatar\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> password = <span class=\"string\">\"password\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> gender = <span class=\"string\">\"gender\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> age = <span class=\"string\">\"age\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 登录信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LoginInfo</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> token = <span class=\"string\">\"token\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> userId = <span class=\"string\">\"userId\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 配置信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SettingInfo</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> font = <span class=\"string\">\"font\"</span></div><div class=\"line\">        <span class=\"keyword\">let</span> backgroundImage = <span class=\"string\">\"backgroundImage\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let defaultStand = UserDefaults.standard</div><div class=\"line\">// 账户信息</div><div class=\"line\">defaultStand.set(&quot;Chilli Cheng&quot;, forKey:UserDefaultKeys.AccountInfo().userName)</div><div class=\"line\">defaultStand.string(forKey: UserDefaultKeys.AccountInfo().userName)</div></pre></td></tr></table></figure>\n<p>上面的代码看起来可读性好了很多, 不仅是为了新接手的小伙伴能看懂, 更是为了我们自己过段时间能看懂. 我亲眼见过自己写的代码看不懂反而要进行重构的小伙伴. </p>\n<h4 id=\"避免初始化\"><a href=\"#避免初始化\" class=\"headerlink\" title=\"避免初始化\"></a>避免初始化</h4><p>但是上面的代码存在一个明显的缺陷, 每次存取值的时候需要初始化 struct 出一个实例, 再访问这个实例的属性获取 key 值, 其实是不必要的, 怎么才能做到不初始化实例就能访问属性呢? 可以使用静态变量, 直接通过类型名字访问属性的值.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> userName = <span class=\"string\">\"userName\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> avatar = <span class=\"string\">\"avatar\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> password = <span class=\"string\">\"password\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> gender = <span class=\"string\">\"gender\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> age = <span class=\"string\">\"age\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取的时候:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName)</div><div class=\"line\">defaultStand.string(forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName)</div></pre></td></tr></table></figure>\n<h4 id=\"枚举分组存储\"><a href=\"#枚举分组存储\" class=\"headerlink\" title=\"枚举分组存储\"></a>枚举分组存储</h4><p>上面的方法虽然能基本满足要求, 但是仍然不完美, 我们依然需要手动去设置 key, 当 key 值很多的时候, 需要一个个的设置, 那有没有可以一劳永逸的办法呢? 不需要我们自己设置 key 的值, 让系统默认给我们设置好 key 的初始值, 我们直接拿 key 去进行存取数据. Swift这么好的语言当然可以实现, 即用枚举的方式, 枚举不仅可以分组设置 key, 还能默认设置 key 的原始值. 前提是我们需要遵守 String 协议, 不设置 rawValue 的时候, 系统会默认给我们的枚举 case 设置跟成员名字相同的原始值(rawValue), 我们就可以拿这个 rawValue 来作为存取数据的 key.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefaultKeys</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 账户信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">AccountInfo</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> userName</div><div class=\"line\">        <span class=\"keyword\">case</span> age</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存账户信息</span></div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName.rawValue)</div><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"number\">18</span>, forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.age.rawValue)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 取存账户信息</span></div><div class=\"line\">defaultStand.string(forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.userName.rawValue)</div><div class=\"line\">defaultStand.integer(forKey: <span class=\"type\">UserDefaultKeys</span>.<span class=\"type\">AccountInfo</span>.age.rawValue)</div></pre></td></tr></table></figure>\n<p>吼吼, 是不是感觉很方便, Swift 太棒了!<br>上面基本就能达到我们的目的, 既解决了一致性问题, 又有上下文知道我存取数据使用的 key 的含义. 但是代码看起来很冗余, 我不就需要一个key 嘛, 干嘛非要链式调用那么多层呢? 还有就是为啥我非要写 rawValue 呢? 如果新来的小伙伴不知道 rawValue 是什么鬼肯定懵逼. </p>\n<h4 id=\"优化-key-值路径\"><a href=\"#优化-key-值路径\" class=\"headerlink\" title=\"优化 key 值路径\"></a>优化 key 值路径</h4><p>虽然上面的代码能很好的达到目的, 但是写法和使用上还是欠妥, 我们仍需要继续改进, 上面的代码主要存在两个问题:</p>\n<ul>\n<li>key 值路径太长</li>\n<li>rawValue 没必要写</li>\n</ul>\n<p>我们先分析一下为什么会出现这个两个问题:<br>key值的路径长是因为我们想分组存储 key, 让key具有上下文, 可读性更改,<br>rawValue 的作用是因为我们使用枚举来存储 key, 就不需要去手动设置 key 的初始值. </p>\n<p>看起来简直是”鱼和熊掌不能兼得”, 有什么办法能解决”鱼和熊掌”的问题呢?<br>那就是”砍掉抓着鱼的熊掌”. 也就是说我们必须先解决一个问题(先让熊抓鱼), 再想法”砍熊掌”.</p>\n<p>有了上面的一系列步骤, 解决第一个问题并不像刚开始一样使用简单的字符串, 而必须是使用枚举, 在这个前提下去”抓鱼”. 也就是我能不能直接传枚举成员值进去, 先利用枚举的 rawValue 解决第一个问题,例如这样使用:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultStand.<span class=\"keyword\">set</span>(<span class=\"string\">\"Chilli Cheng\"</span>, forKey: .userName)</div><div class=\"line\">defaultStand.string(forKey: .userName)</div></pre></td></tr></table></figure>\n<p>很明显能够实现, 只要给 userDefaults 扩展自定义方法即可, 在自定义方法中调用系统的方法进行存取, 为了使用方便我们扩展类方法.示例:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaults</span> </span>&#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">AccountKeys</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> userName</div><div class=\"line\">        <span class=\"keyword\">case</span> age</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(value: String, forKey key: AccountKeys)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"type\">UserDefaults</span>.standard.<span class=\"keyword\">set</span>(value, forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">string</span><span class=\"params\">(forKey key: AccountKeys)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.string(forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存取数据</span></div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"chilli cheng\"</span>, forKey: .userName)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.string(forKey: .userName)</div></pre></td></tr></table></figure>\n<h4 id=\"前置上下文\"><a href=\"#前置上下文\" class=\"headerlink\" title=\"前置上下文\"></a>前置上下文</h4><p> 能实现上面的目的之一, 但是没有上下文, 既然在 key 那里不能加, 换一个思路, 那就在前面加, 例如:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"chilli cheng\"</span>, forKey: .userName)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.string(forKey: .userName)</div></pre></td></tr></table></figure>\n<p>要实现上面的实现方式, 需要扩展 UserDefaults, 添加 AccountInfo 属性, 再调用 AccountInfo 的方法, key值由 AccountInfo 来提供, 因为AccountInfo 提供分组的 key, 由于是自定义的一个分组信息, 需要实现既定方法, 必然想到用协议呀, 毕竟 Swift 的协议很强大, Swift 就是面向协议编程的.<br>那我们先把自定义的方法抽取到协议中, 额, 但是协议不是只能提供方法声明, 不提供方法实现吗? 谁说的? 站出来我保证不打死他! Swift 中可以对协议 protocol 进行扩展, 提供协议方法的默认实现, 如果遵守协议的类/结构体/枚举实现了该方法, 就会覆盖掉默认的方法.<br>我们来试着实现一下, 先写一个协议, 提供默认的方法实现:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(value: String, forKey key: AccountKeys)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"type\">UserDefaults</span>.standard.<span class=\"keyword\">set</span>(value, forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">string</span><span class=\"params\">(forKey key: AccountKeys)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = key.rawValue</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.string(forKey: key)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只要我的 AccountInfo 类/结构体/枚举遵守这个协议, 就能调用存取方法了, 但是, 现在问题来了, 也是至关重要的问题, AccountKeys 从哪儿来? 我们上面是把 AccountKeys 写在UserDefaults扩展里面的, 在协议里面如何知道这个变量是什么类型呢? 而且还使用到了 rawValue, 为了通用性, 那就需要在协议里<a href=\"http://wiki.jikexueyuan.com/project/swift/chapter2/23_Generics.html#associated_types\">关联类型</a>, 而且传入的值能拿到 rawValue, 那么这个关联类型需要遵守 RawRepresentable 协议, 这个很关键!!!</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">    associatedtype defaultKeys: <span class=\"type\">RawRepresentable</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaultsSettable</span> <span class=\"title\">where</span> <span class=\"title\">defaultKeys</span>.<span class=\"title\">RawValue</span>==<span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(value: String?, forKey key: defaultKeys)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> aKey = key.rawValue</div><div class=\"line\">        <span class=\"type\">UserDefaults</span>.standard.<span class=\"keyword\">set</span>(value, forKey: aKey)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">string</span><span class=\"params\">(forKey key: defaultKeys)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> aKey = key.rawValue</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.string(forKey: aKey)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>必须在扩展中使用 where 子语句限制关联类型是字符串类型, 因为 UserDefaults 的 key 就是字符串类型.<br>where defaultKeys.RawValue==String</p>\n</blockquote>\n<p>在 UserDefaults 的扩展中定义分组 key: </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserDefaults</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 账户信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AccountInfo</span>: <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">defaultKeys</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> userName</div><div class=\"line\">            <span class=\"keyword\">case</span> age</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 登录信息</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LoginInfo</span>: <span class=\"title\">UserDefaultsSettable</span> </span>&#123;</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">defaultKeys</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> token</div><div class=\"line\">            <span class=\"keyword\">case</span> userId</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>存取数据:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"chilli cheng\"</span>, forKey: .userName)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">AccountInfo</span>.string(forKey: .userName)</div><div class=\"line\">        </div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">LoginInfo</span>.<span class=\"keyword\">set</span>(value: <span class=\"string\">\"ahdsjhad\"</span>, forKey: .token)</div><div class=\"line\"><span class=\"type\">UserDefaults</span>.<span class=\"type\">LoginInfo</span>.string(forKey: .token)</div></pre></td></tr></table></figure>\n<p>打完收工, 既没有手动去写 key, 避免了写错的问题, 实现了key的一致性, 又实现了上下文, 能够直接明白 key 的含义.<br>如果还有需要存储的分类数据, 同样在 UserDefaults extension 中添加一个结构体, 遵守 UserDefaultsSettable 协议, 实现 defaultKeys 枚举属性, 在枚举中设置该分类存储数据所需要的 key.</p>\n<blockquote>\n<p>注意: UserDefaultsSettable 协议中只实现了存取 string 类型的数据, 可以自行在 UserDefaultsSettable 协议中添加 Int, Bool等类型方法. 虽然这种用法前期比较费劲, 但是不失为一种管理 UserDefaults 的比较好的方式.<br>如果大家有更好的方式, 欢迎交流.</p>\n</blockquote>\n<p>欢迎大家斧正!</p>"},{"title":"TMCache源码分析<二> TMDiskCache磁盘缓存","date":"2016-03-02T16:00:00.000Z","_content":"\n[上篇分析](https://chengzhipeng.github.io/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/)了 `TMCache`中内存缓存`TMMemoryCache`的实现原理, 这篇文章将详细分析磁盘缓存的实现原理.  \n\n磁盘缓存,顾名思义:将数据存储到磁盘上,由于需要储存的数据量比较大,所以一般读写速度都比内存缓存慢, 但也是非常重要的一项功能, 比如能够实现离线浏览等提升用户体验.  \n\n磁盘缓存的实现形式大致分为三种:\n- 基于文件读写.\n- 基于数据库.  \n- 基于 mmap 文件内存映射.\n\n<!---more--->\n\n前面两种使用的比较广泛, `SDWebImage`和`TMDiskCache`都是基于文件 I/O 进行存储的, 也就是一个 value 对应一个文件, 通过读写文件来缓存数据. 根据上篇可以知道`TMMemoryCache`内存缓存的主线是按照 key-value的形式把数据存进可变字典中, 那么磁盘缓存的主线也是按照 key-value的形式进行对应的, 只不过 value 对应的是一个文件, 换汤不换药.  \n\n通过`TMDiskCache`的接口 API 可以看到, `TMDiskCache`提供以下功能:  \n- 同步/异步的进行读写数据.\n- 同步/异步的进行删除数据.\n- 同步/异步的获取缓存路径.\n- 同步/异步的根据缓存时间或者缓存大小来削减磁盘空间.\n- 设置磁盘缓存空间上限, 磁盘缓存时间上限.\n- 各类 will / did block, 以及监听后台操作.\n- 清空临时存储区.\n\n`TMDiskCache`的同步操作是跟`TMMemoryCache`操作一样,都是采用`dispatch_semaphore_t`信号量的形式来强制把异步转成同步操作,后面同步操作就一步带过,除非特别说明.   其实`TMDiskCache`的难点不在于线程安全,因为它所有的操作都在一个 serial queue 串行队列中, 不存在竞态情况, 难点在于文件的操作, 了解 Linux 文件系统操作的同学应该知道文件 I/O 的概念, iOS 封装了操作文件的类, 使用这些高级 API 能更好的操作文件.\n\n### 初始化方法\n在操作之前先看一下`TMDiskCache`的初始化方法, 提供一个类方法, 两个实例方法:\n\n```Objc\n+ (instancetype)sharedCache;\n\n- (instancetype)initWithName:(NSString *)name;\n- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath;\n```\n从名字应该能猜测出最终调用的方法应该是`- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath`, 传磁盘缓存所在目录的名字和绝对路径, 如果调用前两个方法,在方法内部将默认设置好路径或者缓存文件夹名字. 我们主要看终极方法主要做了几件事:\n- 创建串行队列,是单例,即一个单例缓存对象有一个单例串行队列.\n- 初始化两个可变字典`_dates`, `_sizes`, 分别用于存数据最后操作时间和数据占用磁盘空间大小.\n- 创建缓存文件, 设置缓存文件操作时间.\n\n其余的比较简单, 这里主要说一下`设置缓存文件操作时间`的相关 API, 首先是处理 key 的方法, 这两个方法分别对传入的 key 进行编码和解码, 比如在调用`setObject:forKey:`的时候 key 值传入了中文字符, 就会调用`encodedString`和`decodedString`来编解码, 可以进入沙盒中看到对应的缓存文件名字是这类编码后的字符, 形如:`%E7%A8%8B%E5%85%88%E7%94%9F`.\n\n```Objc\n- (NSString *)encodedString:(NSString *)string {\n    if (![string length])\n        return @\"\";\n    \n    CFStringRef static const charsToEscape = CFSTR(\".:/\");\n    CFStringRef escapedString = CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,\n                                                                        (__bridge CFStringRef)string,\n                                                                        NULL,\n                                                                        charsToEscape,\n                                                                        kCFStringEncodingUTF8);\n    return (__bridge_transfer NSString *)escapedString;\n}\n\n- (NSString *)decodedString:(NSString *)string {\n    if (![string length])\n        return @\"\";\n    \n    CFStringRef unescapedString = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault,\n                                                                                          (__bridge CFStringRef)string,\n                                                                                          CFSTR(\"\"),\n                                                                                          kCFStringEncodingUTF8);\n    return (__bridge_transfer NSString *)unescapedString;\n}\n\n```\n\n下面这个初始化设置方法, 只做了一件事:\n> 遍历缓存文件夹下面所有的已缓存的文件, 更新的操作时间数组`_dates`, 文件大小数组`_sizes`以及更新磁盘总使用大小.\n\n这么做的目的是什么呢?第一次创建磁盘缓存目录肯定是空的文件夹, 里面铁定没有缓存文件, 那为什么要遍历一次所有的缓存文件并更新其操作时间和大小呢? 其实是为了防止不小心再次调用`- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath`创建了一个名字和路径都相同的缓存目录, 避免里面已经缓存的数据`脱离控制`. 用心良苦呀!\n\n```Objc\n- (void)initializeDiskProperties {\n    NSUInteger byteCount = 0;\n    NSArray *keys = @[ NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey ];\n    \n    NSError *error = nil;\n    NSArray *files = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:_cacheURL\n                                                   includingPropertiesForKeys:keys\n                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles\n                                                                        error:&error];\n    TMDiskCacheError(error);\n    \n    for (NSURL *fileURL in files) {\n        NSString *key = [self keyForEncodedFileURL:fileURL];\n        \n        error = nil;\n        NSDictionary *dictionary = [fileURL resourceValuesForKeys:keys error:&error];\n        TMDiskCacheError(error);\n        \n        NSDate *date = [dictionary objectForKey:NSURLContentModificationDateKey];\n        if (date && key)\n            [_dates setObject:date forKey:key];\n        \n        NSNumber *fileSize = [dictionary objectForKey:NSURLTotalFileAllocatedSizeKey];\n        if (fileSize) {\n            [_sizes setObject:fileSize forKey:key];\n            byteCount += [fileSize unsignedIntegerValue];\n        }\n    }\n    \n    if (byteCount > 0)\n        self.byteCount = byteCount; // atomic\n}\n\n- (NSString *)keyForEncodedFileURL:(NSURL *)url {\n    NSString *fileName = [url lastPathComponent];\n    if (!fileName)\n        return nil;\n\n    return [self decodedString:fileName];\n}\n\n```\n\n\n由此看出, 对于缓存数据来说, `key 经过编码后设为缓存文件名,  value 经过归档后写入文件`.  \n\n至此, 所有的准备工作都基本做完, 下面开始存取数据了.\n\n### 同步/异步的进行读写数据\n\n#### 异步的进行读写数据\n相关 API:\n\n```Objc\n- (void)objectForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n- (void)setObject:(id <NSCoding>)object forKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n```\n\n先来看看写操作如何实现的, 我就不贴源码具体实现了, 省的看的费劲, 只看关键部位吧~~~你懂的, 嘻嘻.\n\n##### 写入缓存 \n1. 写操作被 commit 到串行队列中, 保证了写缓存的时候线程安全:\n    \n    ```Objc\n    dispatch_async(_queue, ^{ \n        // 写操作\n        // ...\n    }\n    ```\n\n2. 将传入的对象进行归档处理, 所以要缓存的对象一定要遵守`NSCoding`协议, 并实现相关方法:\n\n    ```Objc\n    BOOL written = [NSKeyedArchiver archiveRootObject:object toFile:[fileURL path]];\n    ```\n\n3. 更新缓存文件的修改时间, 不管是新加入的缓存数据还是已有的缓存数据进行更新, 都会修改对应的时间为当前时间:\n    \n    ```Objc\n    [strongSelf setFileModificationDate:now forURL:fileURL];\n    ```\n\n4. 下面是针对缓存空间大小的处理, 比较重要的一步, 根据最新缓存的数据更新总共已经使用的磁盘空间大小, 如果超过预设磁盘空间上限, 则需要删除一些数据以达到不超过上限的目的, 那以什么规则来删除超过缓存上限的部分数据呢? `TMMemoryCache`的优化策略是根据操作时间的先后顺序, 即操作时间早的数据, 认为你使用的概率比较低, 所以就优先删除掉, `TMDiskCache`优化策略跟`TMMemoryCache`相同, 先删除最早的数据. 这也是以文件系统的形式缓存数据的缺点, 不能进行有效的算法.\n - 更新缓存空间大小.\n \n     ```Objc\n        NSNumber *oldEntry = [strongSelf->_sizes objectForKey:key];\n        \n        if ([oldEntry isKindOfClass:[NSNumber class]]){\n            strongSelf.byteCount = strongSelf->_byteCount - [oldEntry unsignedIntegerValue];\n        }\n        \n        [strongSelf->_sizes setObject:diskFileSize forKey:key];\n        strongSelf.byteCount = strongSelf->_byteCount + [diskFileSize unsignedIntegerValue]; // atomic\n     ```\n - 删除超出部分空间的缓存数据.\n \n     ```Objc\n     if (strongSelf->_byteLimit > 0 && strongSelf->_byteCount > strongSelf->_byteLimit)\n                    [strongSelf trimToSizeByDate:strongSelf->_byteLimit block:nil];\n     ```\n\n至此异步写入缓存数据完成, 注意:\n> `_dates`, `_sizes`中的 key 并没有经过编码, 只有缓存文件名才是经过编码的.\n\n##### 读取缓存\n相关 API:\n\n```Objc\n- (id <NSCoding>)objectForKey:(NSString *)key;\n- (void)objectForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n```\n也是看看异步的读取缓存, 根据上面写入缓存的步骤可以推测读取的步骤, 无非就是把 key 进行编码, 找到缓存文件, 再解档缓存文件内容, 最后更新操作时间, 主线就这几步, 其余的就是加点\"配料\" - will / did block 之类的时序控制类操作.\n\n```Objc\ndispatch_async(_queue, ^{\n        TMDiskCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        NSURL *fileURL = [strongSelf encodedFileURLForKey:key];\n        id <NSCoding> object = nil;\n        \n        if ([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]]) {\n            @try {\n                object = [NSKeyedUnarchiver unarchiveObjectWithFile:[fileURL path]];\n            }\n            @catch (NSException *exception) {\n                NSError *error = nil;\n                [[NSFileManager defaultManager] removeItemAtPath:[fileURL path] error:&error];\n                TMDiskCacheError(error);\n            }\n            \n            [strongSelf setFileModificationDate:now forURL:fileURL];\n        }\n        \n        block(strongSelf, key, object, fileURL);\n    });\n```\n代码中通过`@ try`, `@catch`抛出异常, 如果解档缓存文件内容失败, 直接删除该缓存文件, 简单不做作, 直接了当! 额, 也许不近人情, 好歹你告诉我错误信息是什么, 让我来决定删不删嘛. \n\n#### 同步的写入/读取缓存\n都是采用`dispatch_semaphore_t`信号量的形式来实现的.\n\n### 同步/异步的进行删除数据\n相关 API:\n\n```Objc\n- (void)removeObjectForKey:(NSString *)key;\n- (void)removeObjectForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n```\n我们只分析异步的删除缓存数据, 同步的跟其它同步操作一样.\n既然知道怎么写入缓存, 那删除应该也没什么问题了, 找到要删除的文件路径, 删除该缓存文件即可. 所以步骤应该是:\n1. key 进行编码, 再拼接成完整的缓存文件的绝对路径.\n2. 删除文件, 其中删除文件做了特殊的步骤, 但是不影响整个删除流程, 后面会讲解.\n3. 删除`_dates`,`_sizes`中的键值对, 更新总用使用的缓存空间大小.\n\n> 注意删除文件的时候并没有直接删除, 而是把待删除文件移到临时目录 `tmp`下的缓存目录里, 创建了一个新的串行队列进行删除操作.\n\n```Objc\nBOOL trashed = [TMDiskCache moveItemAtURLToTrash:fileURL];\nif (!trashed)\n     return NO;\n\n[TMDiskCache emptyTrash];\n```\n\n### 同步/异步的获取缓存路径\n相关 API:\n\n```Objc\n- (void)fileURLForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n- (NSURL *)fileURLForKey:(NSString *)key;\n```\n实现非常简单:\n1. 对 key 进行编码, 拼接完整缓存文件路径.\n2. 更新缓存文件操作时间.\n\n```Objc\n    NSURL *fileURL = [strongSelf encodedFileURLForKey:key];\n    \n    if ([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]]) {\n        [strongSelf setFileModificationDate:now forURL:fileURL];\n    } else {\n        fileURL = nil;\n    }\n```\n\n### 同步/异步的根据缓存时间或者缓存大小来削减磁盘空间\n这部分操作跟`TMMemoryCache`的实现类似, 相关 API: \n\n```Objc\n- (void)trimToDate:(NSDate *)date;\n- (void)trimToDate:(NSDate *)date block:(TMDiskCacheBlock)block;\n\n- (void)trimToSize:(NSUInteger)byteCount;\n- (void)trimToSize:(NSUInteger)byteCount block:(TMDiskCacheBlock)block;\n\n- (void)trimToSizeByDate:(NSUInteger)byteCount;\n- (void)trimToSizeByDate:(NSUInteger)byteCount block:(TMDiskCacheBlock)block;\n```\n第一组, 根据缓存时间来削减缓存空间, 如果缓存数据的缓存时间超过了设置的`date`, 则会被删除.\n第二组, 根据缓存大小来削减缓存空间, 如果缓存数据的缓存大小超过了指定的`byteCount`, 则会被删除.\n第三组, 根据操作时间的先后顺序, 来削减超过了指定缓存大小的空间.\n\n实现大致都相同, 无非就是对时间进行排序, 然后把 key 进行编码, 拼接路径, 移动缓存文件到 tmp目录下, 再清空 tmp 目录. 注意一点, 无论是按照缓存时间还是缓存大小, 都是升序排序, 最先删除的都是`最早的或最小的`数据.\n\n### 设置磁盘缓存空间上限, 磁盘缓存时间上限\n源码实现:\n\n```Objc\n- (NSUInteger)byteLimit {\n    __block NSUInteger byteLimit = 0;\n    \n    dispatch_sync(_queue, ^{\n        byteLimit = _byteLimit;\n    });\n    \n    return byteLimit;\n}\n\n- (void)setByteLimit:(NSUInteger)byteLimit {\n    __weak TMDiskCache *weakSelf = self;\n    \n    dispatch_barrier_async(_queue, ^{\n        TMDiskCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        strongSelf->_byteLimit = byteLimit;\n        \n        if (byteLimit > 0)\n            [strongSelf trimDiskToSizeByDate:byteLimit];\n    });\n}\n```\n\n设置缓存空间上限的时候采用`dispatch_barrier_async `栅栏方法, 我不知道作者为何这么写, 多此一举! 本来就是串行队列了, 就能够保证线程安全, 加`栅栏`方法没什么意义. 现在应该注意的不是线程安全, 而是`线程死锁`的问题. 所以在 API 接口中有个⚠️警告\n> @warning Do not read this property on the <sharedQueue> (including asynchronous method blocks).\n\n意思是不要在 `shareQueue` 和接口里面的任何 API 的异步 block 中去读这个属性, 为什么呢?  因为`TMDiskCache`所有的读写删除操作都是放在`Serial Queue`串行队列中的, 也就是`shareQueue`队列, 天啦噜...这不造成死锁才怪呢! 警告还写这么不明显.形如下面的是`错误❌`的用法:\n\n```Objc\n[diskCache removeObjectForKey:@\"profileKey\" block:^(TMDiskCache *cache, NSString *key, id<NSCoding> object, NSURL *fileURL) {\n        NSLog(@\"%ld\", diskCache.byteLimit);\n }];\n```\n\n因为在`removeObjectForKey`之类的方法中会同步执行传入的 block 操作, 如果在 block 里面再提交新的任务到串行队列中, 再同步执行, 必然死锁. 因为外层的 block 需要等待新提交的 block 执行完毕才能执行完成, 然而新提交的 block 需要等待外层 block 执行完才能执行, 两者相互依赖对方执行完才能执行完成, 就造成`死锁`了.   \n\n```Objc\nif (block)\n    block(strongSelf, key, nil, fileURL);\n``` \n上一篇分析了 `TMMemoryCache` 容易造成性能消耗严重, 而`TMDiskCache`使用不当容易造成`死锁.`\n\n### 各类 will / did block, 以及后台操作\n\nwill / did block 穿插在各类异步操作中, 非常简单, 看看即可.\n\n```Objc\nif (strongSelf->_willAddObjectBlock)\n    strongSelf->_willAddObjectBlock(strongSelf, key, object, fileURL);\n```\n其中后台操作有点意思, 创建一个全局的`后台管理者`遵守`TMCacheBackgroundTaskManager`协议, 实现其中的两个方法:\n\n```Objc\n- (UIBackgroundTaskIdentifier)beginBackgroundTask;\n- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier;\n```\n然后调用设置方法, 给 `TMDiskCache`对象设置后台管理者.\n\n```Objc\n+ (void)setBackgroundTaskManager:(id <TMCacheBackgroundTaskManager>)backgroundTaskManager;\n```\n在后台任务开始之前调用 `beginBackgroundTask` 方法, 结束后台任务之前调用 `endBackgroundTask`, 就能在后台管理者里面监听到什么时候进入后台操作, 什么时候结束后台操作了.\n具体做法:\n\n```Objc\nUIBackgroundTaskIdentifier taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];\n\ndispatch_async(_queue, ^{ \n      TMDiskCache *strongSelf = weakSelf;\n        if (!strongSelf) {\n            [TMCacheBackgroundTaskManager endBackgroundTask:taskID];\n            return;\n        }\n\n      // 执行后台任务\n      // 比如: 写缓存, 取缓存, 删除缓存等等.\n\n     [TMCacheBackgroundTaskManager endBackgroundTask:taskID];\n}\n```\n因为磁盘的操作可能耗时非常长, 不可能一直等待, 因此通过这种全局的方式来感知异步操作的开始和结束, 从而执行响应事件. \n\n### 清空临时存储区\n根据上面可以知道, 删除缓存文件的时候, 先会在`tmp`下创建\"回收目录\", 需要删除的缓存文件统一放进回收目录下, 下面是获取回收目录的URL 路径, 没有就创建, 有则返回, 只创建一次:\n\n```Objc\n+ (NSURL *)sharedTrashURL {\n    static NSURL *sharedTrashURL;\n    static dispatch_once_t predicate;\n    \n    dispatch_once(&predicate, ^{\n        sharedTrashURL = [[[NSURL alloc] initFileURLWithPath:NSTemporaryDirectory()] URLByAppendingPathComponent:TMDiskCachePrefix isDirectory:YES];\n        \n        if (![[NSFileManager defaultManager] fileExistsAtPath:[sharedTrashURL path]]) {\n            NSError *error = nil;\n            [[NSFileManager defaultManager] createDirectoryAtURL:sharedTrashURL\n                                     withIntermediateDirectories:YES\n                                                      attributes:nil\n                                                           error:&error];\n            TMDiskCacheError(error);\n        }\n    });\n    \n    return sharedTrashURL;\n}\n```\n\n创建一个清空操作专属的串行队列`TrashQueue`, 并且使用`dispatch_set_target_queue`方法修改`TrashQueue`的优先级, 并与全局并发队列`global_queue` 的后台优先级一致. 因为`tmp`目录的情况操作不是那么的重要, 即使我们不手动清除, 系统也会在恰当的时候清除, 所以这里把`TrashQueue`队列的优先级降低.\n\n```Objc\n+ (dispatch_queue_t)sharedTrashQueue {\n    static dispatch_queue_t trashQueue;\n    static dispatch_once_t predicate;\n    \n    dispatch_once(&predicate, ^{\n        NSString *queueName = [[NSString alloc] initWithFormat:@\"%@.trash\", TMDiskCachePrefix];\n        trashQueue = dispatch_queue_create([queueName UTF8String], DISPATCH_QUEUE_SERIAL);\n        dispatch_set_target_queue(trashQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));\n    });\n    \n    return trashQueue;\n}\n```\n\n类方法, 把原本在`Caches`下的缓存文件移动进`tmp`目录下的回收目录.\n\n```Objc\n+ (BOOL)moveItemAtURLToTrash:(NSURL *)itemURL {\n    if (![[NSFileManager defaultManager] fileExistsAtPath:[itemURL path]])\n        return NO;\n    \n    NSError *error = nil;\n    NSString *uniqueString = [[NSProcessInfo processInfo] globallyUniqueString];\n    NSURL *uniqueTrashURL = [[TMDiskCache sharedTrashURL] URLByAppendingPathComponent:uniqueString];\n    BOOL moved = [[NSFileManager defaultManager] moveItemAtURL:itemURL toURL:uniqueTrashURL error:&error];\n    TMDiskCacheError(error);\n    return moved;\n}\n```\n\n把清除操作添加到`TrashQueue`中异步执行, 在该方法中遍历回收目录下所有的缓存文件, 依次进行删除:\n\n```Objc\n+ (void)emptyTrash {\n    UIBackgroundTaskIdentifier taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];\n    \n    dispatch_async([self sharedTrashQueue], ^{\n        NSError *error = nil;\n        NSArray *trashedItems = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:[self sharedTrashURL]\n                                                              includingPropertiesForKeys:nil\n                                                                                 options:0\n                                                                                   error:&error];\n        TMDiskCacheError(error);\n        \n        for (NSURL *trashedItemURL in trashedItems) {\n            NSError *error = nil;\n            [[NSFileManager defaultManager] removeItemAtURL:trashedItemURL error:&error];\n            TMDiskCacheError(error);\n        }\n        \n        [TMCacheBackgroundTaskManager endBackgroundTask:taskID];\n    });\n}\n```\n\n其实我们只要看一下删除操作在哪里执行的, 就能明白为何作者要创建一个专门用于删除数据的串行队列了. `emptyTrash`方法调用是在读写操作的串行队列`queue`中, 方法调用后面还有`_didRemoveObjectBlock`等待执行, 如果删除数据量比较大且删除操作在`queue`中, 将阻塞当前线程, 那么`_didRemoveObjectBlock`会等待许久才能回调, 况且删除操作对于响应用户事件而言不是那么的重要, 所以把需要删除的缓存文件放进`tmp`目录下, 创建新的低优先级的串行队列来进行删除操作.  这点值得学习!\n\n```Objc\n[TMDiskCache emptyTrash];\n```\n\n### 总结\n1. 使用`TMDiskCache`姿势要正确, 否则容易造成`死锁`.\n2. 删除缓存的思路值得借鉴.  \n\n欢迎大家斧正!\n\n","source":"_posts/TMCache源码分析之TMDiskCache磁盘缓存.md","raw":"\n---\ntitle: TMCache源码分析<二> TMDiskCache磁盘缓存\ndate: 2016-3-3 \ncategories: Objective-C\ntags: [TMCache, 缓存]\n---\n\n[上篇分析](https://chengzhipeng.github.io/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/)了 `TMCache`中内存缓存`TMMemoryCache`的实现原理, 这篇文章将详细分析磁盘缓存的实现原理.  \n\n磁盘缓存,顾名思义:将数据存储到磁盘上,由于需要储存的数据量比较大,所以一般读写速度都比内存缓存慢, 但也是非常重要的一项功能, 比如能够实现离线浏览等提升用户体验.  \n\n磁盘缓存的实现形式大致分为三种:\n- 基于文件读写.\n- 基于数据库.  \n- 基于 mmap 文件内存映射.\n\n<!---more--->\n\n前面两种使用的比较广泛, `SDWebImage`和`TMDiskCache`都是基于文件 I/O 进行存储的, 也就是一个 value 对应一个文件, 通过读写文件来缓存数据. 根据上篇可以知道`TMMemoryCache`内存缓存的主线是按照 key-value的形式把数据存进可变字典中, 那么磁盘缓存的主线也是按照 key-value的形式进行对应的, 只不过 value 对应的是一个文件, 换汤不换药.  \n\n通过`TMDiskCache`的接口 API 可以看到, `TMDiskCache`提供以下功能:  \n- 同步/异步的进行读写数据.\n- 同步/异步的进行删除数据.\n- 同步/异步的获取缓存路径.\n- 同步/异步的根据缓存时间或者缓存大小来削减磁盘空间.\n- 设置磁盘缓存空间上限, 磁盘缓存时间上限.\n- 各类 will / did block, 以及监听后台操作.\n- 清空临时存储区.\n\n`TMDiskCache`的同步操作是跟`TMMemoryCache`操作一样,都是采用`dispatch_semaphore_t`信号量的形式来强制把异步转成同步操作,后面同步操作就一步带过,除非特别说明.   其实`TMDiskCache`的难点不在于线程安全,因为它所有的操作都在一个 serial queue 串行队列中, 不存在竞态情况, 难点在于文件的操作, 了解 Linux 文件系统操作的同学应该知道文件 I/O 的概念, iOS 封装了操作文件的类, 使用这些高级 API 能更好的操作文件.\n\n### 初始化方法\n在操作之前先看一下`TMDiskCache`的初始化方法, 提供一个类方法, 两个实例方法:\n\n```Objc\n+ (instancetype)sharedCache;\n\n- (instancetype)initWithName:(NSString *)name;\n- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath;\n```\n从名字应该能猜测出最终调用的方法应该是`- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath`, 传磁盘缓存所在目录的名字和绝对路径, 如果调用前两个方法,在方法内部将默认设置好路径或者缓存文件夹名字. 我们主要看终极方法主要做了几件事:\n- 创建串行队列,是单例,即一个单例缓存对象有一个单例串行队列.\n- 初始化两个可变字典`_dates`, `_sizes`, 分别用于存数据最后操作时间和数据占用磁盘空间大小.\n- 创建缓存文件, 设置缓存文件操作时间.\n\n其余的比较简单, 这里主要说一下`设置缓存文件操作时间`的相关 API, 首先是处理 key 的方法, 这两个方法分别对传入的 key 进行编码和解码, 比如在调用`setObject:forKey:`的时候 key 值传入了中文字符, 就会调用`encodedString`和`decodedString`来编解码, 可以进入沙盒中看到对应的缓存文件名字是这类编码后的字符, 形如:`%E7%A8%8B%E5%85%88%E7%94%9F`.\n\n```Objc\n- (NSString *)encodedString:(NSString *)string {\n    if (![string length])\n        return @\"\";\n    \n    CFStringRef static const charsToEscape = CFSTR(\".:/\");\n    CFStringRef escapedString = CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,\n                                                                        (__bridge CFStringRef)string,\n                                                                        NULL,\n                                                                        charsToEscape,\n                                                                        kCFStringEncodingUTF8);\n    return (__bridge_transfer NSString *)escapedString;\n}\n\n- (NSString *)decodedString:(NSString *)string {\n    if (![string length])\n        return @\"\";\n    \n    CFStringRef unescapedString = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault,\n                                                                                          (__bridge CFStringRef)string,\n                                                                                          CFSTR(\"\"),\n                                                                                          kCFStringEncodingUTF8);\n    return (__bridge_transfer NSString *)unescapedString;\n}\n\n```\n\n下面这个初始化设置方法, 只做了一件事:\n> 遍历缓存文件夹下面所有的已缓存的文件, 更新的操作时间数组`_dates`, 文件大小数组`_sizes`以及更新磁盘总使用大小.\n\n这么做的目的是什么呢?第一次创建磁盘缓存目录肯定是空的文件夹, 里面铁定没有缓存文件, 那为什么要遍历一次所有的缓存文件并更新其操作时间和大小呢? 其实是为了防止不小心再次调用`- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath`创建了一个名字和路径都相同的缓存目录, 避免里面已经缓存的数据`脱离控制`. 用心良苦呀!\n\n```Objc\n- (void)initializeDiskProperties {\n    NSUInteger byteCount = 0;\n    NSArray *keys = @[ NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey ];\n    \n    NSError *error = nil;\n    NSArray *files = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:_cacheURL\n                                                   includingPropertiesForKeys:keys\n                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles\n                                                                        error:&error];\n    TMDiskCacheError(error);\n    \n    for (NSURL *fileURL in files) {\n        NSString *key = [self keyForEncodedFileURL:fileURL];\n        \n        error = nil;\n        NSDictionary *dictionary = [fileURL resourceValuesForKeys:keys error:&error];\n        TMDiskCacheError(error);\n        \n        NSDate *date = [dictionary objectForKey:NSURLContentModificationDateKey];\n        if (date && key)\n            [_dates setObject:date forKey:key];\n        \n        NSNumber *fileSize = [dictionary objectForKey:NSURLTotalFileAllocatedSizeKey];\n        if (fileSize) {\n            [_sizes setObject:fileSize forKey:key];\n            byteCount += [fileSize unsignedIntegerValue];\n        }\n    }\n    \n    if (byteCount > 0)\n        self.byteCount = byteCount; // atomic\n}\n\n- (NSString *)keyForEncodedFileURL:(NSURL *)url {\n    NSString *fileName = [url lastPathComponent];\n    if (!fileName)\n        return nil;\n\n    return [self decodedString:fileName];\n}\n\n```\n\n\n由此看出, 对于缓存数据来说, `key 经过编码后设为缓存文件名,  value 经过归档后写入文件`.  \n\n至此, 所有的准备工作都基本做完, 下面开始存取数据了.\n\n### 同步/异步的进行读写数据\n\n#### 异步的进行读写数据\n相关 API:\n\n```Objc\n- (void)objectForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n- (void)setObject:(id <NSCoding>)object forKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n```\n\n先来看看写操作如何实现的, 我就不贴源码具体实现了, 省的看的费劲, 只看关键部位吧~~~你懂的, 嘻嘻.\n\n##### 写入缓存 \n1. 写操作被 commit 到串行队列中, 保证了写缓存的时候线程安全:\n    \n    ```Objc\n    dispatch_async(_queue, ^{ \n        // 写操作\n        // ...\n    }\n    ```\n\n2. 将传入的对象进行归档处理, 所以要缓存的对象一定要遵守`NSCoding`协议, 并实现相关方法:\n\n    ```Objc\n    BOOL written = [NSKeyedArchiver archiveRootObject:object toFile:[fileURL path]];\n    ```\n\n3. 更新缓存文件的修改时间, 不管是新加入的缓存数据还是已有的缓存数据进行更新, 都会修改对应的时间为当前时间:\n    \n    ```Objc\n    [strongSelf setFileModificationDate:now forURL:fileURL];\n    ```\n\n4. 下面是针对缓存空间大小的处理, 比较重要的一步, 根据最新缓存的数据更新总共已经使用的磁盘空间大小, 如果超过预设磁盘空间上限, 则需要删除一些数据以达到不超过上限的目的, 那以什么规则来删除超过缓存上限的部分数据呢? `TMMemoryCache`的优化策略是根据操作时间的先后顺序, 即操作时间早的数据, 认为你使用的概率比较低, 所以就优先删除掉, `TMDiskCache`优化策略跟`TMMemoryCache`相同, 先删除最早的数据. 这也是以文件系统的形式缓存数据的缺点, 不能进行有效的算法.\n - 更新缓存空间大小.\n \n     ```Objc\n        NSNumber *oldEntry = [strongSelf->_sizes objectForKey:key];\n        \n        if ([oldEntry isKindOfClass:[NSNumber class]]){\n            strongSelf.byteCount = strongSelf->_byteCount - [oldEntry unsignedIntegerValue];\n        }\n        \n        [strongSelf->_sizes setObject:diskFileSize forKey:key];\n        strongSelf.byteCount = strongSelf->_byteCount + [diskFileSize unsignedIntegerValue]; // atomic\n     ```\n - 删除超出部分空间的缓存数据.\n \n     ```Objc\n     if (strongSelf->_byteLimit > 0 && strongSelf->_byteCount > strongSelf->_byteLimit)\n                    [strongSelf trimToSizeByDate:strongSelf->_byteLimit block:nil];\n     ```\n\n至此异步写入缓存数据完成, 注意:\n> `_dates`, `_sizes`中的 key 并没有经过编码, 只有缓存文件名才是经过编码的.\n\n##### 读取缓存\n相关 API:\n\n```Objc\n- (id <NSCoding>)objectForKey:(NSString *)key;\n- (void)objectForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n```\n也是看看异步的读取缓存, 根据上面写入缓存的步骤可以推测读取的步骤, 无非就是把 key 进行编码, 找到缓存文件, 再解档缓存文件内容, 最后更新操作时间, 主线就这几步, 其余的就是加点\"配料\" - will / did block 之类的时序控制类操作.\n\n```Objc\ndispatch_async(_queue, ^{\n        TMDiskCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        NSURL *fileURL = [strongSelf encodedFileURLForKey:key];\n        id <NSCoding> object = nil;\n        \n        if ([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]]) {\n            @try {\n                object = [NSKeyedUnarchiver unarchiveObjectWithFile:[fileURL path]];\n            }\n            @catch (NSException *exception) {\n                NSError *error = nil;\n                [[NSFileManager defaultManager] removeItemAtPath:[fileURL path] error:&error];\n                TMDiskCacheError(error);\n            }\n            \n            [strongSelf setFileModificationDate:now forURL:fileURL];\n        }\n        \n        block(strongSelf, key, object, fileURL);\n    });\n```\n代码中通过`@ try`, `@catch`抛出异常, 如果解档缓存文件内容失败, 直接删除该缓存文件, 简单不做作, 直接了当! 额, 也许不近人情, 好歹你告诉我错误信息是什么, 让我来决定删不删嘛. \n\n#### 同步的写入/读取缓存\n都是采用`dispatch_semaphore_t`信号量的形式来实现的.\n\n### 同步/异步的进行删除数据\n相关 API:\n\n```Objc\n- (void)removeObjectForKey:(NSString *)key;\n- (void)removeObjectForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n```\n我们只分析异步的删除缓存数据, 同步的跟其它同步操作一样.\n既然知道怎么写入缓存, 那删除应该也没什么问题了, 找到要删除的文件路径, 删除该缓存文件即可. 所以步骤应该是:\n1. key 进行编码, 再拼接成完整的缓存文件的绝对路径.\n2. 删除文件, 其中删除文件做了特殊的步骤, 但是不影响整个删除流程, 后面会讲解.\n3. 删除`_dates`,`_sizes`中的键值对, 更新总用使用的缓存空间大小.\n\n> 注意删除文件的时候并没有直接删除, 而是把待删除文件移到临时目录 `tmp`下的缓存目录里, 创建了一个新的串行队列进行删除操作.\n\n```Objc\nBOOL trashed = [TMDiskCache moveItemAtURLToTrash:fileURL];\nif (!trashed)\n     return NO;\n\n[TMDiskCache emptyTrash];\n```\n\n### 同步/异步的获取缓存路径\n相关 API:\n\n```Objc\n- (void)fileURLForKey:(NSString *)key block:(TMDiskCacheObjectBlock)block;\n- (NSURL *)fileURLForKey:(NSString *)key;\n```\n实现非常简单:\n1. 对 key 进行编码, 拼接完整缓存文件路径.\n2. 更新缓存文件操作时间.\n\n```Objc\n    NSURL *fileURL = [strongSelf encodedFileURLForKey:key];\n    \n    if ([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]]) {\n        [strongSelf setFileModificationDate:now forURL:fileURL];\n    } else {\n        fileURL = nil;\n    }\n```\n\n### 同步/异步的根据缓存时间或者缓存大小来削减磁盘空间\n这部分操作跟`TMMemoryCache`的实现类似, 相关 API: \n\n```Objc\n- (void)trimToDate:(NSDate *)date;\n- (void)trimToDate:(NSDate *)date block:(TMDiskCacheBlock)block;\n\n- (void)trimToSize:(NSUInteger)byteCount;\n- (void)trimToSize:(NSUInteger)byteCount block:(TMDiskCacheBlock)block;\n\n- (void)trimToSizeByDate:(NSUInteger)byteCount;\n- (void)trimToSizeByDate:(NSUInteger)byteCount block:(TMDiskCacheBlock)block;\n```\n第一组, 根据缓存时间来削减缓存空间, 如果缓存数据的缓存时间超过了设置的`date`, 则会被删除.\n第二组, 根据缓存大小来削减缓存空间, 如果缓存数据的缓存大小超过了指定的`byteCount`, 则会被删除.\n第三组, 根据操作时间的先后顺序, 来削减超过了指定缓存大小的空间.\n\n实现大致都相同, 无非就是对时间进行排序, 然后把 key 进行编码, 拼接路径, 移动缓存文件到 tmp目录下, 再清空 tmp 目录. 注意一点, 无论是按照缓存时间还是缓存大小, 都是升序排序, 最先删除的都是`最早的或最小的`数据.\n\n### 设置磁盘缓存空间上限, 磁盘缓存时间上限\n源码实现:\n\n```Objc\n- (NSUInteger)byteLimit {\n    __block NSUInteger byteLimit = 0;\n    \n    dispatch_sync(_queue, ^{\n        byteLimit = _byteLimit;\n    });\n    \n    return byteLimit;\n}\n\n- (void)setByteLimit:(NSUInteger)byteLimit {\n    __weak TMDiskCache *weakSelf = self;\n    \n    dispatch_barrier_async(_queue, ^{\n        TMDiskCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        strongSelf->_byteLimit = byteLimit;\n        \n        if (byteLimit > 0)\n            [strongSelf trimDiskToSizeByDate:byteLimit];\n    });\n}\n```\n\n设置缓存空间上限的时候采用`dispatch_barrier_async `栅栏方法, 我不知道作者为何这么写, 多此一举! 本来就是串行队列了, 就能够保证线程安全, 加`栅栏`方法没什么意义. 现在应该注意的不是线程安全, 而是`线程死锁`的问题. 所以在 API 接口中有个⚠️警告\n> @warning Do not read this property on the <sharedQueue> (including asynchronous method blocks).\n\n意思是不要在 `shareQueue` 和接口里面的任何 API 的异步 block 中去读这个属性, 为什么呢?  因为`TMDiskCache`所有的读写删除操作都是放在`Serial Queue`串行队列中的, 也就是`shareQueue`队列, 天啦噜...这不造成死锁才怪呢! 警告还写这么不明显.形如下面的是`错误❌`的用法:\n\n```Objc\n[diskCache removeObjectForKey:@\"profileKey\" block:^(TMDiskCache *cache, NSString *key, id<NSCoding> object, NSURL *fileURL) {\n        NSLog(@\"%ld\", diskCache.byteLimit);\n }];\n```\n\n因为在`removeObjectForKey`之类的方法中会同步执行传入的 block 操作, 如果在 block 里面再提交新的任务到串行队列中, 再同步执行, 必然死锁. 因为外层的 block 需要等待新提交的 block 执行完毕才能执行完成, 然而新提交的 block 需要等待外层 block 执行完才能执行, 两者相互依赖对方执行完才能执行完成, 就造成`死锁`了.   \n\n```Objc\nif (block)\n    block(strongSelf, key, nil, fileURL);\n``` \n上一篇分析了 `TMMemoryCache` 容易造成性能消耗严重, 而`TMDiskCache`使用不当容易造成`死锁.`\n\n### 各类 will / did block, 以及后台操作\n\nwill / did block 穿插在各类异步操作中, 非常简单, 看看即可.\n\n```Objc\nif (strongSelf->_willAddObjectBlock)\n    strongSelf->_willAddObjectBlock(strongSelf, key, object, fileURL);\n```\n其中后台操作有点意思, 创建一个全局的`后台管理者`遵守`TMCacheBackgroundTaskManager`协议, 实现其中的两个方法:\n\n```Objc\n- (UIBackgroundTaskIdentifier)beginBackgroundTask;\n- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier;\n```\n然后调用设置方法, 给 `TMDiskCache`对象设置后台管理者.\n\n```Objc\n+ (void)setBackgroundTaskManager:(id <TMCacheBackgroundTaskManager>)backgroundTaskManager;\n```\n在后台任务开始之前调用 `beginBackgroundTask` 方法, 结束后台任务之前调用 `endBackgroundTask`, 就能在后台管理者里面监听到什么时候进入后台操作, 什么时候结束后台操作了.\n具体做法:\n\n```Objc\nUIBackgroundTaskIdentifier taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];\n\ndispatch_async(_queue, ^{ \n      TMDiskCache *strongSelf = weakSelf;\n        if (!strongSelf) {\n            [TMCacheBackgroundTaskManager endBackgroundTask:taskID];\n            return;\n        }\n\n      // 执行后台任务\n      // 比如: 写缓存, 取缓存, 删除缓存等等.\n\n     [TMCacheBackgroundTaskManager endBackgroundTask:taskID];\n}\n```\n因为磁盘的操作可能耗时非常长, 不可能一直等待, 因此通过这种全局的方式来感知异步操作的开始和结束, 从而执行响应事件. \n\n### 清空临时存储区\n根据上面可以知道, 删除缓存文件的时候, 先会在`tmp`下创建\"回收目录\", 需要删除的缓存文件统一放进回收目录下, 下面是获取回收目录的URL 路径, 没有就创建, 有则返回, 只创建一次:\n\n```Objc\n+ (NSURL *)sharedTrashURL {\n    static NSURL *sharedTrashURL;\n    static dispatch_once_t predicate;\n    \n    dispatch_once(&predicate, ^{\n        sharedTrashURL = [[[NSURL alloc] initFileURLWithPath:NSTemporaryDirectory()] URLByAppendingPathComponent:TMDiskCachePrefix isDirectory:YES];\n        \n        if (![[NSFileManager defaultManager] fileExistsAtPath:[sharedTrashURL path]]) {\n            NSError *error = nil;\n            [[NSFileManager defaultManager] createDirectoryAtURL:sharedTrashURL\n                                     withIntermediateDirectories:YES\n                                                      attributes:nil\n                                                           error:&error];\n            TMDiskCacheError(error);\n        }\n    });\n    \n    return sharedTrashURL;\n}\n```\n\n创建一个清空操作专属的串行队列`TrashQueue`, 并且使用`dispatch_set_target_queue`方法修改`TrashQueue`的优先级, 并与全局并发队列`global_queue` 的后台优先级一致. 因为`tmp`目录的情况操作不是那么的重要, 即使我们不手动清除, 系统也会在恰当的时候清除, 所以这里把`TrashQueue`队列的优先级降低.\n\n```Objc\n+ (dispatch_queue_t)sharedTrashQueue {\n    static dispatch_queue_t trashQueue;\n    static dispatch_once_t predicate;\n    \n    dispatch_once(&predicate, ^{\n        NSString *queueName = [[NSString alloc] initWithFormat:@\"%@.trash\", TMDiskCachePrefix];\n        trashQueue = dispatch_queue_create([queueName UTF8String], DISPATCH_QUEUE_SERIAL);\n        dispatch_set_target_queue(trashQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));\n    });\n    \n    return trashQueue;\n}\n```\n\n类方法, 把原本在`Caches`下的缓存文件移动进`tmp`目录下的回收目录.\n\n```Objc\n+ (BOOL)moveItemAtURLToTrash:(NSURL *)itemURL {\n    if (![[NSFileManager defaultManager] fileExistsAtPath:[itemURL path]])\n        return NO;\n    \n    NSError *error = nil;\n    NSString *uniqueString = [[NSProcessInfo processInfo] globallyUniqueString];\n    NSURL *uniqueTrashURL = [[TMDiskCache sharedTrashURL] URLByAppendingPathComponent:uniqueString];\n    BOOL moved = [[NSFileManager defaultManager] moveItemAtURL:itemURL toURL:uniqueTrashURL error:&error];\n    TMDiskCacheError(error);\n    return moved;\n}\n```\n\n把清除操作添加到`TrashQueue`中异步执行, 在该方法中遍历回收目录下所有的缓存文件, 依次进行删除:\n\n```Objc\n+ (void)emptyTrash {\n    UIBackgroundTaskIdentifier taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];\n    \n    dispatch_async([self sharedTrashQueue], ^{\n        NSError *error = nil;\n        NSArray *trashedItems = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:[self sharedTrashURL]\n                                                              includingPropertiesForKeys:nil\n                                                                                 options:0\n                                                                                   error:&error];\n        TMDiskCacheError(error);\n        \n        for (NSURL *trashedItemURL in trashedItems) {\n            NSError *error = nil;\n            [[NSFileManager defaultManager] removeItemAtURL:trashedItemURL error:&error];\n            TMDiskCacheError(error);\n        }\n        \n        [TMCacheBackgroundTaskManager endBackgroundTask:taskID];\n    });\n}\n```\n\n其实我们只要看一下删除操作在哪里执行的, 就能明白为何作者要创建一个专门用于删除数据的串行队列了. `emptyTrash`方法调用是在读写操作的串行队列`queue`中, 方法调用后面还有`_didRemoveObjectBlock`等待执行, 如果删除数据量比较大且删除操作在`queue`中, 将阻塞当前线程, 那么`_didRemoveObjectBlock`会等待许久才能回调, 况且删除操作对于响应用户事件而言不是那么的重要, 所以把需要删除的缓存文件放进`tmp`目录下, 创建新的低优先级的串行队列来进行删除操作.  这点值得学习!\n\n```Objc\n[TMDiskCache emptyTrash];\n```\n\n### 总结\n1. 使用`TMDiskCache`姿势要正确, 否则容易造成`死锁`.\n2. 删除缓存的思路值得借鉴.  \n\n欢迎大家斧正!\n\n","slug":"TMCache源码分析之TMDiskCache磁盘缓存","published":1,"updated":"2017-02-27T16:34:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizozpebf0007k4exc8vvrusy","content":"<p><a href=\"https://chengzhipeng.github.io/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/\" target=\"_blank\" rel=\"external\">上篇分析</a>了 <code>TMCache</code>中内存缓存<code>TMMemoryCache</code>的实现原理, 这篇文章将详细分析磁盘缓存的实现原理.  </p>\n<p>磁盘缓存,顾名思义:将数据存储到磁盘上,由于需要储存的数据量比较大,所以一般读写速度都比内存缓存慢, 但也是非常重要的一项功能, 比如能够实现离线浏览等提升用户体验.  </p>\n<p>磁盘缓存的实现形式大致分为三种:</p>\n<ul>\n<li>基于文件读写.</li>\n<li>基于数据库.  </li>\n<li>基于 mmap 文件内存映射.</li>\n</ul>\n<a id=\"more\"></a>\n<p>前面两种使用的比较广泛, <code>SDWebImage</code>和<code>TMDiskCache</code>都是基于文件 I/O 进行存储的, 也就是一个 value 对应一个文件, 通过读写文件来缓存数据. 根据上篇可以知道<code>TMMemoryCache</code>内存缓存的主线是按照 key-value的形式把数据存进可变字典中, 那么磁盘缓存的主线也是按照 key-value的形式进行对应的, 只不过 value 对应的是一个文件, 换汤不换药.  </p>\n<p>通过<code>TMDiskCache</code>的接口 API 可以看到, <code>TMDiskCache</code>提供以下功能:  </p>\n<ul>\n<li>同步/异步的进行读写数据.</li>\n<li>同步/异步的进行删除数据.</li>\n<li>同步/异步的获取缓存路径.</li>\n<li>同步/异步的根据缓存时间或者缓存大小来削减磁盘空间.</li>\n<li>设置磁盘缓存空间上限, 磁盘缓存时间上限.</li>\n<li>各类 will / did block, 以及监听后台操作.</li>\n<li>清空临时存储区.</li>\n</ul>\n<p><code>TMDiskCache</code>的同步操作是跟<code>TMMemoryCache</code>操作一样,都是采用<code>dispatch_semaphore_t</code>信号量的形式来强制把异步转成同步操作,后面同步操作就一步带过,除非特别说明.   其实<code>TMDiskCache</code>的难点不在于线程安全,因为它所有的操作都在一个 serial queue 串行队列中, 不存在竞态情况, 难点在于文件的操作, 了解 Linux 文件系统操作的同学应该知道文件 I/O 的概念, iOS 封装了操作文件的类, 使用这些高级 API 能更好的操作文件.</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p>在操作之前先看一下<code>TMDiskCache</code>的初始化方法, 提供一个类方法, 两个实例方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedCache;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithName:(<span class=\"built_in\">NSString</span> *)name;</div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithName:(<span class=\"built_in\">NSString</span> *)name rootPath:(<span class=\"built_in\">NSString</span> *)rootPath;</div></pre></td></tr></table></figure>\n<p>从名字应该能猜测出最终调用的方法应该是<code>- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath</code>, 传磁盘缓存所在目录的名字和绝对路径, 如果调用前两个方法,在方法内部将默认设置好路径或者缓存文件夹名字. 我们主要看终极方法主要做了几件事:</p>\n<ul>\n<li>创建串行队列,是单例,即一个单例缓存对象有一个单例串行队列.</li>\n<li>初始化两个可变字典<code>_dates</code>, <code>_sizes</code>, 分别用于存数据最后操作时间和数据占用磁盘空间大小.</li>\n<li>创建缓存文件, 设置缓存文件操作时间.</li>\n</ul>\n<p>其余的比较简单, 这里主要说一下<code>设置缓存文件操作时间</code>的相关 API, 首先是处理 key 的方法, 这两个方法分别对传入的 key 进行编码和解码, 比如在调用<code>setObject:forKey:</code>的时候 key 值传入了中文字符, 就会调用<code>encodedString</code>和<code>decodedString</code>来编解码, 可以进入沙盒中看到对应的缓存文件名字是这类编码后的字符, 形如:<code>%E7%A8%8B%E5%85%88%E7%94%9F</code>.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)encodedString:(<span class=\"built_in\">NSString</span> *)string &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![string length])</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> charsToEscape = <span class=\"built_in\">CFSTR</span>(<span class=\"string\">\".:/\"</span>);</div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> escapedString = <span class=\"built_in\">CFURLCreateStringByAddingPercentEscapes</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                                        (__bridge <span class=\"built_in\">CFStringRef</span>)string,</div><div class=\"line\">                                                                        <span class=\"literal\">NULL</span>,</div><div class=\"line\">                                                                        charsToEscape,</div><div class=\"line\">                                                                        kCFStringEncodingUTF8);</div><div class=\"line\">    <span class=\"keyword\">return</span> (__bridge_transfer <span class=\"built_in\">NSString</span> *)escapedString;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)decodedString:(<span class=\"built_in\">NSString</span> *)string &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![string length])</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> unescapedString = <span class=\"built_in\">CFURLCreateStringByReplacingPercentEscapesUsingEncoding</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                                                          (__bridge <span class=\"built_in\">CFStringRef</span>)string,</div><div class=\"line\">                                                                                          <span class=\"built_in\">CFSTR</span>(<span class=\"string\">\"\"</span>),</div><div class=\"line\">                                                                                          kCFStringEncodingUTF8);</div><div class=\"line\">    <span class=\"keyword\">return</span> (__bridge_transfer <span class=\"built_in\">NSString</span> *)unescapedString;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个初始化设置方法, 只做了一件事:</p>\n<blockquote>\n<p>遍历缓存文件夹下面所有的已缓存的文件, 更新的操作时间数组<code>_dates</code>, 文件大小数组<code>_sizes</code>以及更新磁盘总使用大小.</p>\n</blockquote>\n<p>这么做的目的是什么呢?第一次创建磁盘缓存目录肯定是空的文件夹, 里面铁定没有缓存文件, 那为什么要遍历一次所有的缓存文件并更新其操作时间和大小呢? 其实是为了防止不小心再次调用<code>- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath</code>创建了一个名字和路径都相同的缓存目录, 避免里面已经缓存的数据<code>脱离控制</code>. 用心良苦呀!</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initializeDiskProperties &#123;</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> byteCount = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keys = @[ <span class=\"built_in\">NSURLContentModificationDateKey</span>, <span class=\"built_in\">NSURLTotalFileAllocatedSizeKey</span> ];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *files = [[<span class=\"built_in\">NSFileManager</span> defaultManager] contentsOfDirectoryAtURL:_cacheURL</div><div class=\"line\">                                                   includingPropertiesForKeys:keys</div><div class=\"line\">                                                                      options:<span class=\"built_in\">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class=\"line\">                                                                        error:&amp;error];</div><div class=\"line\">    TMDiskCacheError(error);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURL</span> *fileURL <span class=\"keyword\">in</span> files) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [<span class=\"keyword\">self</span> keyForEncodedFileURL:fileURL];</div><div class=\"line\">        </div><div class=\"line\">        error = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *dictionary = [fileURL resourceValuesForKeys:keys error:&amp;error];</div><div class=\"line\">        TMDiskCacheError(error);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSDate</span> *date = [dictionary objectForKey:<span class=\"built_in\">NSURLContentModificationDateKey</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (date &amp;&amp; key)</div><div class=\"line\">            [_dates setObject:date forKey:key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSNumber</span> *fileSize = [dictionary objectForKey:<span class=\"built_in\">NSURLTotalFileAllocatedSizeKey</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (fileSize) &#123;</div><div class=\"line\">            [_sizes setObject:fileSize forKey:key];</div><div class=\"line\">            byteCount += [fileSize unsignedIntegerValue];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (byteCount &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">self</span>.byteCount = byteCount; <span class=\"comment\">// atomic</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)keyForEncodedFileURL:(<span class=\"built_in\">NSURL</span> *)url &#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *fileName = [url lastPathComponent];</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fileName)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> decodedString:fileName];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由此看出, 对于缓存数据来说, <code>key 经过编码后设为缓存文件名,  value 经过归档后写入文件</code>.  </p>\n<p>至此, 所有的准备工作都基本做完, 下面开始存取数据了.</p>\n<h3 id=\"同步-异步的进行读写数据\"><a href=\"#同步-异步的进行读写数据\" class=\"headerlink\" title=\"同步/异步的进行读写数据\"></a>同步/异步的进行读写数据</h3><h4 id=\"异步的进行读写数据\"><a href=\"#异步的进行读写数据\" class=\"headerlink\" title=\"异步的进行读写数据\"></a>异步的进行读写数据</h4><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<p>先来看看写操作如何实现的, 我就不贴源码具体实现了, 省的看的费劲, 只看关键部位吧~~~你懂的, 嘻嘻.</p>\n<h5 id=\"写入缓存\"><a href=\"#写入缓存\" class=\"headerlink\" title=\"写入缓存\"></a>写入缓存</h5><ol>\n<li><p>写操作被 commit 到串行队列中, 保证了写缓存的时候线程安全:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(_queue, ^&#123; </div><div class=\"line\">    <span class=\"comment\">// 写操作</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>将传入的对象进行归档处理, 所以要缓存的对象一定要遵守<code>NSCoding</code>协议, 并实现相关方法:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> written = [<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:object toFile:[fileURL path]];</div></pre></td></tr></table></figure>\n</li>\n<li><p>更新缓存文件的修改时间, 不管是新加入的缓存数据还是已有的缓存数据进行更新, 都会修改对应的时间为当前时间:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[strongSelf setFileModificationDate:now forURL:fileURL];</div></pre></td></tr></table></figure>\n</li>\n<li><p>下面是针对缓存空间大小的处理, 比较重要的一步, 根据最新缓存的数据更新总共已经使用的磁盘空间大小, 如果超过预设磁盘空间上限, 则需要删除一些数据以达到不超过上限的目的, 那以什么规则来删除超过缓存上限的部分数据呢? <code>TMMemoryCache</code>的优化策略是根据操作时间的先后顺序, 即操作时间早的数据, 认为你使用的概率比较低, 所以就优先删除掉, <code>TMDiskCache</code>优化策略跟<code>TMMemoryCache</code>相同, 先删除最早的数据. 这也是以文件系统的形式缓存数据的缺点, 不能进行有效的算法.</p>\n<ul>\n<li><p>更新缓存空间大小.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSNumber</span> *oldEntry = [strongSelf-&gt;_sizes objectForKey:key];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ([oldEntry isKindOfClass:[<span class=\"built_in\">NSNumber</span> <span class=\"keyword\">class</span>]])&#123;</div><div class=\"line\">    strongSelf.byteCount = strongSelf-&gt;_byteCount - [oldEntry unsignedIntegerValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[strongSelf-&gt;_sizes setObject:diskFileSize forKey:key];</div><div class=\"line\">strongSelf.byteCount = strongSelf-&gt;_byteCount + [diskFileSize unsignedIntegerValue]; <span class=\"comment\">// atomic</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>删除超出部分空间的缓存数据.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (strongSelf-&gt;_byteLimit &gt; <span class=\"number\">0</span> &amp;&amp; strongSelf-&gt;_byteCount &gt; strongSelf-&gt;_byteLimit)</div><div class=\"line\">               [strongSelf trimToSizeByDate:strongSelf-&gt;_byteLimit block:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>至此异步写入缓存数据完成, 注意:</p>\n<blockquote>\n<p><code>_dates</code>, <code>_sizes</code>中的 key 并没有经过编码, 只有缓存文件名才是经过编码的.</p>\n</blockquote>\n<h5 id=\"读取缓存\"><a href=\"#读取缓存\" class=\"headerlink\" title=\"读取缓存\"></a>读取缓存</h5><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCoding</span>&gt;)objectForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<p>也是看看异步的读取缓存, 根据上面写入缓存的步骤可以推测读取的步骤, 无非就是把 key 进行编码, 找到缓存文件, 再解档缓存文件内容, 最后更新操作时间, 主线就这几步, 其余的就是加点”配料” - will / did block 之类的时序控制类操作.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(_queue, ^&#123;</div><div class=\"line\">        TMDiskCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSURL</span> *fileURL = [strongSelf encodedFileURLForKey:key];</div><div class=\"line\">        <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCoding</span>&gt; object = <span class=\"literal\">nil</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]]) &#123;</div><div class=\"line\">            <span class=\"keyword\">@try</span> &#123;</div><div class=\"line\">                object = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:[fileURL path]];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">@catch</span> (<span class=\"built_in\">NSException</span> *exception) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">                [[<span class=\"built_in\">NSFileManager</span> defaultManager] removeItemAtPath:[fileURL path] error:&amp;error];</div><div class=\"line\">                TMDiskCacheError(error);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            [strongSelf setFileModificationDate:now forURL:fileURL];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        block(strongSelf, key, object, fileURL);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>代码中通过<code>@ try</code>, <code>@catch</code>抛出异常, 如果解档缓存文件内容失败, 直接删除该缓存文件, 简单不做作, 直接了当! 额, 也许不近人情, 好歹你告诉我错误信息是什么, 让我来决定删不删嘛. </p>\n<h4 id=\"同步的写入-读取缓存\"><a href=\"#同步的写入-读取缓存\" class=\"headerlink\" title=\"同步的写入/读取缓存\"></a>同步的写入/读取缓存</h4><p>都是采用<code>dispatch_semaphore_t</code>信号量的形式来实现的.</p>\n<h3 id=\"同步-异步的进行删除数据\"><a href=\"#同步-异步的进行删除数据\" class=\"headerlink\" title=\"同步/异步的进行删除数据\"></a>同步/异步的进行删除数据</h3><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<p>我们只分析异步的删除缓存数据, 同步的跟其它同步操作一样.<br>既然知道怎么写入缓存, 那删除应该也没什么问题了, 找到要删除的文件路径, 删除该缓存文件即可. 所以步骤应该是:</p>\n<ol>\n<li>key 进行编码, 再拼接成完整的缓存文件的绝对路径.</li>\n<li>删除文件, 其中删除文件做了特殊的步骤, 但是不影响整个删除流程, 后面会讲解.</li>\n<li>删除<code>_dates</code>,<code>_sizes</code>中的键值对, 更新总用使用的缓存空间大小.</li>\n</ol>\n<blockquote>\n<p>注意删除文件的时候并没有直接删除, 而是把待删除文件移到临时目录 <code>tmp</code>下的缓存目录里, 创建了一个新的串行队列进行删除操作.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> trashed = [TMDiskCache moveItemAtURLToTrash:fileURL];</div><div class=\"line\"><span class=\"keyword\">if</span> (!trashed)</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\"></div><div class=\"line\">[TMDiskCache emptyTrash];</div></pre></td></tr></table></figure>\n<h3 id=\"同步-异步的获取缓存路径\"><a href=\"#同步-异步的获取缓存路径\" class=\"headerlink\" title=\"同步/异步的获取缓存路径\"></a>同步/异步的获取缓存路径</h3><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)fileURLForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div><div class=\"line\">- (<span class=\"built_in\">NSURL</span> *)fileURLForKey:(<span class=\"built_in\">NSString</span> *)key;</div></pre></td></tr></table></figure>\n<p>实现非常简单:</p>\n<ol>\n<li>对 key 进行编码, 拼接完整缓存文件路径.</li>\n<li>更新缓存文件操作时间.</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSURL</span> *fileURL = [strongSelf encodedFileURLForKey:key];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]]) &#123;</div><div class=\"line\">    [strongSelf setFileModificationDate:now forURL:fileURL];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    fileURL = <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"同步-异步的根据缓存时间或者缓存大小来削减磁盘空间\"><a href=\"#同步-异步的根据缓存时间或者缓存大小来削减磁盘空间\" class=\"headerlink\" title=\"同步/异步的根据缓存时间或者缓存大小来削减磁盘空间\"></a>同步/异步的根据缓存时间或者缓存大小来削减磁盘空间</h3><p>这部分操作跟<code>TMMemoryCache</code>的实现类似, 相关 API: </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToDate:(<span class=\"built_in\">NSDate</span> *)date;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToDate:(<span class=\"built_in\">NSDate</span> *)date block:(TMDiskCacheBlock)block;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSize:(<span class=\"built_in\">NSUInteger</span>)byteCount;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSize:(<span class=\"built_in\">NSUInteger</span>)byteCount block:(TMDiskCacheBlock)block;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSizeByDate:(<span class=\"built_in\">NSUInteger</span>)byteCount;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSizeByDate:(<span class=\"built_in\">NSUInteger</span>)byteCount block:(TMDiskCacheBlock)block;</div></pre></td></tr></table></figure>\n<p>第一组, 根据缓存时间来削减缓存空间, 如果缓存数据的缓存时间超过了设置的<code>date</code>, 则会被删除.<br>第二组, 根据缓存大小来削减缓存空间, 如果缓存数据的缓存大小超过了指定的<code>byteCount</code>, 则会被删除.<br>第三组, 根据操作时间的先后顺序, 来削减超过了指定缓存大小的空间.</p>\n<p>实现大致都相同, 无非就是对时间进行排序, 然后把 key 进行编码, 拼接路径, 移动缓存文件到 tmp目录下, 再清空 tmp 目录. 注意一点, 无论是按照缓存时间还是缓存大小, 都是升序排序, 最先删除的都是<code>最早的或最小的</code>数据.</p>\n<h3 id=\"设置磁盘缓存空间上限-磁盘缓存时间上限\"><a href=\"#设置磁盘缓存空间上限-磁盘缓存时间上限\" class=\"headerlink\" title=\"设置磁盘缓存空间上限, 磁盘缓存时间上限\"></a>设置磁盘缓存空间上限, 磁盘缓存时间上限</h3><p>源码实现:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)byteLimit &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSUInteger</span> byteLimit = <span class=\"number\">0</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_queue, ^&#123;</div><div class=\"line\">        byteLimit = _byteLimit;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> byteLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setByteLimit:(<span class=\"built_in\">NSUInteger</span>)byteLimit &#123;</div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMDiskCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\">    </div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMDiskCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        strongSelf-&gt;_byteLimit = byteLimit;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (byteLimit &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            [strongSelf trimDiskToSizeByDate:byteLimit];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置缓存空间上限的时候采用<code>dispatch_barrier_async</code>栅栏方法, 我不知道作者为何这么写, 多此一举! 本来就是串行队列了, 就能够保证线程安全, 加<code>栅栏</code>方法没什么意义. 现在应该注意的不是线程安全, 而是<code>线程死锁</code>的问题. 所以在 API 接口中有个⚠️警告</p>\n<blockquote>\n<p>@warning Do not read this property on the <sharedqueue> (including asynchronous method blocks).</sharedqueue></p>\n</blockquote>\n<p>意思是不要在 <code>shareQueue</code> 和接口里面的任何 API 的异步 block 中去读这个属性, 为什么呢?  因为<code>TMDiskCache</code>所有的读写删除操作都是放在<code>Serial Queue</code>串行队列中的, 也就是<code>shareQueue</code>队列, 天啦噜…这不造成死锁才怪呢! 警告还写这么不明显.形如下面的是<code>错误❌</code>的用法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[diskCache removeObjectForKey:<span class=\"string\">@\"profileKey\"</span> block:^(TMDiskCache *cache, <span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt; object, <span class=\"built_in\">NSURL</span> *fileURL) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, diskCache.byteLimit);</div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure>\n<p>因为在<code>removeObjectForKey</code>之类的方法中会同步执行传入的 block 操作, 如果在 block 里面再提交新的任务到串行队列中, 再同步执行, 必然死锁. 因为外层的 block 需要等待新提交的 block 执行完毕才能执行完成, 然而新提交的 block 需要等待外层 block 执行完才能执行, 两者相互依赖对方执行完才能执行完成, 就造成<code>死锁</code>了.   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (block)</div><div class=\"line\">    block(strongSelf, key, <span class=\"literal\">nil</span>, fileURL);</div><div class=\"line\">``` </div><div class=\"line\">上一篇分析了 `TMMemoryCache` 容易造成性能消耗严重, 而`TMDiskCache`使用不当容易造成`死锁.`</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">### 各类 will / did block, 以及后台操作</span></div><div class=\"line\"></div><div class=\"line\">will / did block 穿插在各类异步操作中, 非常简单, 看看即可.</div><div class=\"line\"></div><div class=\"line\">```Objc</div><div class=\"line\"><span class=\"keyword\">if</span> (strongSelf-&gt;_willAddObjectBlock)</div><div class=\"line\">    strongSelf-&gt;_willAddObjectBlock(strongSelf, key, object, fileURL);</div></pre></td></tr></table></figure>\n<p>其中后台操作有点意思, 创建一个全局的<code>后台管理者</code>遵守<code>TMCacheBackgroundTaskManager</code>协议, 实现其中的两个方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIBackgroundTaskIdentifier</span>)beginBackgroundTask;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)endBackgroundTask:(<span class=\"built_in\">UIBackgroundTaskIdentifier</span>)identifier;</div></pre></td></tr></table></figure>\n<p>然后调用设置方法, 给 <code>TMDiskCache</code>对象设置后台管理者.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)setBackgroundTaskManager:(<span class=\"keyword\">id</span> &lt;TMCacheBackgroundTaskManager&gt;)backgroundTaskManager;</div></pre></td></tr></table></figure>\n<p>在后台任务开始之前调用 <code>beginBackgroundTask</code> 方法, 结束后台任务之前调用 <code>endBackgroundTask</code>, 就能在后台管理者里面监听到什么时候进入后台操作, 什么时候结束后台操作了.<br>具体做法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIBackgroundTaskIdentifier</span> taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(_queue, ^&#123; </div><div class=\"line\">      TMDiskCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf) &#123;</div><div class=\"line\">            [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 执行后台任务</span></div><div class=\"line\">      <span class=\"comment\">// 比如: 写缓存, 取缓存, 删除缓存等等.</span></div><div class=\"line\"></div><div class=\"line\">     [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为磁盘的操作可能耗时非常长, 不可能一直等待, 因此通过这种全局的方式来感知异步操作的开始和结束, 从而执行响应事件. </p>\n<h3 id=\"清空临时存储区\"><a href=\"#清空临时存储区\" class=\"headerlink\" title=\"清空临时存储区\"></a>清空临时存储区</h3><p>根据上面可以知道, 删除缓存文件的时候, 先会在<code>tmp</code>下创建”回收目录”, 需要删除的缓存文件统一放进回收目录下, 下面是获取回收目录的URL 路径, 没有就创建, 有则返回, 只创建一次:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">NSURL</span> *)sharedTrashURL &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSURL</span> *sharedTrashURL;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> predicate;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;predicate, ^&#123;</div><div class=\"line\">        sharedTrashURL = [[[<span class=\"built_in\">NSURL</span> alloc] initFileURLWithPath:<span class=\"built_in\">NSTemporaryDirectory</span>()] URLByAppendingPathComponent:TMDiskCachePrefix isDirectory:<span class=\"literal\">YES</span>];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[sharedTrashURL path]]) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">            [[<span class=\"built_in\">NSFileManager</span> defaultManager] createDirectoryAtURL:sharedTrashURL</div><div class=\"line\">                                     withIntermediateDirectories:<span class=\"literal\">YES</span></div><div class=\"line\">                                                      attributes:<span class=\"literal\">nil</span></div><div class=\"line\">                                                           error:&amp;error];</div><div class=\"line\">            TMDiskCacheError(error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> sharedTrashURL;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个清空操作专属的串行队列<code>TrashQueue</code>, 并且使用<code>dispatch_set_target_queue</code>方法修改<code>TrashQueue</code>的优先级, 并与全局并发队列<code>global_queue</code> 的后台优先级一致. 因为<code>tmp</code>目录的情况操作不是那么的重要, 即使我们不手动清除, 系统也会在恰当的时候清除, 所以这里把<code>TrashQueue</code>队列的优先级降低.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">dispatch_queue_t</span>)sharedTrashQueue &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_queue_t</span> trashQueue;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> predicate;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;predicate, ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *queueName = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"%@.trash\"</span>, TMDiskCachePrefix];</div><div class=\"line\">        trashQueue = dispatch_queue_create([queueName UTF8String], DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">        dispatch_set_target_queue(trashQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>));</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> trashQueue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类方法, 把原本在<code>Caches</code>下的缓存文件移动进<code>tmp</code>目录下的回收目录.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)moveItemAtURLToTrash:(<span class=\"built_in\">NSURL</span> *)itemURL &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[itemURL path]])</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *uniqueString = [[<span class=\"built_in\">NSProcessInfo</span> processInfo] globallyUniqueString];</div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *uniqueTrashURL = [[TMDiskCache sharedTrashURL] URLByAppendingPathComponent:uniqueString];</div><div class=\"line\">    <span class=\"built_in\">BOOL</span> moved = [[<span class=\"built_in\">NSFileManager</span> defaultManager] moveItemAtURL:itemURL toURL:uniqueTrashURL error:&amp;error];</div><div class=\"line\">    TMDiskCacheError(error);</div><div class=\"line\">    <span class=\"keyword\">return</span> moved;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把清除操作添加到<code>TrashQueue</code>中异步执行, 在该方法中遍历回收目录下所有的缓存文件, 依次进行删除:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)emptyTrash &#123;</div><div class=\"line\">    <span class=\"built_in\">UIBackgroundTaskIdentifier</span> taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>([<span class=\"keyword\">self</span> sharedTrashQueue], ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"built_in\">NSArray</span> *trashedItems = [[<span class=\"built_in\">NSFileManager</span> defaultManager] contentsOfDirectoryAtURL:[<span class=\"keyword\">self</span> sharedTrashURL]</div><div class=\"line\">                                                              includingPropertiesForKeys:<span class=\"literal\">nil</span></div><div class=\"line\">                                                                                 options:<span class=\"number\">0</span></div><div class=\"line\">                                                                                   error:&amp;error];</div><div class=\"line\">        TMDiskCacheError(error);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURL</span> *trashedItemURL <span class=\"keyword\">in</span> trashedItems) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">            [[<span class=\"built_in\">NSFileManager</span> defaultManager] removeItemAtURL:trashedItemURL error:&amp;error];</div><div class=\"line\">            TMDiskCacheError(error);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实我们只要看一下删除操作在哪里执行的, 就能明白为何作者要创建一个专门用于删除数据的串行队列了. <code>emptyTrash</code>方法调用是在读写操作的串行队列<code>queue</code>中, 方法调用后面还有<code>_didRemoveObjectBlock</code>等待执行, 如果删除数据量比较大且删除操作在<code>queue</code>中, 将阻塞当前线程, 那么<code>_didRemoveObjectBlock</code>会等待许久才能回调, 况且删除操作对于响应用户事件而言不是那么的重要, 所以把需要删除的缓存文件放进<code>tmp</code>目录下, 创建新的低优先级的串行队列来进行删除操作.  这点值得学习!</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[TMDiskCache emptyTrash];</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>使用<code>TMDiskCache</code>姿势要正确, 否则容易造成<code>死锁</code>.</li>\n<li>删除缓存的思路值得借鉴.  </li>\n</ol>\n<p>欢迎大家斧正!</p>\n","excerpt":"<p><a href=\"https://chengzhipeng.github.io/2016/02/27/TMCache源码分析之TMMemoryCache内存缓存/\">上篇分析</a>了 <code>TMCache</code>中内存缓存<code>TMMemoryCache</code>的实现原理, 这篇文章将详细分析磁盘缓存的实现原理.  </p>\n<p>磁盘缓存,顾名思义:将数据存储到磁盘上,由于需要储存的数据量比较大,所以一般读写速度都比内存缓存慢, 但也是非常重要的一项功能, 比如能够实现离线浏览等提升用户体验.  </p>\n<p>磁盘缓存的实现形式大致分为三种:</p>\n<ul>\n<li>基于文件读写.</li>\n<li>基于数据库.  </li>\n<li>基于 mmap 文件内存映射.</li>\n</ul>","more":"<p>前面两种使用的比较广泛, <code>SDWebImage</code>和<code>TMDiskCache</code>都是基于文件 I/O 进行存储的, 也就是一个 value 对应一个文件, 通过读写文件来缓存数据. 根据上篇可以知道<code>TMMemoryCache</code>内存缓存的主线是按照 key-value的形式把数据存进可变字典中, 那么磁盘缓存的主线也是按照 key-value的形式进行对应的, 只不过 value 对应的是一个文件, 换汤不换药.  </p>\n<p>通过<code>TMDiskCache</code>的接口 API 可以看到, <code>TMDiskCache</code>提供以下功能:  </p>\n<ul>\n<li>同步/异步的进行读写数据.</li>\n<li>同步/异步的进行删除数据.</li>\n<li>同步/异步的获取缓存路径.</li>\n<li>同步/异步的根据缓存时间或者缓存大小来削减磁盘空间.</li>\n<li>设置磁盘缓存空间上限, 磁盘缓存时间上限.</li>\n<li>各类 will / did block, 以及监听后台操作.</li>\n<li>清空临时存储区.</li>\n</ul>\n<p><code>TMDiskCache</code>的同步操作是跟<code>TMMemoryCache</code>操作一样,都是采用<code>dispatch_semaphore_t</code>信号量的形式来强制把异步转成同步操作,后面同步操作就一步带过,除非特别说明.   其实<code>TMDiskCache</code>的难点不在于线程安全,因为它所有的操作都在一个 serial queue 串行队列中, 不存在竞态情况, 难点在于文件的操作, 了解 Linux 文件系统操作的同学应该知道文件 I/O 的概念, iOS 封装了操作文件的类, 使用这些高级 API 能更好的操作文件.</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p>在操作之前先看一下<code>TMDiskCache</code>的初始化方法, 提供一个类方法, 两个实例方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>)sharedCache;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithName:(<span class=\"built_in\">NSString</span> *)name;</div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithName:(<span class=\"built_in\">NSString</span> *)name rootPath:(<span class=\"built_in\">NSString</span> *)rootPath;</div></pre></td></tr></table></figure>\n<p>从名字应该能猜测出最终调用的方法应该是<code>- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath</code>, 传磁盘缓存所在目录的名字和绝对路径, 如果调用前两个方法,在方法内部将默认设置好路径或者缓存文件夹名字. 我们主要看终极方法主要做了几件事:</p>\n<ul>\n<li>创建串行队列,是单例,即一个单例缓存对象有一个单例串行队列.</li>\n<li>初始化两个可变字典<code>_dates</code>, <code>_sizes</code>, 分别用于存数据最后操作时间和数据占用磁盘空间大小.</li>\n<li>创建缓存文件, 设置缓存文件操作时间.</li>\n</ul>\n<p>其余的比较简单, 这里主要说一下<code>设置缓存文件操作时间</code>的相关 API, 首先是处理 key 的方法, 这两个方法分别对传入的 key 进行编码和解码, 比如在调用<code>setObject:forKey:</code>的时候 key 值传入了中文字符, 就会调用<code>encodedString</code>和<code>decodedString</code>来编解码, 可以进入沙盒中看到对应的缓存文件名字是这类编码后的字符, 形如:<code>%E7%A8%8B%E5%85%88%E7%94%9F</code>.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)encodedString:(<span class=\"built_in\">NSString</span> *)string &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![string length])</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> charsToEscape = <span class=\"built_in\">CFSTR</span>(<span class=\"string\">\".:/\"</span>);</div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> escapedString = <span class=\"built_in\">CFURLCreateStringByAddingPercentEscapes</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                                        (__bridge <span class=\"built_in\">CFStringRef</span>)string,</div><div class=\"line\">                                                                        <span class=\"literal\">NULL</span>,</div><div class=\"line\">                                                                        charsToEscape,</div><div class=\"line\">                                                                        kCFStringEncodingUTF8);</div><div class=\"line\">    <span class=\"keyword\">return</span> (__bridge_transfer <span class=\"built_in\">NSString</span> *)escapedString;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)decodedString:(<span class=\"built_in\">NSString</span> *)string &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![string length])</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> unescapedString = <span class=\"built_in\">CFURLCreateStringByReplacingPercentEscapesUsingEncoding</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                                                          (__bridge <span class=\"built_in\">CFStringRef</span>)string,</div><div class=\"line\">                                                                                          <span class=\"built_in\">CFSTR</span>(<span class=\"string\">\"\"</span>),</div><div class=\"line\">                                                                                          kCFStringEncodingUTF8);</div><div class=\"line\">    <span class=\"keyword\">return</span> (__bridge_transfer <span class=\"built_in\">NSString</span> *)unescapedString;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个初始化设置方法, 只做了一件事:</p>\n<blockquote>\n<p>遍历缓存文件夹下面所有的已缓存的文件, 更新的操作时间数组<code>_dates</code>, 文件大小数组<code>_sizes</code>以及更新磁盘总使用大小.</p>\n</blockquote>\n<p>这么做的目的是什么呢?第一次创建磁盘缓存目录肯定是空的文件夹, 里面铁定没有缓存文件, 那为什么要遍历一次所有的缓存文件并更新其操作时间和大小呢? 其实是为了防止不小心再次调用<code>- (instancetype)initWithName:(NSString *)name rootPath:(NSString *)rootPath</code>创建了一个名字和路径都相同的缓存目录, 避免里面已经缓存的数据<code>脱离控制</code>. 用心良苦呀!</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initializeDiskProperties &#123;</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> byteCount = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keys = @[ <span class=\"built_in\">NSURLContentModificationDateKey</span>, <span class=\"built_in\">NSURLTotalFileAllocatedSizeKey</span> ];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *files = [[<span class=\"built_in\">NSFileManager</span> defaultManager] contentsOfDirectoryAtURL:_cacheURL</div><div class=\"line\">                                                   includingPropertiesForKeys:keys</div><div class=\"line\">                                                                      options:<span class=\"built_in\">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class=\"line\">                                                                        error:&amp;error];</div><div class=\"line\">    TMDiskCacheError(error);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURL</span> *fileURL <span class=\"keyword\">in</span> files) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [<span class=\"keyword\">self</span> keyForEncodedFileURL:fileURL];</div><div class=\"line\">        </div><div class=\"line\">        error = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *dictionary = [fileURL resourceValuesForKeys:keys error:&amp;error];</div><div class=\"line\">        TMDiskCacheError(error);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSDate</span> *date = [dictionary objectForKey:<span class=\"built_in\">NSURLContentModificationDateKey</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (date &amp;&amp; key)</div><div class=\"line\">            [_dates setObject:date forKey:key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSNumber</span> *fileSize = [dictionary objectForKey:<span class=\"built_in\">NSURLTotalFileAllocatedSizeKey</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (fileSize) &#123;</div><div class=\"line\">            [_sizes setObject:fileSize forKey:key];</div><div class=\"line\">            byteCount += [fileSize unsignedIntegerValue];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (byteCount &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">self</span>.byteCount = byteCount; <span class=\"comment\">// atomic</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)keyForEncodedFileURL:(<span class=\"built_in\">NSURL</span> *)url &#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *fileName = [url lastPathComponent];</div><div class=\"line\">    <span class=\"keyword\">if</span> (!fileName)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> decodedString:fileName];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由此看出, 对于缓存数据来说, <code>key 经过编码后设为缓存文件名,  value 经过归档后写入文件</code>.  </p>\n<p>至此, 所有的准备工作都基本做完, 下面开始存取数据了.</p>\n<h3 id=\"同步-异步的进行读写数据\"><a href=\"#同步-异步的进行读写数据\" class=\"headerlink\" title=\"同步/异步的进行读写数据\"></a>同步/异步的进行读写数据</h3><h4 id=\"异步的进行读写数据\"><a href=\"#异步的进行读写数据\" class=\"headerlink\" title=\"异步的进行读写数据\"></a>异步的进行读写数据</h4><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCoding</span>&gt;)object forKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<p>先来看看写操作如何实现的, 我就不贴源码具体实现了, 省的看的费劲, 只看关键部位吧~~~你懂的, 嘻嘻.</p>\n<h5 id=\"写入缓存\"><a href=\"#写入缓存\" class=\"headerlink\" title=\"写入缓存\"></a>写入缓存</h5><ol>\n<li><p>写操作被 commit 到串行队列中, 保证了写缓存的时候线程安全:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(_queue, ^&#123; </div><div class=\"line\">    <span class=\"comment\">// 写操作</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>将传入的对象进行归档处理, 所以要缓存的对象一定要遵守<code>NSCoding</code>协议, 并实现相关方法:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> written = [<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:object toFile:[fileURL path]];</div></pre></td></tr></table></figure>\n</li>\n<li><p>更新缓存文件的修改时间, 不管是新加入的缓存数据还是已有的缓存数据进行更新, 都会修改对应的时间为当前时间:</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[strongSelf setFileModificationDate:now forURL:fileURL];</div></pre></td></tr></table></figure>\n</li>\n<li><p>下面是针对缓存空间大小的处理, 比较重要的一步, 根据最新缓存的数据更新总共已经使用的磁盘空间大小, 如果超过预设磁盘空间上限, 则需要删除一些数据以达到不超过上限的目的, 那以什么规则来删除超过缓存上限的部分数据呢? <code>TMMemoryCache</code>的优化策略是根据操作时间的先后顺序, 即操作时间早的数据, 认为你使用的概率比较低, 所以就优先删除掉, <code>TMDiskCache</code>优化策略跟<code>TMMemoryCache</code>相同, 先删除最早的数据. 这也是以文件系统的形式缓存数据的缺点, 不能进行有效的算法.</p>\n<ul>\n<li><p>更新缓存空间大小.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSNumber</span> *oldEntry = [strongSelf-&gt;_sizes objectForKey:key];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ([oldEntry isKindOfClass:[<span class=\"built_in\">NSNumber</span> <span class=\"keyword\">class</span>]])&#123;</div><div class=\"line\">    strongSelf.byteCount = strongSelf-&gt;_byteCount - [oldEntry unsignedIntegerValue];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[strongSelf-&gt;_sizes setObject:diskFileSize forKey:key];</div><div class=\"line\">strongSelf.byteCount = strongSelf-&gt;_byteCount + [diskFileSize unsignedIntegerValue]; <span class=\"comment\">// atomic</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>删除超出部分空间的缓存数据.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (strongSelf-&gt;_byteLimit &gt; <span class=\"number\">0</span> &amp;&amp; strongSelf-&gt;_byteCount &gt; strongSelf-&gt;_byteLimit)</div><div class=\"line\">               [strongSelf trimToSizeByDate:strongSelf-&gt;_byteLimit block:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>至此异步写入缓存数据完成, 注意:</p>\n<blockquote>\n<p><code>_dates</code>, <code>_sizes</code>中的 key 并没有经过编码, 只有缓存文件名才是经过编码的.</p>\n</blockquote>\n<h5 id=\"读取缓存\"><a href=\"#读取缓存\" class=\"headerlink\" title=\"读取缓存\"></a>读取缓存</h5><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCoding</span>&gt;)objectForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<p>也是看看异步的读取缓存, 根据上面写入缓存的步骤可以推测读取的步骤, 无非就是把 key 进行编码, 找到缓存文件, 再解档缓存文件内容, 最后更新操作时间, 主线就这几步, 其余的就是加点”配料” - will / did block 之类的时序控制类操作.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(_queue, ^&#123;</div><div class=\"line\">        TMDiskCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">NSURL</span> *fileURL = [strongSelf encodedFileURLForKey:key];</div><div class=\"line\">        <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSCoding</span>&gt; object = <span class=\"literal\">nil</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]]) &#123;</div><div class=\"line\">            <span class=\"keyword\">@try</span> &#123;</div><div class=\"line\">                object = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:[fileURL path]];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">@catch</span> (<span class=\"built_in\">NSException</span> *exception) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">                [[<span class=\"built_in\">NSFileManager</span> defaultManager] removeItemAtPath:[fileURL path] error:&amp;error];</div><div class=\"line\">                TMDiskCacheError(error);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            [strongSelf setFileModificationDate:now forURL:fileURL];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        block(strongSelf, key, object, fileURL);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>代码中通过<code>@ try</code>, <code>@catch</code>抛出异常, 如果解档缓存文件内容失败, 直接删除该缓存文件, 简单不做作, 直接了当! 额, 也许不近人情, 好歹你告诉我错误信息是什么, 让我来决定删不删嘛. </p>\n<h4 id=\"同步的写入-读取缓存\"><a href=\"#同步的写入-读取缓存\" class=\"headerlink\" title=\"同步的写入/读取缓存\"></a>同步的写入/读取缓存</h4><p>都是采用<code>dispatch_semaphore_t</code>信号量的形式来实现的.</p>\n<h3 id=\"同步-异步的进行删除数据\"><a href=\"#同步-异步的进行删除数据\" class=\"headerlink\" title=\"同步/异步的进行删除数据\"></a>同步/异步的进行删除数据</h3><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<p>我们只分析异步的删除缓存数据, 同步的跟其它同步操作一样.<br>既然知道怎么写入缓存, 那删除应该也没什么问题了, 找到要删除的文件路径, 删除该缓存文件即可. 所以步骤应该是:</p>\n<ol>\n<li>key 进行编码, 再拼接成完整的缓存文件的绝对路径.</li>\n<li>删除文件, 其中删除文件做了特殊的步骤, 但是不影响整个删除流程, 后面会讲解.</li>\n<li>删除<code>_dates</code>,<code>_sizes</code>中的键值对, 更新总用使用的缓存空间大小.</li>\n</ol>\n<blockquote>\n<p>注意删除文件的时候并没有直接删除, 而是把待删除文件移到临时目录 <code>tmp</code>下的缓存目录里, 创建了一个新的串行队列进行删除操作.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> trashed = [TMDiskCache moveItemAtURLToTrash:fileURL];</div><div class=\"line\"><span class=\"keyword\">if</span> (!trashed)</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\"></div><div class=\"line\">[TMDiskCache emptyTrash];</div></pre></td></tr></table></figure>\n<h3 id=\"同步-异步的获取缓存路径\"><a href=\"#同步-异步的获取缓存路径\" class=\"headerlink\" title=\"同步/异步的获取缓存路径\"></a>同步/异步的获取缓存路径</h3><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)fileURLForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMDiskCacheObjectBlock)block;</div><div class=\"line\">- (<span class=\"built_in\">NSURL</span> *)fileURLForKey:(<span class=\"built_in\">NSString</span> *)key;</div></pre></td></tr></table></figure>\n<p>实现非常简单:</p>\n<ol>\n<li>对 key 进行编码, 拼接完整缓存文件路径.</li>\n<li>更新缓存文件操作时间.</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSURL</span> *fileURL = [strongSelf encodedFileURLForKey:key];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]]) &#123;</div><div class=\"line\">    [strongSelf setFileModificationDate:now forURL:fileURL];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    fileURL = <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"同步-异步的根据缓存时间或者缓存大小来削减磁盘空间\"><a href=\"#同步-异步的根据缓存时间或者缓存大小来削减磁盘空间\" class=\"headerlink\" title=\"同步/异步的根据缓存时间或者缓存大小来削减磁盘空间\"></a>同步/异步的根据缓存时间或者缓存大小来削减磁盘空间</h3><p>这部分操作跟<code>TMMemoryCache</code>的实现类似, 相关 API: </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToDate:(<span class=\"built_in\">NSDate</span> *)date;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToDate:(<span class=\"built_in\">NSDate</span> *)date block:(TMDiskCacheBlock)block;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSize:(<span class=\"built_in\">NSUInteger</span>)byteCount;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSize:(<span class=\"built_in\">NSUInteger</span>)byteCount block:(TMDiskCacheBlock)block;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSizeByDate:(<span class=\"built_in\">NSUInteger</span>)byteCount;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToSizeByDate:(<span class=\"built_in\">NSUInteger</span>)byteCount block:(TMDiskCacheBlock)block;</div></pre></td></tr></table></figure>\n<p>第一组, 根据缓存时间来削减缓存空间, 如果缓存数据的缓存时间超过了设置的<code>date</code>, 则会被删除.<br>第二组, 根据缓存大小来削减缓存空间, 如果缓存数据的缓存大小超过了指定的<code>byteCount</code>, 则会被删除.<br>第三组, 根据操作时间的先后顺序, 来削减超过了指定缓存大小的空间.</p>\n<p>实现大致都相同, 无非就是对时间进行排序, 然后把 key 进行编码, 拼接路径, 移动缓存文件到 tmp目录下, 再清空 tmp 目录. 注意一点, 无论是按照缓存时间还是缓存大小, 都是升序排序, 最先删除的都是<code>最早的或最小的</code>数据.</p>\n<h3 id=\"设置磁盘缓存空间上限-磁盘缓存时间上限\"><a href=\"#设置磁盘缓存空间上限-磁盘缓存时间上限\" class=\"headerlink\" title=\"设置磁盘缓存空间上限, 磁盘缓存时间上限\"></a>设置磁盘缓存空间上限, 磁盘缓存时间上限</h3><p>源码实现:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)byteLimit &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSUInteger</span> byteLimit = <span class=\"number\">0</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_queue, ^&#123;</div><div class=\"line\">        byteLimit = _byteLimit;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> byteLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setByteLimit:(<span class=\"built_in\">NSUInteger</span>)byteLimit &#123;</div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMDiskCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\">    </div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMDiskCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        strongSelf-&gt;_byteLimit = byteLimit;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (byteLimit &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            [strongSelf trimDiskToSizeByDate:byteLimit];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置缓存空间上限的时候采用<code>dispatch_barrier_async</code>栅栏方法, 我不知道作者为何这么写, 多此一举! 本来就是串行队列了, 就能够保证线程安全, 加<code>栅栏</code>方法没什么意义. 现在应该注意的不是线程安全, 而是<code>线程死锁</code>的问题. 所以在 API 接口中有个⚠️警告</p>\n<blockquote>\n<p>@warning Do not read this property on the <sharedQueue> (including asynchronous method blocks).</p>\n</blockquote>\n<p>意思是不要在 <code>shareQueue</code> 和接口里面的任何 API 的异步 block 中去读这个属性, 为什么呢?  因为<code>TMDiskCache</code>所有的读写删除操作都是放在<code>Serial Queue</code>串行队列中的, 也就是<code>shareQueue</code>队列, 天啦噜…这不造成死锁才怪呢! 警告还写这么不明显.形如下面的是<code>错误❌</code>的用法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[diskCache removeObjectForKey:<span class=\"string\">@\"profileKey\"</span> block:^(TMDiskCache *cache, <span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCoding</span>&gt; object, <span class=\"built_in\">NSURL</span> *fileURL) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld\"</span>, diskCache.byteLimit);</div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure>\n<p>因为在<code>removeObjectForKey</code>之类的方法中会同步执行传入的 block 操作, 如果在 block 里面再提交新的任务到串行队列中, 再同步执行, 必然死锁. 因为外层的 block 需要等待新提交的 block 执行完毕才能执行完成, 然而新提交的 block 需要等待外层 block 执行完才能执行, 两者相互依赖对方执行完才能执行完成, 就造成<code>死锁</code>了.   </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (block)</div><div class=\"line\">    block(strongSelf, key, <span class=\"literal\">nil</span>, fileURL);</div><div class=\"line\">``` </div><div class=\"line\">上一篇分析了 `TMMemoryCache` 容易造成性能消耗严重, 而`TMDiskCache`使用不当容易造成`死锁.`</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">### 各类 will / did block, 以及后台操作</span></div><div class=\"line\"></div><div class=\"line\">will / did block 穿插在各类异步操作中, 非常简单, 看看即可.</div><div class=\"line\"></div><div class=\"line\">```Objc</div><div class=\"line\"><span class=\"keyword\">if</span> (strongSelf-&gt;_willAddObjectBlock)</div><div class=\"line\">    strongSelf-&gt;_willAddObjectBlock(strongSelf, key, object, fileURL);</div></pre></td></tr></table></figure>\n<p>其中后台操作有点意思, 创建一个全局的<code>后台管理者</code>遵守<code>TMCacheBackgroundTaskManager</code>协议, 实现其中的两个方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIBackgroundTaskIdentifier</span>)beginBackgroundTask;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)endBackgroundTask:(<span class=\"built_in\">UIBackgroundTaskIdentifier</span>)identifier;</div></pre></td></tr></table></figure>\n<p>然后调用设置方法, 给 <code>TMDiskCache</code>对象设置后台管理者.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)setBackgroundTaskManager:(<span class=\"keyword\">id</span> &lt;TMCacheBackgroundTaskManager&gt;)backgroundTaskManager;</div></pre></td></tr></table></figure>\n<p>在后台任务开始之前调用 <code>beginBackgroundTask</code> 方法, 结束后台任务之前调用 <code>endBackgroundTask</code>, 就能在后台管理者里面监听到什么时候进入后台操作, 什么时候结束后台操作了.<br>具体做法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIBackgroundTaskIdentifier</span> taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(_queue, ^&#123; </div><div class=\"line\">      TMDiskCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf) &#123;</div><div class=\"line\">            [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 执行后台任务</span></div><div class=\"line\">      <span class=\"comment\">// 比如: 写缓存, 取缓存, 删除缓存等等.</span></div><div class=\"line\"></div><div class=\"line\">     [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为磁盘的操作可能耗时非常长, 不可能一直等待, 因此通过这种全局的方式来感知异步操作的开始和结束, 从而执行响应事件. </p>\n<h3 id=\"清空临时存储区\"><a href=\"#清空临时存储区\" class=\"headerlink\" title=\"清空临时存储区\"></a>清空临时存储区</h3><p>根据上面可以知道, 删除缓存文件的时候, 先会在<code>tmp</code>下创建”回收目录”, 需要删除的缓存文件统一放进回收目录下, 下面是获取回收目录的URL 路径, 没有就创建, 有则返回, 只创建一次:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">NSURL</span> *)sharedTrashURL &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSURL</span> *sharedTrashURL;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> predicate;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;predicate, ^&#123;</div><div class=\"line\">        sharedTrashURL = [[[<span class=\"built_in\">NSURL</span> alloc] initFileURLWithPath:<span class=\"built_in\">NSTemporaryDirectory</span>()] URLByAppendingPathComponent:TMDiskCachePrefix isDirectory:<span class=\"literal\">YES</span>];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[sharedTrashURL path]]) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">            [[<span class=\"built_in\">NSFileManager</span> defaultManager] createDirectoryAtURL:sharedTrashURL</div><div class=\"line\">                                     withIntermediateDirectories:<span class=\"literal\">YES</span></div><div class=\"line\">                                                      attributes:<span class=\"literal\">nil</span></div><div class=\"line\">                                                           error:&amp;error];</div><div class=\"line\">            TMDiskCacheError(error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> sharedTrashURL;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个清空操作专属的串行队列<code>TrashQueue</code>, 并且使用<code>dispatch_set_target_queue</code>方法修改<code>TrashQueue</code>的优先级, 并与全局并发队列<code>global_queue</code> 的后台优先级一致. 因为<code>tmp</code>目录的情况操作不是那么的重要, 即使我们不手动清除, 系统也会在恰当的时候清除, 所以这里把<code>TrashQueue</code>队列的优先级降低.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">dispatch_queue_t</span>)sharedTrashQueue &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_queue_t</span> trashQueue;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> predicate;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;predicate, ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *queueName = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@\"%@.trash\"</span>, TMDiskCachePrefix];</div><div class=\"line\">        trashQueue = dispatch_queue_create([queueName UTF8String], DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">        dispatch_set_target_queue(trashQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>));</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> trashQueue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类方法, 把原本在<code>Caches</code>下的缓存文件移动进<code>tmp</code>目录下的回收目录.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"built_in\">BOOL</span>)moveItemAtURLToTrash:(<span class=\"built_in\">NSURL</span> *)itemURL &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[itemURL path]])</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *uniqueString = [[<span class=\"built_in\">NSProcessInfo</span> processInfo] globallyUniqueString];</div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *uniqueTrashURL = [[TMDiskCache sharedTrashURL] URLByAppendingPathComponent:uniqueString];</div><div class=\"line\">    <span class=\"built_in\">BOOL</span> moved = [[<span class=\"built_in\">NSFileManager</span> defaultManager] moveItemAtURL:itemURL toURL:uniqueTrashURL error:&amp;error];</div><div class=\"line\">    TMDiskCacheError(error);</div><div class=\"line\">    <span class=\"keyword\">return</span> moved;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把清除操作添加到<code>TrashQueue</code>中异步执行, 在该方法中遍历回收目录下所有的缓存文件, 依次进行删除:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)emptyTrash &#123;</div><div class=\"line\">    <span class=\"built_in\">UIBackgroundTaskIdentifier</span> taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>([<span class=\"keyword\">self</span> sharedTrashQueue], ^&#123;</div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"built_in\">NSArray</span> *trashedItems = [[<span class=\"built_in\">NSFileManager</span> defaultManager] contentsOfDirectoryAtURL:[<span class=\"keyword\">self</span> sharedTrashURL]</div><div class=\"line\">                                                              includingPropertiesForKeys:<span class=\"literal\">nil</span></div><div class=\"line\">                                                                                 options:<span class=\"number\">0</span></div><div class=\"line\">                                                                                   error:&amp;error];</div><div class=\"line\">        TMDiskCacheError(error);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSURL</span> *trashedItemURL <span class=\"keyword\">in</span> trashedItems) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;</div><div class=\"line\">            [[<span class=\"built_in\">NSFileManager</span> defaultManager] removeItemAtURL:trashedItemURL error:&amp;error];</div><div class=\"line\">            TMDiskCacheError(error);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实我们只要看一下删除操作在哪里执行的, 就能明白为何作者要创建一个专门用于删除数据的串行队列了. <code>emptyTrash</code>方法调用是在读写操作的串行队列<code>queue</code>中, 方法调用后面还有<code>_didRemoveObjectBlock</code>等待执行, 如果删除数据量比较大且删除操作在<code>queue</code>中, 将阻塞当前线程, 那么<code>_didRemoveObjectBlock</code>会等待许久才能回调, 况且删除操作对于响应用户事件而言不是那么的重要, 所以把需要删除的缓存文件放进<code>tmp</code>目录下, 创建新的低优先级的串行队列来进行删除操作.  这点值得学习!</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[TMDiskCache emptyTrash];</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>使用<code>TMDiskCache</code>姿势要正确, 否则容易造成<code>死锁</code>.</li>\n<li>删除缓存的思路值得借鉴.  </li>\n</ol>\n<p>欢迎大家斧正!</p>"},{"title":"TMCache源码分析<一> TMMemoryCache内存缓存","date":"2016-02-26T16:00:00.000Z","_content":"缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:\n- 内存缓存: 快速, 读写数据量小\n- 磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)\n\n那缓存的目的是什么呢? 大概分为以下几点:\n+ 复用数据,避免重复计算.\n+ 缓解服务端压力.\n+ 提高用户体验,比如离线浏览, 节省流量等等.\n\n简言之,缓存的目的就是:\n> 以空间换时间.  \n  \n<!---more--->\n  \n目前 gitHub 上开源了很多缓存框架, 著名的 [TMCache](https://github.com/tumblr/TMCache), [PINCache](https://github.com/pinterest/PINCache), [YYCache](https://github.com/ibireme/YYCache)等, 接下来我会逐一分析他们的源码实现, 对比它们的优缺点.  \n\n[TMCache](https://github.com/tumblr/TMCache), [PINCache](https://github.com/pinterest/PINCache), [YYCache](https://github.com/ibireme/YYCache)基本框架结构都相同, 接口 API 类似, 所以只要会使用其中一个框架, 另外两个上手起来非常容易, 但是三个框架的内部实现原理略有不同.\n\n### TMMemoryCache\n`TMMemoryCache` 是 `TMCache` 框架中针对内存缓存的实现, 在系统 `NSCache` 缓存的基础上增加了很多方法和属性, 比如数量限制、内存总容量限制、缓存存活时间限制、内存警告或应用退到后台时清空缓存等功能. 并且`TMMemoryCache`能够同步和异步的对内存数据进行操作,最重要的一点是`TMMemoryCache`是线程安全的, 能够确保在多线程情况下数据的安全性.  \n\n首先来看一下 `TMMemoryCache` 提供什么功能, 按照功能来分析它的实现原理:\n1. 同步/异步的存储对象到内存中.\n2. 同步/异步的从内存中获取对象.\n3. 同步/异步的从内存中删除指定 key 的对象,或者全部对象.\n4. 增加/删除数据, 内存警告, 退回后台的异步回调事件.\n5. 设置内存缓存使用上限.\n6. 设置内存缓存过期时间.\n7. 内存警告或退到后台清空缓存.\n8. 根据时间或缓存大小来清空指定时间段或缓存范围的数据.\n\n### 同步/异步的存储对象到内存中\n相关 API:\n\n```Objc\n// 同步\n- (void)setObject:(id)object forKey:(NSString *)key;\n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost;\n\n// 异步\n- (void)setObject:(id)object forKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block;\n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost block:(TMMemoryCacheObjectBlock)block;\n```\n\n#### 异步存储\n首先看一下异步存储对象, 因为同步存储里面会调用异步存储操作, 采用 `dispatch_semaphore` 信号量的方式强制把异步操作转换成同步操作.  \n内存缓存的核心是创建字典把需要存储的对象按照 key, value的形式存进字典中, 这是一条主线, 然后在主线上分发出许多分支, 比如:缓存时间, 缓存大小, 线程安全等, 都是围绕着这条主线来的. TMMemoryCache 也不例外, 在调用`+ (instancetype)sharedCache`方法创建并初始化的时候会创建三个可变字典`_dictionary`, `_dates`, `_costs`,这三个字典分别保存三种键值对:   \n- | Key |value\n-------------|-------------|-------------\n_dictionary | 存储对象的 key | 存储对象的值\n_dates | 存储对象的 key | 存储对象时的时间\n_costs | 存储对象的 key | 存储对象所占内存大小\n\n实现数据存储的核心方法:\n\n```Objc  \n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost block:(TMMemoryCacheObjectBlock)block {\n    NSDate *now = [[NSDate alloc] init];\n\n    if (!key || !object)\n        return;\n\n    __weak TMMemoryCache *weakSelf = self;\n\n    // 0.竞态条件下, 在并发队列中保护写操作\n    dispatch_barrier_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n\n        // 1.调用 will add block\n        if (strongSelf->_willAddObjectBlock)\n            strongSelf->_willAddObjectBlock(strongSelf, key, object);\n\n        // 2.存储 key 对应的数据,时间,缓存大小到相应的字典中\n        [strongSelf->_dictionary setObject:object forKey:key];\n        [strongSelf->_dates setObject:now forKey:key];\n        [strongSelf->_costs setObject:@(cost) forKey:key];\n\n        _totalCost += cost;\n\n        // 3.调用 did add block\n        if (strongSelf->_didAddObjectBlock)\n            strongSelf->_didAddObjectBlock(strongSelf, key, object);\n\n        // 4.根据时间排序来清空指定缓存大小的内存\n        if (strongSelf->_costLimit > 0)\n            [strongSelf trimToCostByDate:strongSelf->_costLimit block:nil];\n\n        // 5.异步回调\n        if (block) {\n            __weak TMMemoryCache *weakSelf = strongSelf;\n            dispatch_async(strongSelf->_queue, ^{\n                TMMemoryCache *strongSelf = weakSelf;\n                if (strongSelf)\n                    block(strongSelf, key, object);\n            });\n        }\n    });\n}\n```\n\n在上面的代码中我标出了核心存储方法做了几件事, 其中最为核心的是保证线程安全的`dispatch_barrier_async`方法, 在 GCD 中称之为`栅栏`方法, 一般跟`并发队列`一起用, 在多线程中对同一资源的竞争条件下保护共享资源, 确保在同一时间片段只有一个线程`写`资源, 这是不扩展讲 GCD 的相关知识.\n> dispatch_barrier_async 方法一般都是跟并发队列搭配使用,下面的图解很清晰(`侵删`), 在并发队列中有很多任务(block), 这些block都是按照 FIFO 的顺序执行的, 当要执行用 dispatch_barrier_async 方法提交到并发队列queue的 block 的时候, 该并发队列暂时会'卡住', 等待之前的任务 block 执行完毕, 再执行dispatch_barrier_async 提交的 block, 在此 block 之后提交到并发队列queue的 block 不会被执行,会一直等待 dispatch_barrier_async block 执行完毕后才开始并发执行, 我们可以看出, 在并发队列遇到 dispatch_barrier_async block 时就处于一直串行队列状态, 等待执行完毕后又开始并发执行.  \n由于TMMemoryCache中所有的读写操作都是在一个 concurrent queue(并发队列)中, 所以使用 `dispatch_barrier_async` 能够保证写操作的线程安全, 在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心, 但也是它最大的毛病, 容易造成性能下降和死锁.\n> ![dispatch_barrier_async](https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67)\n\n从上面代码中可以看出, 在该方法中把需要存储的数据按照 key-value 的形式存储进了`_dictionary`字典中, 其它操作无非就是增加功能的配料,后面会抽丝剥茧的捋清楚, 到此处我们的任务完成, 知道是怎么存储数据的, 非常简单:\n1. 使用 GCD 的 `dispatch_barrier_async` 方法保证写操作线程安全.\n2. 把需要存储的数据存进可变字典中.\n\n#### 同步存储\n根据上文所说, 同步存储中会调用异步存储操作, 来看一下代码:  \n\n```Objc\n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost {\n    if (!object || !key)\n        return;\n\n    // 1.创建信号量\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n\n    // 2.异步存数据\n    [self setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, NSString *key, id object) {\n        \n        // 3.异步存储完毕发送 signal 信号\n        dispatch_semaphore_signal(semaphore);\n    }];\n\n    // 4.等待异步存储完毕\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n}\n```\n\n从上面代码可以看出,同步的存储数据使用了 GCD 的 `dispatch_semaphore_t` 信号量, 这是一个非常古老又复杂的线程概念, 有兴趣的话可以看看 `<<UNIX 环境高级编程>>` 这本经典之作, 因为它的复杂是建立在操作系统的复杂性上的.但是这并不影响我们使用 dispatch_semaphore_t 信号量. 怎么使用 GCD 的信号量以及原理下面大概描述一下:\n> 信号量在竞态条件下能够保证线程安全,在创建信号量 dispatch_semaphore_create 的时候设置信号量的值, 这个值表示允许多少个线程可同时访问公共资源, 就好比我们的车位一样, 线程就是我们的车子,这个信号量就是停车场的管理者, 他知道什么时候有多少车位, 是不是该把车子放进停车场, 当没有车位或者车位不足时, 这个管理员就会把司机卡在停车场外不准进, 那么被拦住的司机按照 FIFO 的队列排着队, 有足够位置的时候,管理员就方法闸门, 大吼一声: 孩子们去吧. 那么肯定有司机等不耐烦了, 就想着等十分钟没有车位就不等了,就可以在 dispatch_semaphore_wait 方法中设置等待时间, 等待超过设置时间就不等待.    \n> 那么把上面的场景应用在 dispatch_semaphore_create 信号量中就很容易理解了, 创建信号量并设置最大并发线程数, dispatch_semaphore_wait 设置等待时间,在等待时间未到达或者信号量值没有达到初始值时会一直等待, 调用 dispatch_semaphore_wait 方法会使信号量的值+1, 表示增加一个线程等待处理共用资源, 当 dispatch_semaphore_signal 时会使信号量的值-1, 表示该线程不再占用共用资源.\n\n根据上面对 dispatch_semaphore_t 信号量的描述可知, 信号量的初始值为0,当前线程执行 dispatch_semaphore_wait 方法就会一直等待, 此时就相当于同步操作, 当在并发队列中异步存储完数据调用dispatch_semaphore_signal 方法, 此时信号量的值变成0,跟初始值一样,当前线程立即结束等待, 同步设置方法执行完毕.  \n\n其实同步实现存储数据的方式很多, 主要就是要串行执行写操作采用 dispatch_sync的方式, 但是基于 TMMemoryCache 所有的操作都是在并发队列上的, 所以才采用信号量的方式.\n\n其实只要知道`dispatch_barrier_async`, `dispatch_semaphore_t` 的用法,后面的都可以不用看了, 自己去找源码看看就明白了.\n\n---\n\n休息一下吧,后面的简单了\n\n---\n\n### 同步/异步的从内存中获取对象.\n有了上面的同步/异步存储的理论, 那么同步/异步获取对象简直易如反掌, 不就是从`_dictionary`字典中根据 key 取出对应的 value 值, 在取的过程中加以线程安全, will/did 之类辅助处理的 block 操作.\n\n#### 异步获取数据\n\n```Objc\n- (void)objectForKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block {\n    NSDate *now = [[NSDate alloc] init];\n    \n    if (!key || !block)\n        return;\n\n    __weak TMMemoryCache *weakSelf = self;\n\n    // 1.异步加载存储数据\n    dispatch_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        // 2.根据 key 找到value\n        id object = [strongSelf->_dictionary objectForKey:key];\n\n        if (object) {\n            __weak TMMemoryCache *weakSelf = strongSelf;\n            // 3.也用栅栏保护写操作, 保证在写的时候没有线程在访问共享资源\n            dispatch_barrier_async(strongSelf->_queue, ^{\n                TMMemoryCache *strongSelf = weakSelf;\n                if (strongSelf)\n                    // 4.更新数据的最后操作时间(当前时间)\n                    [strongSelf->_dates setObject:now forKey:key];\n            });\n        }\n\n        // 5.回调\n        block(strongSelf, key, object);\n    });\n}\n```\n\n根据代码中注释可知,除了拿到 key 值对应的 value, 还更新了此数据最后操作时间, 这有什么用呢? 其实是为了记录数据最后的操作时间, 后面会根据这个最后操作时间来删除数据等一系列根据时间排序的操作.最后一步是回调, 我们可以看到, TMMemoryCache所有的读写和回调操作都放在同一个并发队列中,这就为以后性能下降和死锁埋下伏笔.\n\n#### 同步获取数据\n\n```Objc\n- (id)objectForKey:(NSString *)key {\n    if (!key)\n        return nil;\n\n    __block id objectForKey = nil;\n\n    // 采用信号量强制转化成同步操作\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n\n    [self objectForKey:key block:^(TMMemoryCache *cache, NSString *key, id object) {\n        objectForKey = object;\n        dispatch_semaphore_signal(semaphore);\n    }];\n\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n    return objectForKey;\n}\n```\n\n同步获取数据也是通过 `dispatch_semaphore_t` 信号量的方式,把异步获取数据的操作强制转成同步获取, 跟同步存储数据的原理相同.\n\n### 同步/异步的从内存中删除指定 key 的对象,或者全部对象.\n删除操作也不例外:\n\n```Objc\n- (void)removeObjectForKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block {\n    if (!key)\n        return;\n\n    __weak TMMemoryCache *weakSelf = self;\n\n    // 1.\"栅栏\"方法,保证线程安全\n    dispatch_barrier_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n\n        // 2.根据 key 删除 value\n        [strongSelf removeObjectAndExecuteBlocksForKey:key];\n\n        if (block) {\n            __weak TMMemoryCache *weakSelf = strongSelf;\n            \n            // 3.完成后回调\n            dispatch_async(strongSelf->_queue, ^{\n                TMMemoryCache *strongSelf = weakSelf;\n                if (strongSelf)\n                    block(strongSelf, key, nil);\n            });\n        }\n    });\n}\n\n// private API\n- (void)removeObjectAndExecuteBlocksForKey:(NSString *)key {\n    id object = [_dictionary objectForKey:key];\n    NSNumber *cost = [_costs objectForKey:key];\n\n    if (_willRemoveObjectBlock)\n        _willRemoveObjectBlock(self, key, object);\n\n    if (cost)\n        _totalCost -= [cost unsignedIntegerValue];\n\n    // 删除所有跟此数据相关的缓存: value, date, cost\n    [_dictionary removeObjectForKey:key];\n    [_dates removeObjectForKey:key];\n    [_costs removeObjectForKey:key];\n\n    if (_didRemoveObjectBlock)\n        _didRemoveObjectBlock(self, key, nil);\n}\n\n```\n\n需要注意的是 `- (void)removeObjectAndExecuteBlocksForKey` 是共用私有方法, 删除跟 key 相关的所有缓存, 后面的删除操作还会用到此方法.\n\n### 设置内存缓存使用上限 \nTMMemoryCache 提供`costLimit`属性来设置内存缓存使用上限, 这个也是 NSCache 不具备的功能,来看一下跟此属性相关的方法以及实现,代码中有详细解释:\n\n\n{% codeblock lang:Objc %}\n// getter\n- (NSUInteger)costLimit {\n    __block NSUInteger costLimit = 0;\n\n    // 要想通过函数返回值传递回去,那么必须同步执行,所以使用dispatch_sync同步获取内存使用上限\n    dispatch_sync(_queue, ^{\n        costLimit = _costLimit;\n    });\n\n    return costLimit;\n}\n\n// setter\n- (void)setCostLimit:(NSUInteger)costLimit {\n    __weak TMMemoryCache *weakSelf = self;\n\n    // \"栅栏\"方法保护写操作\n    dispatch_barrier_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n\n        // 设置内存上限\n        strongSelf->_costLimit = costLimit;\n\n        if (costLimit > 0)\n            // 根据时间排序来削减内存缓存,以达到设置的内存缓存上限的目的\n            [strongSelf trimToCostLimitByDate:costLimit];\n    });\n}\n\n- (void)trimToCostLimitByDate:(NSUInteger)limit {\n    if (_totalCost <= limit)\n        return;\n\n    // 按照时间的升序来排列 key\n    NSArray *keysSortedByDate = [_dates keysSortedByValueUsingSelector:@selector(compare:)];\n\n    // oldest objects first\n    for (NSString *key in keysSortedByDate) {\n        [self removeObjectAndExecuteBlocksForKey:key];\n\n        if (_totalCost <= limit)\n            break;\n    }\n}\n{% endcodeblock %}\n\n\n\n在`- (void)trimToCostLimitByDate:(NSUInteger)limit` 方法的作用:\n1. 如果目前已使用的内存大小小于需要设置的内存上线,则不删除数据,否则删除'最老'的数据,让已使用的内存大小不超过设置的内存上限.\n2. 按照存储的数据最近操作的最后时间进行升序排序,即最近操作的数据对应的 key 排最后.\n3. 如果已经超过内存上限, 则根据 key 值删除数据, 先删除操作时间较早的数据.\n\n\n从这里就会恍然大悟, 之前设置的 `_date` 数组终于派上用场了,如果需要删除数据则按照时间的先后顺序来删除,也算是一种优先级策略吧.\n\n### 设置内存缓存过期时间\nTMMemoryCache 提供`ageLimit`属性来设置缓存过期时间,根据上面`costLimit`属性可以猜想一下`ageLimit`是怎么实现的,既然是要设置缓存过期时间, 那么我设置缓存过期时间 `ageLimit = 10` 10秒钟,说明距离当前时间之前的10秒的数据已经过期, 需要删除掉; 再过10秒又要当前时间删除之前10秒存的数据,我们知道删除只需要找到 key 就行,所以就必须通过`_date`字典找到过期的 key, 再删除数据.由此可知需要一个定时器,每过10秒删除一次,完成一个定时任务. \n上面只是我们的猜想,来看看代码是不是这么实现的呢?我们只需看核心的操作方法\n\n```Objc\n- (void)trimToAgeLimitRecursively {\n    if (_ageLimit == 0.0)\n        return;\n\n    // 说明距离现在 ageLimit 秒的缓存应该被清除掉了\n    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:-_ageLimit];\n    [self trimMemoryToDate:date];\n    \n    __weak TMMemoryCache *weakSelf = self;\n    \n    // 延迟 ageLimit 秒, 又异步的清除缓存\n    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_ageLimit * NSEC_PER_SEC));\n    dispatch_after(time, _queue, ^(void){\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        __weak TMMemoryCache *weakSelf = strongSelf;\n        \n        dispatch_barrier_async(strongSelf->_queue, ^{\n            TMMemoryCache *strongSelf = weakSelf;\n            [strongSelf trimToAgeLimitRecursively];\n        });\n    });\n}\n\n;``  \n上面的代码验证了我们的猜想,但是在不断的创建定时器,不断的在并行队列中使用`dispatch_barrier_async`栅栏方法提交递归 block, 天啦噜...如果设置的 ageLimit 很小,可想而知性能消耗会非常大!\n \n \n### 内存警告或退到后台清空缓存\n内存警告和退到后台需要监听系统通知,`UIApplicationDidReceiveMemoryWarningNotification`和`UIApplicationDidEnterBackgroundNotification`, 然后执行清除操作方法`removeAllObjects`,只不过在相应的位置执行对应的 will/did 之类的 block 操作.\n\n### 根据时间或缓存大小来清空指定时间段或缓存范围的数据\n这两类方法主要是为了更加灵活的使用 TMMemoryCache,指定一个时间或者内存大小,会自动删除时间点之前和大于指定内存大小的数据.\n相关 API:\n\n```Objc\n// 清空 date 之前的数据\n- (void)trimToDate:(NSDate *)date block:(TMMemoryCacheBlock)block;\n// 清空数据,让已使用内存大小为cost \n- (void)trimToCost:(NSUInteger)cost block:(TMMemoryCacheBlock)block;\n```\n\n删除指定时间点有两点注意:\n- 如果指定的时间点为 `[NSDate distantPast]` 表示最早能表示的时间,说明清空全部数据.\n- 如果不是最早时间,把`_date`中的 key 按照升序排序,再遍历排序后的 key 数组,判断跟指定时间的关系,如果比指定时间更早则删除, 即删除指定时间节点之前的数据.\n\n```Objc\n- (void)trimMemoryToDate:(NSDate *)trimDate {\n    // 字典中存放的顺序不是按照顺序存放的, 所以按照一定格式排序, 根据 value 升序的排 key 值顺序, 也就是说根据时间的升序来排 key, 数组中第一个值是最早的时间的值.\n    NSArray *keysSortedByDate = [_dates keysSortedByValueUsingSelector:@selector(compare:)];\n    \n    for (NSString *key in keysSortedByDate) { // oldest objects first\n        NSDate *accessDate = [_dates objectForKey:key];\n        if (!accessDate)\n            continue;\n        \n        // 找出每个时间的然后跟要删除的时间点进行比较, 如果比删除时间早则删除\n        if ([accessDate compare:trimDate] == NSOrderedAscending) { // older than trim date\n            [self removeObjectAndExecuteBlocksForKey:key];\n        } else {\n            break;\n        }\n    }\n}\n```\n\n### 总结\n内存缓存是很简单的, 核心就是 key-value 的形式存储数据进字典,再辅助设置内存上限,缓存时间,各类 will/did block 操作, 最重要的是要实现线程安全.\n\n欢迎大家斧正!\n\n\n\n","source":"_posts/TMCache源码分析之TMMemoryCache内存缓存.md","raw":"---\ntitle: TMCache源码分析<一> TMMemoryCache内存缓存\ndate: 2016-2-27 \ncategories: Objective-C\ntags: [TMCache, 缓存]\n---\n缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:\n- 内存缓存: 快速, 读写数据量小\n- 磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)\n\n那缓存的目的是什么呢? 大概分为以下几点:\n+ 复用数据,避免重复计算.\n+ 缓解服务端压力.\n+ 提高用户体验,比如离线浏览, 节省流量等等.\n\n简言之,缓存的目的就是:\n> 以空间换时间.  \n  \n<!---more--->\n  \n目前 gitHub 上开源了很多缓存框架, 著名的 [TMCache](https://github.com/tumblr/TMCache), [PINCache](https://github.com/pinterest/PINCache), [YYCache](https://github.com/ibireme/YYCache)等, 接下来我会逐一分析他们的源码实现, 对比它们的优缺点.  \n\n[TMCache](https://github.com/tumblr/TMCache), [PINCache](https://github.com/pinterest/PINCache), [YYCache](https://github.com/ibireme/YYCache)基本框架结构都相同, 接口 API 类似, 所以只要会使用其中一个框架, 另外两个上手起来非常容易, 但是三个框架的内部实现原理略有不同.\n\n### TMMemoryCache\n`TMMemoryCache` 是 `TMCache` 框架中针对内存缓存的实现, 在系统 `NSCache` 缓存的基础上增加了很多方法和属性, 比如数量限制、内存总容量限制、缓存存活时间限制、内存警告或应用退到后台时清空缓存等功能. 并且`TMMemoryCache`能够同步和异步的对内存数据进行操作,最重要的一点是`TMMemoryCache`是线程安全的, 能够确保在多线程情况下数据的安全性.  \n\n首先来看一下 `TMMemoryCache` 提供什么功能, 按照功能来分析它的实现原理:\n1. 同步/异步的存储对象到内存中.\n2. 同步/异步的从内存中获取对象.\n3. 同步/异步的从内存中删除指定 key 的对象,或者全部对象.\n4. 增加/删除数据, 内存警告, 退回后台的异步回调事件.\n5. 设置内存缓存使用上限.\n6. 设置内存缓存过期时间.\n7. 内存警告或退到后台清空缓存.\n8. 根据时间或缓存大小来清空指定时间段或缓存范围的数据.\n\n### 同步/异步的存储对象到内存中\n相关 API:\n\n```Objc\n// 同步\n- (void)setObject:(id)object forKey:(NSString *)key;\n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost;\n\n// 异步\n- (void)setObject:(id)object forKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block;\n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost block:(TMMemoryCacheObjectBlock)block;\n```\n\n#### 异步存储\n首先看一下异步存储对象, 因为同步存储里面会调用异步存储操作, 采用 `dispatch_semaphore` 信号量的方式强制把异步操作转换成同步操作.  \n内存缓存的核心是创建字典把需要存储的对象按照 key, value的形式存进字典中, 这是一条主线, 然后在主线上分发出许多分支, 比如:缓存时间, 缓存大小, 线程安全等, 都是围绕着这条主线来的. TMMemoryCache 也不例外, 在调用`+ (instancetype)sharedCache`方法创建并初始化的时候会创建三个可变字典`_dictionary`, `_dates`, `_costs`,这三个字典分别保存三种键值对:   \n- | Key |value\n-------------|-------------|-------------\n_dictionary | 存储对象的 key | 存储对象的值\n_dates | 存储对象的 key | 存储对象时的时间\n_costs | 存储对象的 key | 存储对象所占内存大小\n\n实现数据存储的核心方法:\n\n```Objc  \n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost block:(TMMemoryCacheObjectBlock)block {\n    NSDate *now = [[NSDate alloc] init];\n\n    if (!key || !object)\n        return;\n\n    __weak TMMemoryCache *weakSelf = self;\n\n    // 0.竞态条件下, 在并发队列中保护写操作\n    dispatch_barrier_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n\n        // 1.调用 will add block\n        if (strongSelf->_willAddObjectBlock)\n            strongSelf->_willAddObjectBlock(strongSelf, key, object);\n\n        // 2.存储 key 对应的数据,时间,缓存大小到相应的字典中\n        [strongSelf->_dictionary setObject:object forKey:key];\n        [strongSelf->_dates setObject:now forKey:key];\n        [strongSelf->_costs setObject:@(cost) forKey:key];\n\n        _totalCost += cost;\n\n        // 3.调用 did add block\n        if (strongSelf->_didAddObjectBlock)\n            strongSelf->_didAddObjectBlock(strongSelf, key, object);\n\n        // 4.根据时间排序来清空指定缓存大小的内存\n        if (strongSelf->_costLimit > 0)\n            [strongSelf trimToCostByDate:strongSelf->_costLimit block:nil];\n\n        // 5.异步回调\n        if (block) {\n            __weak TMMemoryCache *weakSelf = strongSelf;\n            dispatch_async(strongSelf->_queue, ^{\n                TMMemoryCache *strongSelf = weakSelf;\n                if (strongSelf)\n                    block(strongSelf, key, object);\n            });\n        }\n    });\n}\n```\n\n在上面的代码中我标出了核心存储方法做了几件事, 其中最为核心的是保证线程安全的`dispatch_barrier_async`方法, 在 GCD 中称之为`栅栏`方法, 一般跟`并发队列`一起用, 在多线程中对同一资源的竞争条件下保护共享资源, 确保在同一时间片段只有一个线程`写`资源, 这是不扩展讲 GCD 的相关知识.\n> dispatch_barrier_async 方法一般都是跟并发队列搭配使用,下面的图解很清晰(`侵删`), 在并发队列中有很多任务(block), 这些block都是按照 FIFO 的顺序执行的, 当要执行用 dispatch_barrier_async 方法提交到并发队列queue的 block 的时候, 该并发队列暂时会'卡住', 等待之前的任务 block 执行完毕, 再执行dispatch_barrier_async 提交的 block, 在此 block 之后提交到并发队列queue的 block 不会被执行,会一直等待 dispatch_barrier_async block 执行完毕后才开始并发执行, 我们可以看出, 在并发队列遇到 dispatch_barrier_async block 时就处于一直串行队列状态, 等待执行完毕后又开始并发执行.  \n由于TMMemoryCache中所有的读写操作都是在一个 concurrent queue(并发队列)中, 所以使用 `dispatch_barrier_async` 能够保证写操作的线程安全, 在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心, 但也是它最大的毛病, 容易造成性能下降和死锁.\n> ![dispatch_barrier_async](https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67)\n\n从上面代码中可以看出, 在该方法中把需要存储的数据按照 key-value 的形式存储进了`_dictionary`字典中, 其它操作无非就是增加功能的配料,后面会抽丝剥茧的捋清楚, 到此处我们的任务完成, 知道是怎么存储数据的, 非常简单:\n1. 使用 GCD 的 `dispatch_barrier_async` 方法保证写操作线程安全.\n2. 把需要存储的数据存进可变字典中.\n\n#### 同步存储\n根据上文所说, 同步存储中会调用异步存储操作, 来看一下代码:  \n\n```Objc\n- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost {\n    if (!object || !key)\n        return;\n\n    // 1.创建信号量\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n\n    // 2.异步存数据\n    [self setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, NSString *key, id object) {\n        \n        // 3.异步存储完毕发送 signal 信号\n        dispatch_semaphore_signal(semaphore);\n    }];\n\n    // 4.等待异步存储完毕\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n}\n```\n\n从上面代码可以看出,同步的存储数据使用了 GCD 的 `dispatch_semaphore_t` 信号量, 这是一个非常古老又复杂的线程概念, 有兴趣的话可以看看 `<<UNIX 环境高级编程>>` 这本经典之作, 因为它的复杂是建立在操作系统的复杂性上的.但是这并不影响我们使用 dispatch_semaphore_t 信号量. 怎么使用 GCD 的信号量以及原理下面大概描述一下:\n> 信号量在竞态条件下能够保证线程安全,在创建信号量 dispatch_semaphore_create 的时候设置信号量的值, 这个值表示允许多少个线程可同时访问公共资源, 就好比我们的车位一样, 线程就是我们的车子,这个信号量就是停车场的管理者, 他知道什么时候有多少车位, 是不是该把车子放进停车场, 当没有车位或者车位不足时, 这个管理员就会把司机卡在停车场外不准进, 那么被拦住的司机按照 FIFO 的队列排着队, 有足够位置的时候,管理员就方法闸门, 大吼一声: 孩子们去吧. 那么肯定有司机等不耐烦了, 就想着等十分钟没有车位就不等了,就可以在 dispatch_semaphore_wait 方法中设置等待时间, 等待超过设置时间就不等待.    \n> 那么把上面的场景应用在 dispatch_semaphore_create 信号量中就很容易理解了, 创建信号量并设置最大并发线程数, dispatch_semaphore_wait 设置等待时间,在等待时间未到达或者信号量值没有达到初始值时会一直等待, 调用 dispatch_semaphore_wait 方法会使信号量的值+1, 表示增加一个线程等待处理共用资源, 当 dispatch_semaphore_signal 时会使信号量的值-1, 表示该线程不再占用共用资源.\n\n根据上面对 dispatch_semaphore_t 信号量的描述可知, 信号量的初始值为0,当前线程执行 dispatch_semaphore_wait 方法就会一直等待, 此时就相当于同步操作, 当在并发队列中异步存储完数据调用dispatch_semaphore_signal 方法, 此时信号量的值变成0,跟初始值一样,当前线程立即结束等待, 同步设置方法执行完毕.  \n\n其实同步实现存储数据的方式很多, 主要就是要串行执行写操作采用 dispatch_sync的方式, 但是基于 TMMemoryCache 所有的操作都是在并发队列上的, 所以才采用信号量的方式.\n\n其实只要知道`dispatch_barrier_async`, `dispatch_semaphore_t` 的用法,后面的都可以不用看了, 自己去找源码看看就明白了.\n\n---\n\n休息一下吧,后面的简单了\n\n---\n\n### 同步/异步的从内存中获取对象.\n有了上面的同步/异步存储的理论, 那么同步/异步获取对象简直易如反掌, 不就是从`_dictionary`字典中根据 key 取出对应的 value 值, 在取的过程中加以线程安全, will/did 之类辅助处理的 block 操作.\n\n#### 异步获取数据\n\n```Objc\n- (void)objectForKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block {\n    NSDate *now = [[NSDate alloc] init];\n    \n    if (!key || !block)\n        return;\n\n    __weak TMMemoryCache *weakSelf = self;\n\n    // 1.异步加载存储数据\n    dispatch_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        // 2.根据 key 找到value\n        id object = [strongSelf->_dictionary objectForKey:key];\n\n        if (object) {\n            __weak TMMemoryCache *weakSelf = strongSelf;\n            // 3.也用栅栏保护写操作, 保证在写的时候没有线程在访问共享资源\n            dispatch_barrier_async(strongSelf->_queue, ^{\n                TMMemoryCache *strongSelf = weakSelf;\n                if (strongSelf)\n                    // 4.更新数据的最后操作时间(当前时间)\n                    [strongSelf->_dates setObject:now forKey:key];\n            });\n        }\n\n        // 5.回调\n        block(strongSelf, key, object);\n    });\n}\n```\n\n根据代码中注释可知,除了拿到 key 值对应的 value, 还更新了此数据最后操作时间, 这有什么用呢? 其实是为了记录数据最后的操作时间, 后面会根据这个最后操作时间来删除数据等一系列根据时间排序的操作.最后一步是回调, 我们可以看到, TMMemoryCache所有的读写和回调操作都放在同一个并发队列中,这就为以后性能下降和死锁埋下伏笔.\n\n#### 同步获取数据\n\n```Objc\n- (id)objectForKey:(NSString *)key {\n    if (!key)\n        return nil;\n\n    __block id objectForKey = nil;\n\n    // 采用信号量强制转化成同步操作\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n\n    [self objectForKey:key block:^(TMMemoryCache *cache, NSString *key, id object) {\n        objectForKey = object;\n        dispatch_semaphore_signal(semaphore);\n    }];\n\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n    return objectForKey;\n}\n```\n\n同步获取数据也是通过 `dispatch_semaphore_t` 信号量的方式,把异步获取数据的操作强制转成同步获取, 跟同步存储数据的原理相同.\n\n### 同步/异步的从内存中删除指定 key 的对象,或者全部对象.\n删除操作也不例外:\n\n```Objc\n- (void)removeObjectForKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block {\n    if (!key)\n        return;\n\n    __weak TMMemoryCache *weakSelf = self;\n\n    // 1.\"栅栏\"方法,保证线程安全\n    dispatch_barrier_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n\n        // 2.根据 key 删除 value\n        [strongSelf removeObjectAndExecuteBlocksForKey:key];\n\n        if (block) {\n            __weak TMMemoryCache *weakSelf = strongSelf;\n            \n            // 3.完成后回调\n            dispatch_async(strongSelf->_queue, ^{\n                TMMemoryCache *strongSelf = weakSelf;\n                if (strongSelf)\n                    block(strongSelf, key, nil);\n            });\n        }\n    });\n}\n\n// private API\n- (void)removeObjectAndExecuteBlocksForKey:(NSString *)key {\n    id object = [_dictionary objectForKey:key];\n    NSNumber *cost = [_costs objectForKey:key];\n\n    if (_willRemoveObjectBlock)\n        _willRemoveObjectBlock(self, key, object);\n\n    if (cost)\n        _totalCost -= [cost unsignedIntegerValue];\n\n    // 删除所有跟此数据相关的缓存: value, date, cost\n    [_dictionary removeObjectForKey:key];\n    [_dates removeObjectForKey:key];\n    [_costs removeObjectForKey:key];\n\n    if (_didRemoveObjectBlock)\n        _didRemoveObjectBlock(self, key, nil);\n}\n\n```\n\n需要注意的是 `- (void)removeObjectAndExecuteBlocksForKey` 是共用私有方法, 删除跟 key 相关的所有缓存, 后面的删除操作还会用到此方法.\n\n### 设置内存缓存使用上限 \nTMMemoryCache 提供`costLimit`属性来设置内存缓存使用上限, 这个也是 NSCache 不具备的功能,来看一下跟此属性相关的方法以及实现,代码中有详细解释:\n\n\n{% codeblock lang:Objc %}\n// getter\n- (NSUInteger)costLimit {\n    __block NSUInteger costLimit = 0;\n\n    // 要想通过函数返回值传递回去,那么必须同步执行,所以使用dispatch_sync同步获取内存使用上限\n    dispatch_sync(_queue, ^{\n        costLimit = _costLimit;\n    });\n\n    return costLimit;\n}\n\n// setter\n- (void)setCostLimit:(NSUInteger)costLimit {\n    __weak TMMemoryCache *weakSelf = self;\n\n    // \"栅栏\"方法保护写操作\n    dispatch_barrier_async(_queue, ^{\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n\n        // 设置内存上限\n        strongSelf->_costLimit = costLimit;\n\n        if (costLimit > 0)\n            // 根据时间排序来削减内存缓存,以达到设置的内存缓存上限的目的\n            [strongSelf trimToCostLimitByDate:costLimit];\n    });\n}\n\n- (void)trimToCostLimitByDate:(NSUInteger)limit {\n    if (_totalCost <= limit)\n        return;\n\n    // 按照时间的升序来排列 key\n    NSArray *keysSortedByDate = [_dates keysSortedByValueUsingSelector:@selector(compare:)];\n\n    // oldest objects first\n    for (NSString *key in keysSortedByDate) {\n        [self removeObjectAndExecuteBlocksForKey:key];\n\n        if (_totalCost <= limit)\n            break;\n    }\n}\n{% endcodeblock %}\n\n\n\n在`- (void)trimToCostLimitByDate:(NSUInteger)limit` 方法的作用:\n1. 如果目前已使用的内存大小小于需要设置的内存上线,则不删除数据,否则删除'最老'的数据,让已使用的内存大小不超过设置的内存上限.\n2. 按照存储的数据最近操作的最后时间进行升序排序,即最近操作的数据对应的 key 排最后.\n3. 如果已经超过内存上限, 则根据 key 值删除数据, 先删除操作时间较早的数据.\n\n\n从这里就会恍然大悟, 之前设置的 `_date` 数组终于派上用场了,如果需要删除数据则按照时间的先后顺序来删除,也算是一种优先级策略吧.\n\n### 设置内存缓存过期时间\nTMMemoryCache 提供`ageLimit`属性来设置缓存过期时间,根据上面`costLimit`属性可以猜想一下`ageLimit`是怎么实现的,既然是要设置缓存过期时间, 那么我设置缓存过期时间 `ageLimit = 10` 10秒钟,说明距离当前时间之前的10秒的数据已经过期, 需要删除掉; 再过10秒又要当前时间删除之前10秒存的数据,我们知道删除只需要找到 key 就行,所以就必须通过`_date`字典找到过期的 key, 再删除数据.由此可知需要一个定时器,每过10秒删除一次,完成一个定时任务. \n上面只是我们的猜想,来看看代码是不是这么实现的呢?我们只需看核心的操作方法\n\n```Objc\n- (void)trimToAgeLimitRecursively {\n    if (_ageLimit == 0.0)\n        return;\n\n    // 说明距离现在 ageLimit 秒的缓存应该被清除掉了\n    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:-_ageLimit];\n    [self trimMemoryToDate:date];\n    \n    __weak TMMemoryCache *weakSelf = self;\n    \n    // 延迟 ageLimit 秒, 又异步的清除缓存\n    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_ageLimit * NSEC_PER_SEC));\n    dispatch_after(time, _queue, ^(void){\n        TMMemoryCache *strongSelf = weakSelf;\n        if (!strongSelf)\n            return;\n        \n        __weak TMMemoryCache *weakSelf = strongSelf;\n        \n        dispatch_barrier_async(strongSelf->_queue, ^{\n            TMMemoryCache *strongSelf = weakSelf;\n            [strongSelf trimToAgeLimitRecursively];\n        });\n    });\n}\n\n;``  \n上面的代码验证了我们的猜想,但是在不断的创建定时器,不断的在并行队列中使用`dispatch_barrier_async`栅栏方法提交递归 block, 天啦噜...如果设置的 ageLimit 很小,可想而知性能消耗会非常大!\n \n \n### 内存警告或退到后台清空缓存\n内存警告和退到后台需要监听系统通知,`UIApplicationDidReceiveMemoryWarningNotification`和`UIApplicationDidEnterBackgroundNotification`, 然后执行清除操作方法`removeAllObjects`,只不过在相应的位置执行对应的 will/did 之类的 block 操作.\n\n### 根据时间或缓存大小来清空指定时间段或缓存范围的数据\n这两类方法主要是为了更加灵活的使用 TMMemoryCache,指定一个时间或者内存大小,会自动删除时间点之前和大于指定内存大小的数据.\n相关 API:\n\n```Objc\n// 清空 date 之前的数据\n- (void)trimToDate:(NSDate *)date block:(TMMemoryCacheBlock)block;\n// 清空数据,让已使用内存大小为cost \n- (void)trimToCost:(NSUInteger)cost block:(TMMemoryCacheBlock)block;\n```\n\n删除指定时间点有两点注意:\n- 如果指定的时间点为 `[NSDate distantPast]` 表示最早能表示的时间,说明清空全部数据.\n- 如果不是最早时间,把`_date`中的 key 按照升序排序,再遍历排序后的 key 数组,判断跟指定时间的关系,如果比指定时间更早则删除, 即删除指定时间节点之前的数据.\n\n```Objc\n- (void)trimMemoryToDate:(NSDate *)trimDate {\n    // 字典中存放的顺序不是按照顺序存放的, 所以按照一定格式排序, 根据 value 升序的排 key 值顺序, 也就是说根据时间的升序来排 key, 数组中第一个值是最早的时间的值.\n    NSArray *keysSortedByDate = [_dates keysSortedByValueUsingSelector:@selector(compare:)];\n    \n    for (NSString *key in keysSortedByDate) { // oldest objects first\n        NSDate *accessDate = [_dates objectForKey:key];\n        if (!accessDate)\n            continue;\n        \n        // 找出每个时间的然后跟要删除的时间点进行比较, 如果比删除时间早则删除\n        if ([accessDate compare:trimDate] == NSOrderedAscending) { // older than trim date\n            [self removeObjectAndExecuteBlocksForKey:key];\n        } else {\n            break;\n        }\n    }\n}\n```\n\n### 总结\n内存缓存是很简单的, 核心就是 key-value 的形式存储数据进字典,再辅助设置内存上限,缓存时间,各类 will/did block 操作, 最重要的是要实现线程安全.\n\n欢迎大家斧正!\n\n\n\n","slug":"TMCache源码分析之TMMemoryCache内存缓存","published":1,"updated":"2017-02-27T16:17:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizozpebh0008k4exobfp1vkz","content":"<p>缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:</p>\n<ul>\n<li>内存缓存: 快速, 读写数据量小</li>\n<li>磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)</li>\n</ul>\n<p>那缓存的目的是什么呢? 大概分为以下几点:</p>\n<ul>\n<li>复用数据,避免重复计算.</li>\n<li>缓解服务端压力.</li>\n<li>提高用户体验,比如离线浏览, 节省流量等等.</li>\n</ul>\n<p>简言之,缓存的目的就是:</p>\n<blockquote>\n<p>以空间换时间.  </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>目前 gitHub 上开源了很多缓存框架, 著名的 <a href=\"https://github.com/tumblr/TMCache\" target=\"_blank\" rel=\"external\">TMCache</a>, <a href=\"https://github.com/pinterest/PINCache\" target=\"_blank\" rel=\"external\">PINCache</a>, <a href=\"https://github.com/ibireme/YYCache\" target=\"_blank\" rel=\"external\">YYCache</a>等, 接下来我会逐一分析他们的源码实现, 对比它们的优缺点.  </p>\n<p><a href=\"https://github.com/tumblr/TMCache\" target=\"_blank\" rel=\"external\">TMCache</a>, <a href=\"https://github.com/pinterest/PINCache\" target=\"_blank\" rel=\"external\">PINCache</a>, <a href=\"https://github.com/ibireme/YYCache\" target=\"_blank\" rel=\"external\">YYCache</a>基本框架结构都相同, 接口 API 类似, 所以只要会使用其中一个框架, 另外两个上手起来非常容易, 但是三个框架的内部实现原理略有不同.</p>\n<h3 id=\"TMMemoryCache\"><a href=\"#TMMemoryCache\" class=\"headerlink\" title=\"TMMemoryCache\"></a>TMMemoryCache</h3><p><code>TMMemoryCache</code> 是 <code>TMCache</code> 框架中针对内存缓存的实现, 在系统 <code>NSCache</code> 缓存的基础上增加了很多方法和属性, 比如数量限制、内存总容量限制、缓存存活时间限制、内存警告或应用退到后台时清空缓存等功能. 并且<code>TMMemoryCache</code>能够同步和异步的对内存数据进行操作,最重要的一点是<code>TMMemoryCache</code>是线程安全的, 能够确保在多线程情况下数据的安全性.  </p>\n<p>首先来看一下 <code>TMMemoryCache</code> 提供什么功能, 按照功能来分析它的实现原理:</p>\n<ol>\n<li>同步/异步的存储对象到内存中.</li>\n<li>同步/异步的从内存中获取对象.</li>\n<li>同步/异步的从内存中删除指定 key 的对象,或者全部对象.</li>\n<li>增加/删除数据, 内存警告, 退回后台的异步回调事件.</li>\n<li>设置内存缓存使用上限.</li>\n<li>设置内存缓存过期时间.</li>\n<li>内存警告或退到后台清空缓存.</li>\n<li>根据时间或缓存大小来清空指定时间段或缓存范围的数据.</li>\n</ol>\n<h3 id=\"同步-异步的存储对象到内存中\"><a href=\"#同步-异步的存储对象到内存中\" class=\"headerlink\" title=\"同步/异步的存储对象到内存中\"></a>同步/异步的存储对象到内存中</h3><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同步</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 异步</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost block:(TMMemoryCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<h4 id=\"异步存储\"><a href=\"#异步存储\" class=\"headerlink\" title=\"异步存储\"></a>异步存储</h4><p>首先看一下异步存储对象, 因为同步存储里面会调用异步存储操作, 采用 <code>dispatch_semaphore</code> 信号量的方式强制把异步操作转换成同步操作.<br>内存缓存的核心是创建字典把需要存储的对象按照 key, value的形式存进字典中, 这是一条主线, 然后在主线上分发出许多分支, 比如:缓存时间, 缓存大小, 线程安全等, 都是围绕着这条主线来的. TMMemoryCache 也不例外, 在调用<code>+ (instancetype)sharedCache</code>方法创建并初始化的时候会创建三个可变字典<code>_dictionary</code>, <code>_dates</code>, <code>_costs</code>,这三个字典分别保存三种键值对:   </p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Key</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_dictionary</td>\n<td>存储对象的 key</td>\n<td>存储对象的值</td>\n</tr>\n<tr>\n<td>_dates</td>\n<td>存储对象的 key</td>\n<td>存储对象时的时间</td>\n</tr>\n<tr>\n<td>_costs</td>\n<td>存储对象的 key</td>\n<td>存储对象所占内存大小</td>\n</tr>\n</tbody>\n</table>\n<p>实现数据存储的核心方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost block:(TMMemoryCacheObjectBlock)block &#123;</div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *now = [[<span class=\"built_in\">NSDate</span> alloc] init];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!key || !object)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 0.竞态条件下, 在并发队列中保护写操作</span></div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 1.调用 will add block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (strongSelf-&gt;_willAddObjectBlock)</div><div class=\"line\">            strongSelf-&gt;_willAddObjectBlock(strongSelf, key, object);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 2.存储 key 对应的数据,时间,缓存大小到相应的字典中</span></div><div class=\"line\">        [strongSelf-&gt;_dictionary setObject:object forKey:key];</div><div class=\"line\">        [strongSelf-&gt;_dates setObject:now forKey:key];</div><div class=\"line\">        [strongSelf-&gt;_costs setObject:@(cost) forKey:key];</div><div class=\"line\"></div><div class=\"line\">        _totalCost += cost;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 3.调用 did add block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (strongSelf-&gt;_didAddObjectBlock)</div><div class=\"line\">            strongSelf-&gt;_didAddObjectBlock(strongSelf, key, object);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 4.根据时间排序来清空指定缓存大小的内存</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (strongSelf-&gt;_costLimit &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            [strongSelf trimToCostByDate:strongSelf-&gt;_costLimit block:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 5.异步回调</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (block) &#123;</div><div class=\"line\">            __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">            <span class=\"built_in\">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">                TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">                <span class=\"keyword\">if</span> (strongSelf)</div><div class=\"line\">                    block(strongSelf, key, object);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中我标出了核心存储方法做了几件事, 其中最为核心的是保证线程安全的<code>dispatch_barrier_async</code>方法, 在 GCD 中称之为<code>栅栏</code>方法, 一般跟<code>并发队列</code>一起用, 在多线程中对同一资源的竞争条件下保护共享资源, 确保在同一时间片段只有一个线程<code>写</code>资源, 这是不扩展讲 GCD 的相关知识.</p>\n<blockquote>\n<p>dispatch_barrier_async 方法一般都是跟并发队列搭配使用,下面的图解很清晰(<code>侵删</code>), 在并发队列中有很多任务(block), 这些block都是按照 FIFO 的顺序执行的, 当要执行用 dispatch_barrier_async 方法提交到并发队列queue的 block 的时候, 该并发队列暂时会’卡住’, 等待之前的任务 block 执行完毕, 再执行dispatch_barrier_async 提交的 block, 在此 block 之后提交到并发队列queue的 block 不会被执行,会一直等待 dispatch_barrier_async block 执行完毕后才开始并发执行, 我们可以看出, 在并发队列遇到 dispatch_barrier_async block 时就处于一直串行队列状态, 等待执行完毕后又开始并发执行.<br>由于TMMemoryCache中所有的读写操作都是在一个 concurrent queue(并发队列)中, 所以使用 <code>dispatch_barrier_async</code> 能够保证写操作的线程安全, 在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心, 但也是它最大的毛病, 容易造成性能下降和死锁.<br><img src=\"https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67\" alt=\"dispatch_barrier_async\"></p>\n</blockquote>\n<p>从上面代码中可以看出, 在该方法中把需要存储的数据按照 key-value 的形式存储进了<code>_dictionary</code>字典中, 其它操作无非就是增加功能的配料,后面会抽丝剥茧的捋清楚, 到此处我们的任务完成, 知道是怎么存储数据的, 非常简单:</p>\n<ol>\n<li>使用 GCD 的 <code>dispatch_barrier_async</code> 方法保证写操作线程安全.</li>\n<li>把需要存储的数据存进可变字典中.</li>\n</ol>\n<h4 id=\"同步存储\"><a href=\"#同步存储\" class=\"headerlink\" title=\"同步存储\"></a>同步存储</h4><p>根据上文所说, 同步存储中会调用异步存储操作, 来看一下代码:  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!object || !key)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.创建信号量</span></div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 2.异步存数据</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, <span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span> object) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 3.异步存储完毕发送 signal 信号</span></div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 4.等待异步存储完毕</span></div><div class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面代码可以看出,同步的存储数据使用了 GCD 的 <code>dispatch_semaphore_t</code> 信号量, 这是一个非常古老又复杂的线程概念, 有兴趣的话可以看看 <code>&lt;&lt;UNIX 环境高级编程&gt;&gt;</code> 这本经典之作, 因为它的复杂是建立在操作系统的复杂性上的.但是这并不影响我们使用 dispatch_semaphore_t 信号量. 怎么使用 GCD 的信号量以及原理下面大概描述一下:</p>\n<blockquote>\n<p>信号量在竞态条件下能够保证线程安全,在创建信号量 dispatch_semaphore_create 的时候设置信号量的值, 这个值表示允许多少个线程可同时访问公共资源, 就好比我们的车位一样, 线程就是我们的车子,这个信号量就是停车场的管理者, 他知道什么时候有多少车位, 是不是该把车子放进停车场, 当没有车位或者车位不足时, 这个管理员就会把司机卡在停车场外不准进, 那么被拦住的司机按照 FIFO 的队列排着队, 有足够位置的时候,管理员就方法闸门, 大吼一声: 孩子们去吧. 那么肯定有司机等不耐烦了, 就想着等十分钟没有车位就不等了,就可以在 dispatch_semaphore_wait 方法中设置等待时间, 等待超过设置时间就不等待.<br>那么把上面的场景应用在 dispatch_semaphore_create 信号量中就很容易理解了, 创建信号量并设置最大并发线程数, dispatch_semaphore_wait 设置等待时间,在等待时间未到达或者信号量值没有达到初始值时会一直等待, 调用 dispatch_semaphore_wait 方法会使信号量的值+1, 表示增加一个线程等待处理共用资源, 当 dispatch_semaphore_signal 时会使信号量的值-1, 表示该线程不再占用共用资源.</p>\n</blockquote>\n<p>根据上面对 dispatch_semaphore_t 信号量的描述可知, 信号量的初始值为0,当前线程执行 dispatch_semaphore_wait 方法就会一直等待, 此时就相当于同步操作, 当在并发队列中异步存储完数据调用dispatch_semaphore_signal 方法, 此时信号量的值变成0,跟初始值一样,当前线程立即结束等待, 同步设置方法执行完毕.  </p>\n<p>其实同步实现存储数据的方式很多, 主要就是要串行执行写操作采用 dispatch_sync的方式, 但是基于 TMMemoryCache 所有的操作都是在并发队列上的, 所以才采用信号量的方式.</p>\n<p>其实只要知道<code>dispatch_barrier_async</code>, <code>dispatch_semaphore_t</code> 的用法,后面的都可以不用看了, 自己去找源码看看就明白了.</p>\n<hr>\n<p>休息一下吧,后面的简单了</p>\n<hr>\n<h3 id=\"同步-异步的从内存中获取对象\"><a href=\"#同步-异步的从内存中获取对象\" class=\"headerlink\" title=\"同步/异步的从内存中获取对象.\"></a>同步/异步的从内存中获取对象.</h3><p>有了上面的同步/异步存储的理论, 那么同步/异步获取对象简直易如反掌, 不就是从<code>_dictionary</code>字典中根据 key 取出对应的 value 值, 在取的过程中加以线程安全, will/did 之类辅助处理的 block 操作.</p>\n<h4 id=\"异步获取数据\"><a href=\"#异步获取数据\" class=\"headerlink\" title=\"异步获取数据\"></a>异步获取数据</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block &#123;</div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *now = [[<span class=\"built_in\">NSDate</span> alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!key || !block)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.异步加载存储数据</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 2.根据 key 找到value</span></div><div class=\"line\">        <span class=\"keyword\">id</span> object = [strongSelf-&gt;_dictionary objectForKey:key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (object) &#123;</div><div class=\"line\">            __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">            <span class=\"comment\">// 3.也用栅栏保护写操作, 保证在写的时候没有线程在访问共享资源</span></div><div class=\"line\">            dispatch_barrier_async(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">                TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">                <span class=\"keyword\">if</span> (strongSelf)</div><div class=\"line\">                    <span class=\"comment\">// 4.更新数据的最后操作时间(当前时间)</span></div><div class=\"line\">                    [strongSelf-&gt;_dates setObject:now forKey:key];</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 5.回调</span></div><div class=\"line\">        block(strongSelf, key, object);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据代码中注释可知,除了拿到 key 值对应的 value, 还更新了此数据最后操作时间, 这有什么用呢? 其实是为了记录数据最后的操作时间, 后面会根据这个最后操作时间来删除数据等一系列根据时间排序的操作.最后一步是回调, 我们可以看到, TMMemoryCache所有的读写和回调操作都放在同一个并发队列中,这就为以后性能下降和死锁埋下伏笔.</p>\n<h4 id=\"同步获取数据\"><a href=\"#同步获取数据\" class=\"headerlink\" title=\"同步获取数据\"></a>同步获取数据</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!key)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">    __block <span class=\"keyword\">id</span> objectForKey = <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 采用信号量强制转化成同步操作</span></div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span> objectForKey:key block:^(TMMemoryCache *cache, <span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span> object) &#123;</div><div class=\"line\">        objectForKey = object;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> objectForKey;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同步获取数据也是通过 <code>dispatch_semaphore_t</code> 信号量的方式,把异步获取数据的操作强制转成同步获取, 跟同步存储数据的原理相同.</p>\n<h3 id=\"同步-异步的从内存中删除指定-key-的对象-或者全部对象\"><a href=\"#同步-异步的从内存中删除指定-key-的对象-或者全部对象\" class=\"headerlink\" title=\"同步/异步的从内存中删除指定 key 的对象,或者全部对象.\"></a>同步/异步的从内存中删除指定 key 的对象,或者全部对象.</h3><p>删除操作也不例外:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!key)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.\"栅栏\"方法,保证线程安全</span></div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 2.根据 key 删除 value</span></div><div class=\"line\">        [strongSelf removeObjectAndExecuteBlocksForKey:key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (block) &#123;</div><div class=\"line\">            __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">// 3.完成后回调</span></div><div class=\"line\">            <span class=\"built_in\">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">                TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">                <span class=\"keyword\">if</span> (strongSelf)</div><div class=\"line\">                    block(strongSelf, key, <span class=\"literal\">nil</span>);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// private API</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectAndExecuteBlocksForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> object = [_dictionary objectForKey:key];</div><div class=\"line\">    <span class=\"built_in\">NSNumber</span> *cost = [_costs objectForKey:key];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (_willRemoveObjectBlock)</div><div class=\"line\">        _willRemoveObjectBlock(<span class=\"keyword\">self</span>, key, object);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (cost)</div><div class=\"line\">        _totalCost -= [cost unsignedIntegerValue];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 删除所有跟此数据相关的缓存: value, date, cost</span></div><div class=\"line\">    [_dictionary removeObjectForKey:key];</div><div class=\"line\">    [_dates removeObjectForKey:key];</div><div class=\"line\">    [_costs removeObjectForKey:key];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (_didRemoveObjectBlock)</div><div class=\"line\">        _didRemoveObjectBlock(<span class=\"keyword\">self</span>, key, <span class=\"literal\">nil</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是 <code>- (void)removeObjectAndExecuteBlocksForKey</code> 是共用私有方法, 删除跟 key 相关的所有缓存, 后面的删除操作还会用到此方法.</p>\n<h3 id=\"设置内存缓存使用上限\"><a href=\"#设置内存缓存使用上限\" class=\"headerlink\" title=\"设置内存缓存使用上限\"></a>设置内存缓存使用上限</h3><p>TMMemoryCache 提供<code>costLimit</code>属性来设置内存缓存使用上限, 这个也是 NSCache 不具备的功能,来看一下跟此属性相关的方法以及实现,代码中有详细解释:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// getter</span></div><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)costLimit &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSUInteger</span> costLimit = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 要想通过函数返回值传递回去,那么必须同步执行,所以使用dispatch_sync同步获取内存使用上限</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_queue, ^&#123;</div><div class=\"line\">        costLimit = _costLimit;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> costLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// setter</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setCostLimit:(<span class=\"built_in\">NSUInteger</span>)costLimit &#123;</div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// \"栅栏\"方法保护写操作</span></div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 设置内存上限</span></div><div class=\"line\">        strongSelf-&gt;_costLimit = costLimit;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (costLimit &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"comment\">// 根据时间排序来削减内存缓存,以达到设置的内存缓存上限的目的</span></div><div class=\"line\">            [strongSelf trimToCostLimitByDate:costLimit];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToCostLimitByDate:(<span class=\"built_in\">NSUInteger</span>)limit &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (_totalCost &lt;= limit)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 按照时间的升序来排列 key</span></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keysSortedByDate = [_dates keysSortedByValueUsingSelector:<span class=\"keyword\">@selector</span>(compare:)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// oldest objects first</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> keysSortedByDate) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> removeObjectAndExecuteBlocksForKey:key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (_totalCost &lt;= limit)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>- (void)trimToCostLimitByDate:(NSUInteger)limit</code> 方法的作用:</p>\n<ol>\n<li>如果目前已使用的内存大小小于需要设置的内存上线,则不删除数据,否则删除’最老’的数据,让已使用的内存大小不超过设置的内存上限.</li>\n<li>按照存储的数据最近操作的最后时间进行升序排序,即最近操作的数据对应的 key 排最后.</li>\n<li>如果已经超过内存上限, 则根据 key 值删除数据, 先删除操作时间较早的数据.</li>\n</ol>\n<p>从这里就会恍然大悟, 之前设置的 <code>_date</code> 数组终于派上用场了,如果需要删除数据则按照时间的先后顺序来删除,也算是一种优先级策略吧.</p>\n<h3 id=\"设置内存缓存过期时间\"><a href=\"#设置内存缓存过期时间\" class=\"headerlink\" title=\"设置内存缓存过期时间\"></a>设置内存缓存过期时间</h3><p>TMMemoryCache 提供<code>ageLimit</code>属性来设置缓存过期时间,根据上面<code>costLimit</code>属性可以猜想一下<code>ageLimit</code>是怎么实现的,既然是要设置缓存过期时间, 那么我设置缓存过期时间 <code>ageLimit = 10</code> 10秒钟,说明距离当前时间之前的10秒的数据已经过期, 需要删除掉; 再过10秒又要当前时间删除之前10秒存的数据,我们知道删除只需要找到 key 就行,所以就必须通过<code>_date</code>字典找到过期的 key, 再删除数据.由此可知需要一个定时器,每过10秒删除一次,完成一个定时任务.<br>上面只是我们的猜想,来看看代码是不是这么实现的呢?我们只需看核心的操作方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToAgeLimitRecursively &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (_ageLimit == <span class=\"number\">0.0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 说明距离现在 ageLimit 秒的缓存应该被清除掉了</span></div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *date = [[<span class=\"built_in\">NSDate</span> alloc] initWithTimeIntervalSinceNow:-_ageLimit];</div><div class=\"line\">    [<span class=\"keyword\">self</span> trimMemoryToDate:date];</div><div class=\"line\">    </div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 延迟 ageLimit 秒, 又异步的清除缓存</span></div><div class=\"line\">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_ageLimit * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">    dispatch_after(time, _queue, ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_barrier_async(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">            TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">            [strongSelf trimToAgeLimitRecursively];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">;``  </div><div class=\"line\">上面的代码验证了我们的猜想,但是在不断的创建定时器,不断的在并行队列中使用`dispatch_barrier_async`栅栏方法提交递归 block, 天啦噜...如果设置的 ageLimit 很小,可想而知性能消耗会非常大!</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">### 内存警告或退到后台清空缓存</span></div><div class=\"line\">内存警告和退到后台需要监听系统通知,`<span class=\"built_in\">UIApplicationDidReceiveMemoryWarningNotification</span>`和`<span class=\"built_in\">UIApplicationDidEnterBackgroundNotification</span>`, 然后执行清除操作方法`removeAllObjects`,只不过在相应的位置执行对应的 will/did 之类的 block 操作.</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">### 根据时间或缓存大小来清空指定时间段或缓存范围的数据</span></div><div class=\"line\">这两类方法主要是为了更加灵活的使用 TMMemoryCache,指定一个时间或者内存大小,会自动删除时间点之前和大于指定内存大小的数据.</div><div class=\"line\">相关 API:</div><div class=\"line\"></div><div class=\"line\">```Objc</div><div class=\"line\"><span class=\"comment\">// 清空 date 之前的数据</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToDate:(<span class=\"built_in\">NSDate</span> *)date block:(TMMemoryCacheBlock)block;</div><div class=\"line\"><span class=\"comment\">// 清空数据,让已使用内存大小为cost </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost block:(TMMemoryCacheBlock)block;</div></pre></td></tr></table></figure>\n<p>删除指定时间点有两点注意:</p>\n<ul>\n<li>如果指定的时间点为 <code>[NSDate distantPast]</code> 表示最早能表示的时间,说明清空全部数据.</li>\n<li>如果不是最早时间,把<code>_date</code>中的 key 按照升序排序,再遍历排序后的 key 数组,判断跟指定时间的关系,如果比指定时间更早则删除, 即删除指定时间节点之前的数据.</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)trimMemoryToDate:(<span class=\"built_in\">NSDate</span> *)trimDate &#123;</div><div class=\"line\">    <span class=\"comment\">// 字典中存放的顺序不是按照顺序存放的, 所以按照一定格式排序, 根据 value 升序的排 key 值顺序, 也就是说根据时间的升序来排 key, 数组中第一个值是最早的时间的值.</span></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keysSortedByDate = [_dates keysSortedByValueUsingSelector:<span class=\"keyword\">@selector</span>(compare:)];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> keysSortedByDate) &#123; <span class=\"comment\">// oldest objects first</span></div><div class=\"line\">        <span class=\"built_in\">NSDate</span> *accessDate = [_dates objectForKey:key];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!accessDate)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 找出每个时间的然后跟要删除的时间点进行比较, 如果比删除时间早则删除</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ([accessDate compare:trimDate] == <span class=\"built_in\">NSOrderedAscending</span>) &#123; <span class=\"comment\">// older than trim date</span></div><div class=\"line\">            [<span class=\"keyword\">self</span> removeObjectAndExecuteBlocksForKey:key];</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>内存缓存是很简单的, 核心就是 key-value 的形式存储数据进字典,再辅助设置内存上限,缓存时间,各类 will/did block 操作, 最重要的是要实现线程安全.</p>\n<p>欢迎大家斧正!</p>\n","excerpt":"<p>缓存是我们移动端开发必不可少的功能, 目前提及的缓存按照存储形式来分主要分为:</p>\n<ul>\n<li>内存缓存: 快速, 读写数据量小</li>\n<li>磁盘缓存: 慢速, 读写数据量大(慢速是相对于内存缓存而言)</li>\n</ul>\n<p>那缓存的目的是什么呢? 大概分为以下几点:</p>\n<ul>\n<li>复用数据,避免重复计算.</li>\n<li>缓解服务端压力.</li>\n<li>提高用户体验,比如离线浏览, 节省流量等等.</li>\n</ul>\n<p>简言之,缓存的目的就是:</p>\n<blockquote>\n<p>以空间换时间.  </p>\n</blockquote>","more":"<p>目前 gitHub 上开源了很多缓存框架, 著名的 <a href=\"https://github.com/tumblr/TMCache\">TMCache</a>, <a href=\"https://github.com/pinterest/PINCache\">PINCache</a>, <a href=\"https://github.com/ibireme/YYCache\">YYCache</a>等, 接下来我会逐一分析他们的源码实现, 对比它们的优缺点.  </p>\n<p><a href=\"https://github.com/tumblr/TMCache\">TMCache</a>, <a href=\"https://github.com/pinterest/PINCache\">PINCache</a>, <a href=\"https://github.com/ibireme/YYCache\">YYCache</a>基本框架结构都相同, 接口 API 类似, 所以只要会使用其中一个框架, 另外两个上手起来非常容易, 但是三个框架的内部实现原理略有不同.</p>\n<h3 id=\"TMMemoryCache\"><a href=\"#TMMemoryCache\" class=\"headerlink\" title=\"TMMemoryCache\"></a>TMMemoryCache</h3><p><code>TMMemoryCache</code> 是 <code>TMCache</code> 框架中针对内存缓存的实现, 在系统 <code>NSCache</code> 缓存的基础上增加了很多方法和属性, 比如数量限制、内存总容量限制、缓存存活时间限制、内存警告或应用退到后台时清空缓存等功能. 并且<code>TMMemoryCache</code>能够同步和异步的对内存数据进行操作,最重要的一点是<code>TMMemoryCache</code>是线程安全的, 能够确保在多线程情况下数据的安全性.  </p>\n<p>首先来看一下 <code>TMMemoryCache</code> 提供什么功能, 按照功能来分析它的实现原理:</p>\n<ol>\n<li>同步/异步的存储对象到内存中.</li>\n<li>同步/异步的从内存中获取对象.</li>\n<li>同步/异步的从内存中删除指定 key 的对象,或者全部对象.</li>\n<li>增加/删除数据, 内存警告, 退回后台的异步回调事件.</li>\n<li>设置内存缓存使用上限.</li>\n<li>设置内存缓存过期时间.</li>\n<li>内存警告或退到后台清空缓存.</li>\n<li>根据时间或缓存大小来清空指定时间段或缓存范围的数据.</li>\n</ol>\n<h3 id=\"同步-异步的存储对象到内存中\"><a href=\"#同步-异步的存储对象到内存中\" class=\"headerlink\" title=\"同步/异步的存储对象到内存中\"></a>同步/异步的存储对象到内存中</h3><p>相关 API:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同步</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 异步</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost block:(TMMemoryCacheObjectBlock)block;</div></pre></td></tr></table></figure>\n<h4 id=\"异步存储\"><a href=\"#异步存储\" class=\"headerlink\" title=\"异步存储\"></a>异步存储</h4><p>首先看一下异步存储对象, 因为同步存储里面会调用异步存储操作, 采用 <code>dispatch_semaphore</code> 信号量的方式强制把异步操作转换成同步操作.<br>内存缓存的核心是创建字典把需要存储的对象按照 key, value的形式存进字典中, 这是一条主线, 然后在主线上分发出许多分支, 比如:缓存时间, 缓存大小, 线程安全等, 都是围绕着这条主线来的. TMMemoryCache 也不例外, 在调用<code>+ (instancetype)sharedCache</code>方法创建并初始化的时候会创建三个可变字典<code>_dictionary</code>, <code>_dates</code>, <code>_costs</code>,这三个字典分别保存三种键值对:   </p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Key</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_dictionary</td>\n<td>存储对象的 key</td>\n<td>存储对象的值</td>\n</tr>\n<tr>\n<td>_dates</td>\n<td>存储对象的 key</td>\n<td>存储对象时的时间</td>\n</tr>\n<tr>\n<td>_costs</td>\n<td>存储对象的 key</td>\n<td>存储对象所占内存大小</td>\n</tr>\n</tbody>\n</table>\n<p>实现数据存储的核心方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost block:(TMMemoryCacheObjectBlock)block &#123;</div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *now = [[<span class=\"built_in\">NSDate</span> alloc] init];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!key || !object)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 0.竞态条件下, 在并发队列中保护写操作</span></div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 1.调用 will add block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (strongSelf-&gt;_willAddObjectBlock)</div><div class=\"line\">            strongSelf-&gt;_willAddObjectBlock(strongSelf, key, object);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 2.存储 key 对应的数据,时间,缓存大小到相应的字典中</span></div><div class=\"line\">        [strongSelf-&gt;_dictionary setObject:object forKey:key];</div><div class=\"line\">        [strongSelf-&gt;_dates setObject:now forKey:key];</div><div class=\"line\">        [strongSelf-&gt;_costs setObject:@(cost) forKey:key];</div><div class=\"line\"></div><div class=\"line\">        _totalCost += cost;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 3.调用 did add block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (strongSelf-&gt;_didAddObjectBlock)</div><div class=\"line\">            strongSelf-&gt;_didAddObjectBlock(strongSelf, key, object);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 4.根据时间排序来清空指定缓存大小的内存</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (strongSelf-&gt;_costLimit &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            [strongSelf trimToCostByDate:strongSelf-&gt;_costLimit block:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 5.异步回调</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (block) &#123;</div><div class=\"line\">            __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">            <span class=\"built_in\">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">                TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">                <span class=\"keyword\">if</span> (strongSelf)</div><div class=\"line\">                    block(strongSelf, key, object);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中我标出了核心存储方法做了几件事, 其中最为核心的是保证线程安全的<code>dispatch_barrier_async</code>方法, 在 GCD 中称之为<code>栅栏</code>方法, 一般跟<code>并发队列</code>一起用, 在多线程中对同一资源的竞争条件下保护共享资源, 确保在同一时间片段只有一个线程<code>写</code>资源, 这是不扩展讲 GCD 的相关知识.</p>\n<blockquote>\n<p>dispatch_barrier_async 方法一般都是跟并发队列搭配使用,下面的图解很清晰(<code>侵删</code>), 在并发队列中有很多任务(block), 这些block都是按照 FIFO 的顺序执行的, 当要执行用 dispatch_barrier_async 方法提交到并发队列queue的 block 的时候, 该并发队列暂时会’卡住’, 等待之前的任务 block 执行完毕, 再执行dispatch_barrier_async 提交的 block, 在此 block 之后提交到并发队列queue的 block 不会被执行,会一直等待 dispatch_barrier_async block 执行完毕后才开始并发执行, 我们可以看出, 在并发队列遇到 dispatch_barrier_async block 时就处于一直串行队列状态, 等待执行完毕后又开始并发执行.<br>由于TMMemoryCache中所有的读写操作都是在一个 concurrent queue(并发队列)中, 所以使用 <code>dispatch_barrier_async</code> 能够保证写操作的线程安全, 在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心, 但也是它最大的毛病, 容易造成性能下降和死锁.<br><img src=\"https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67\" alt=\"dispatch_barrier_async\"></p>\n</blockquote>\n<p>从上面代码中可以看出, 在该方法中把需要存储的数据按照 key-value 的形式存储进了<code>_dictionary</code>字典中, 其它操作无非就是增加功能的配料,后面会抽丝剥茧的捋清楚, 到此处我们的任务完成, 知道是怎么存储数据的, 非常简单:</p>\n<ol>\n<li>使用 GCD 的 <code>dispatch_barrier_async</code> 方法保证写操作线程安全.</li>\n<li>把需要存储的数据存进可变字典中.</li>\n</ol>\n<h4 id=\"同步存储\"><a href=\"#同步存储\" class=\"headerlink\" title=\"同步存储\"></a>同步存储</h4><p>根据上文所说, 同步存储中会调用异步存储操作, 来看一下代码:  </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"built_in\">NSString</span> *)key withCost:(<span class=\"built_in\">NSUInteger</span>)cost &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!object || !key)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.创建信号量</span></div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 2.异步存数据</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, <span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span> object) &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 3.异步存储完毕发送 signal 信号</span></div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 4.等待异步存储完毕</span></div><div class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面代码可以看出,同步的存储数据使用了 GCD 的 <code>dispatch_semaphore_t</code> 信号量, 这是一个非常古老又复杂的线程概念, 有兴趣的话可以看看 <code>&lt;&lt;UNIX 环境高级编程&gt;&gt;</code> 这本经典之作, 因为它的复杂是建立在操作系统的复杂性上的.但是这并不影响我们使用 dispatch_semaphore_t 信号量. 怎么使用 GCD 的信号量以及原理下面大概描述一下:</p>\n<blockquote>\n<p>信号量在竞态条件下能够保证线程安全,在创建信号量 dispatch_semaphore_create 的时候设置信号量的值, 这个值表示允许多少个线程可同时访问公共资源, 就好比我们的车位一样, 线程就是我们的车子,这个信号量就是停车场的管理者, 他知道什么时候有多少车位, 是不是该把车子放进停车场, 当没有车位或者车位不足时, 这个管理员就会把司机卡在停车场外不准进, 那么被拦住的司机按照 FIFO 的队列排着队, 有足够位置的时候,管理员就方法闸门, 大吼一声: 孩子们去吧. 那么肯定有司机等不耐烦了, 就想着等十分钟没有车位就不等了,就可以在 dispatch_semaphore_wait 方法中设置等待时间, 等待超过设置时间就不等待.<br>那么把上面的场景应用在 dispatch_semaphore_create 信号量中就很容易理解了, 创建信号量并设置最大并发线程数, dispatch_semaphore_wait 设置等待时间,在等待时间未到达或者信号量值没有达到初始值时会一直等待, 调用 dispatch_semaphore_wait 方法会使信号量的值+1, 表示增加一个线程等待处理共用资源, 当 dispatch_semaphore_signal 时会使信号量的值-1, 表示该线程不再占用共用资源.</p>\n</blockquote>\n<p>根据上面对 dispatch_semaphore_t 信号量的描述可知, 信号量的初始值为0,当前线程执行 dispatch_semaphore_wait 方法就会一直等待, 此时就相当于同步操作, 当在并发队列中异步存储完数据调用dispatch_semaphore_signal 方法, 此时信号量的值变成0,跟初始值一样,当前线程立即结束等待, 同步设置方法执行完毕.  </p>\n<p>其实同步实现存储数据的方式很多, 主要就是要串行执行写操作采用 dispatch_sync的方式, 但是基于 TMMemoryCache 所有的操作都是在并发队列上的, 所以才采用信号量的方式.</p>\n<p>其实只要知道<code>dispatch_barrier_async</code>, <code>dispatch_semaphore_t</code> 的用法,后面的都可以不用看了, 自己去找源码看看就明白了.</p>\n<hr>\n<p>休息一下吧,后面的简单了</p>\n<hr>\n<h3 id=\"同步-异步的从内存中获取对象\"><a href=\"#同步-异步的从内存中获取对象\" class=\"headerlink\" title=\"同步/异步的从内存中获取对象.\"></a>同步/异步的从内存中获取对象.</h3><p>有了上面的同步/异步存储的理论, 那么同步/异步获取对象简直易如反掌, 不就是从<code>_dictionary</code>字典中根据 key 取出对应的 value 值, 在取的过程中加以线程安全, will/did 之类辅助处理的 block 操作.</p>\n<h4 id=\"异步获取数据\"><a href=\"#异步获取数据\" class=\"headerlink\" title=\"异步获取数据\"></a>异步获取数据</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block &#123;</div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *now = [[<span class=\"built_in\">NSDate</span> alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!key || !block)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.异步加载存储数据</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 2.根据 key 找到value</span></div><div class=\"line\">        <span class=\"keyword\">id</span> object = [strongSelf-&gt;_dictionary objectForKey:key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (object) &#123;</div><div class=\"line\">            __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">            <span class=\"comment\">// 3.也用栅栏保护写操作, 保证在写的时候没有线程在访问共享资源</span></div><div class=\"line\">            dispatch_barrier_async(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">                TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">                <span class=\"keyword\">if</span> (strongSelf)</div><div class=\"line\">                    <span class=\"comment\">// 4.更新数据的最后操作时间(当前时间)</span></div><div class=\"line\">                    [strongSelf-&gt;_dates setObject:now forKey:key];</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 5.回调</span></div><div class=\"line\">        block(strongSelf, key, object);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据代码中注释可知,除了拿到 key 值对应的 value, 还更新了此数据最后操作时间, 这有什么用呢? 其实是为了记录数据最后的操作时间, 后面会根据这个最后操作时间来删除数据等一系列根据时间排序的操作.最后一步是回调, 我们可以看到, TMMemoryCache所有的读写和回调操作都放在同一个并发队列中,这就为以后性能下降和死锁埋下伏笔.</p>\n<h4 id=\"同步获取数据\"><a href=\"#同步获取数据\" class=\"headerlink\" title=\"同步获取数据\"></a>同步获取数据</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)objectForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!key)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">    __block <span class=\"keyword\">id</span> objectForKey = <span class=\"literal\">nil</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 采用信号量强制转化成同步操作</span></div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    [<span class=\"keyword\">self</span> objectForKey:key block:^(TMMemoryCache *cache, <span class=\"built_in\">NSString</span> *key, <span class=\"keyword\">id</span> object) &#123;</div><div class=\"line\">        objectForKey = object;</div><div class=\"line\">        dispatch_semaphore_signal(semaphore);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> objectForKey;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同步获取数据也是通过 <code>dispatch_semaphore_t</code> 信号量的方式,把异步获取数据的操作强制转成同步获取, 跟同步存储数据的原理相同.</p>\n<h3 id=\"同步-异步的从内存中删除指定-key-的对象-或者全部对象\"><a href=\"#同步-异步的从内存中删除指定-key-的对象-或者全部对象\" class=\"headerlink\" title=\"同步/异步的从内存中删除指定 key 的对象,或者全部对象.\"></a>同步/异步的从内存中删除指定 key 的对象,或者全部对象.</h3><p>删除操作也不例外:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectForKey:(<span class=\"built_in\">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!key)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.\"栅栏\"方法,保证线程安全</span></div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 2.根据 key 删除 value</span></div><div class=\"line\">        [strongSelf removeObjectAndExecuteBlocksForKey:key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (block) &#123;</div><div class=\"line\">            __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">// 3.完成后回调</span></div><div class=\"line\">            <span class=\"built_in\">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">                TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">                <span class=\"keyword\">if</span> (strongSelf)</div><div class=\"line\">                    block(strongSelf, key, <span class=\"literal\">nil</span>);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// private API</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectAndExecuteBlocksForKey:(<span class=\"built_in\">NSString</span> *)key &#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> object = [_dictionary objectForKey:key];</div><div class=\"line\">    <span class=\"built_in\">NSNumber</span> *cost = [_costs objectForKey:key];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (_willRemoveObjectBlock)</div><div class=\"line\">        _willRemoveObjectBlock(<span class=\"keyword\">self</span>, key, object);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (cost)</div><div class=\"line\">        _totalCost -= [cost unsignedIntegerValue];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 删除所有跟此数据相关的缓存: value, date, cost</span></div><div class=\"line\">    [_dictionary removeObjectForKey:key];</div><div class=\"line\">    [_dates removeObjectForKey:key];</div><div class=\"line\">    [_costs removeObjectForKey:key];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (_didRemoveObjectBlock)</div><div class=\"line\">        _didRemoveObjectBlock(<span class=\"keyword\">self</span>, key, <span class=\"literal\">nil</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是 <code>- (void)removeObjectAndExecuteBlocksForKey</code> 是共用私有方法, 删除跟 key 相关的所有缓存, 后面的删除操作还会用到此方法.</p>\n<h3 id=\"设置内存缓存使用上限\"><a href=\"#设置内存缓存使用上限\" class=\"headerlink\" title=\"设置内存缓存使用上限\"></a>设置内存缓存使用上限</h3><p>TMMemoryCache 提供<code>costLimit</code>属性来设置内存缓存使用上限, 这个也是 NSCache 不具备的功能,来看一下跟此属性相关的方法以及实现,代码中有详细解释:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// getter</span></div><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)costLimit &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSUInteger</span> costLimit = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 要想通过函数返回值传递回去,那么必须同步执行,所以使用dispatch_sync同步获取内存使用上限</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_queue, ^&#123;</div><div class=\"line\">        costLimit = _costLimit;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> costLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// setter</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setCostLimit:(<span class=\"built_in\">NSUInteger</span>)costLimit &#123;</div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// \"栅栏\"方法保护写操作</span></div><div class=\"line\">    dispatch_barrier_async(_queue, ^&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 设置内存上限</span></div><div class=\"line\">        strongSelf-&gt;_costLimit = costLimit;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (costLimit &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"comment\">// 根据时间排序来削减内存缓存,以达到设置的内存缓存上限的目的</span></div><div class=\"line\">            [strongSelf trimToCostLimitByDate:costLimit];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToCostLimitByDate:(<span class=\"built_in\">NSUInteger</span>)limit &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (_totalCost &lt;= limit)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 按照时间的升序来排列 key</span></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keysSortedByDate = [_dates keysSortedByValueUsingSelector:<span class=\"keyword\">@selector</span>(compare:)];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// oldest objects first</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> keysSortedByDate) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> removeObjectAndExecuteBlocksForKey:key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (_totalCost &lt;= limit)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>- (void)trimToCostLimitByDate:(NSUInteger)limit</code> 方法的作用:</p>\n<ol>\n<li>如果目前已使用的内存大小小于需要设置的内存上线,则不删除数据,否则删除’最老’的数据,让已使用的内存大小不超过设置的内存上限.</li>\n<li>按照存储的数据最近操作的最后时间进行升序排序,即最近操作的数据对应的 key 排最后.</li>\n<li>如果已经超过内存上限, 则根据 key 值删除数据, 先删除操作时间较早的数据.</li>\n</ol>\n<p>从这里就会恍然大悟, 之前设置的 <code>_date</code> 数组终于派上用场了,如果需要删除数据则按照时间的先后顺序来删除,也算是一种优先级策略吧.</p>\n<h3 id=\"设置内存缓存过期时间\"><a href=\"#设置内存缓存过期时间\" class=\"headerlink\" title=\"设置内存缓存过期时间\"></a>设置内存缓存过期时间</h3><p>TMMemoryCache 提供<code>ageLimit</code>属性来设置缓存过期时间,根据上面<code>costLimit</code>属性可以猜想一下<code>ageLimit</code>是怎么实现的,既然是要设置缓存过期时间, 那么我设置缓存过期时间 <code>ageLimit = 10</code> 10秒钟,说明距离当前时间之前的10秒的数据已经过期, 需要删除掉; 再过10秒又要当前时间删除之前10秒存的数据,我们知道删除只需要找到 key 就行,所以就必须通过<code>_date</code>字典找到过期的 key, 再删除数据.由此可知需要一个定时器,每过10秒删除一次,完成一个定时任务.<br>上面只是我们的猜想,来看看代码是不是这么实现的呢?我们只需看核心的操作方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToAgeLimitRecursively &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (_ageLimit == <span class=\"number\">0.0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 说明距离现在 ageLimit 秒的缓存应该被清除掉了</span></div><div class=\"line\">    <span class=\"built_in\">NSDate</span> *date = [[<span class=\"built_in\">NSDate</span> alloc] initWithTimeIntervalSinceNow:-_ageLimit];</div><div class=\"line\">    [<span class=\"keyword\">self</span> trimMemoryToDate:date];</div><div class=\"line\">    </div><div class=\"line\">    __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 延迟 ageLimit 秒, 又异步的清除缓存</span></div><div class=\"line\">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_ageLimit * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">    dispatch_after(time, _queue, ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">        TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!strongSelf)</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        </div><div class=\"line\">        __<span class=\"keyword\">weak</span> TMMemoryCache *weakSelf = strongSelf;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_barrier_async(strongSelf-&gt;_queue, ^&#123;</div><div class=\"line\">            TMMemoryCache *strongSelf = weakSelf;</div><div class=\"line\">            [strongSelf trimToAgeLimitRecursively];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">;``  </div><div class=\"line\">上面的代码验证了我们的猜想,但是在不断的创建定时器,不断的在并行队列中使用`dispatch_barrier_async`栅栏方法提交递归 block, 天啦噜...如果设置的 ageLimit 很小,可想而知性能消耗会非常大!</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">### 内存警告或退到后台清空缓存</span></div><div class=\"line\">内存警告和退到后台需要监听系统通知,`<span class=\"built_in\">UIApplicationDidReceiveMemoryWarningNotification</span>`和`<span class=\"built_in\">UIApplicationDidEnterBackgroundNotification</span>`, 然后执行清除操作方法`removeAllObjects`,只不过在相应的位置执行对应的 will/did 之类的 block 操作.</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">### 根据时间或缓存大小来清空指定时间段或缓存范围的数据</span></div><div class=\"line\">这两类方法主要是为了更加灵活的使用 TMMemoryCache,指定一个时间或者内存大小,会自动删除时间点之前和大于指定内存大小的数据.</div><div class=\"line\">相关 API:</div><div class=\"line\"></div><div class=\"line\">```Objc</div><div class=\"line\"><span class=\"comment\">// 清空 date 之前的数据</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToDate:(<span class=\"built_in\">NSDate</span> *)date block:(TMMemoryCacheBlock)block;</div><div class=\"line\"><span class=\"comment\">// 清空数据,让已使用内存大小为cost </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)trimToCost:(<span class=\"built_in\">NSUInteger</span>)cost block:(TMMemoryCacheBlock)block;</div></pre></td></tr></table></figure>\n<p>删除指定时间点有两点注意:</p>\n<ul>\n<li>如果指定的时间点为 <code>[NSDate distantPast]</code> 表示最早能表示的时间,说明清空全部数据.</li>\n<li>如果不是最早时间,把<code>_date</code>中的 key 按照升序排序,再遍历排序后的 key 数组,判断跟指定时间的关系,如果比指定时间更早则删除, 即删除指定时间节点之前的数据.</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)trimMemoryToDate:(<span class=\"built_in\">NSDate</span> *)trimDate &#123;</div><div class=\"line\">    <span class=\"comment\">// 字典中存放的顺序不是按照顺序存放的, 所以按照一定格式排序, 根据 value 升序的排 key 值顺序, 也就是说根据时间的升序来排 key, 数组中第一个值是最早的时间的值.</span></div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *keysSortedByDate = [_dates keysSortedByValueUsingSelector:<span class=\"keyword\">@selector</span>(compare:)];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> keysSortedByDate) &#123; <span class=\"comment\">// oldest objects first</span></div><div class=\"line\">        <span class=\"built_in\">NSDate</span> *accessDate = [_dates objectForKey:key];</div><div class=\"line\">        <span class=\"keyword\">if</span> (!accessDate)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 找出每个时间的然后跟要删除的时间点进行比较, 如果比删除时间早则删除</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ([accessDate compare:trimDate] == <span class=\"built_in\">NSOrderedAscending</span>) &#123; <span class=\"comment\">// older than trim date</span></div><div class=\"line\">            [<span class=\"keyword\">self</span> removeObjectAndExecuteBlocksForKey:key];</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>内存缓存是很简单的, 核心就是 key-value 的形式存储数据进字典,再辅助设置内存上限,缓存时间,各类 will/did block 操作, 最重要的是要实现线程安全.</p>\n<p>欢迎大家斧正!</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cizozpebf0007k4exc8vvrusy","category_id":"cizozpeb90004k4exjqy1l95q","_id":"cizozpebm000ck4ex7hv622fn"},{"post_id":"cizozpeay0000k4ex0dhaby1i","category_id":"cizozpeb90004k4exjqy1l95q","_id":"cizozpebp000fk4ex0121z1pq"},{"post_id":"cizozpebh0008k4exobfp1vkz","category_id":"cizozpeb90004k4exjqy1l95q","_id":"cizozpebr000gk4exp5zqd7a9"},{"post_id":"cizozpeb50002k4exaddm0eme","category_id":"cizozpebl0009k4ex1rdrual9","_id":"cizozpebz000ik4exs0farr3b"},{"post_id":"cizozpebd0006k4exfx362u3s","category_id":"cizozpebl0009k4ex1rdrual9","_id":"cizozpec0000kk4exy5aqthf6"}],"PostTag":[{"post_id":"cizozpeay0000k4ex0dhaby1i","tag_id":"cizozpebd0005k4exhigm7f87","_id":"cizozpebm000bk4ex9v0yus35"},{"post_id":"cizozpeb50002k4exaddm0eme","tag_id":"cizozpebl000ak4exlzrm5k3f","_id":"cizozpebz000jk4exkvetj0zy"},{"post_id":"cizozpeb50002k4exaddm0eme","tag_id":"cizozpebn000ek4exrx6b4em6","_id":"cizozpec0000lk4exhdxbjtr9"},{"post_id":"cizozpebd0006k4exfx362u3s","tag_id":"cizozpebt000hk4exhdpelxrx","_id":"cizozpec1000ok4exhhfxz8r9"},{"post_id":"cizozpebd0006k4exfx362u3s","tag_id":"cizozpebl000ak4exlzrm5k3f","_id":"cizozpec2000pk4exxt6vcxdd"},{"post_id":"cizozpebf0007k4exc8vvrusy","tag_id":"cizozpec1000nk4ex9lznse5o","_id":"cizozpec4000sk4exjhigsbjn"},{"post_id":"cizozpebf0007k4exc8vvrusy","tag_id":"cizozpec2000qk4ex1c8vun2k","_id":"cizozpec4000tk4ex2rbzapea"},{"post_id":"cizozpebh0008k4exobfp1vkz","tag_id":"cizozpec1000nk4ex9lznse5o","_id":"cizozpec6000vk4exzujy7cl2"},{"post_id":"cizozpebh0008k4exobfp1vkz","tag_id":"cizozpec2000qk4ex1c8vun2k","_id":"cizozpec6000wk4exh27dluyw"}],"Tag":[{"name":"RunLoop","_id":"cizozpebd0005k4exhigm7f87"},{"name":"Swift","_id":"cizozpebl000ak4exlzrm5k3f"},{"name":"关联对象","_id":"cizozpebn000ek4exrx6b4em6"},{"name":"UserDefaults","_id":"cizozpebt000hk4exhdpelxrx"},{"name":"TMCache","_id":"cizozpec1000nk4ex9lznse5o"},{"name":"缓存","_id":"cizozpec2000qk4ex1c8vun2k"}]}}